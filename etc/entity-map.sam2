# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Entity map converter
#
# This program accepts the `entity-map.txt` file as input, outputting a
# (very large) map literal corresponding to its contents.
#

SELF_PATH, ARGS* ::

# Map for converting hex characters to lower case.
def LOWER_CASE_MAP = [A: "a", B: "b", C: "c", D: "d", E: "e", F: "f"];

# Parses the end of a line, which consists of any number of spaces, optionally
# followed by a comment, and finally followed by a newline.
def parLineEnd = {/
    " "*
    ("#" [! "\n"]*)?
    "\n"
/};

# Parses a comma, optionally surrounded by whitespace.
def parComma = {/
    " "*
    ","
    " "*
/};

# Parses a single code point, yielding the hex constant as a string. Leading
# zeroes are omitted from the result.
def parCodePoint = {/
    " "*
    "U+"
    "0"*
    digits = (
        ch = ["0".."9" "A".."F"]
        {
            def value = tokenType(ch);
            <> mapGet(LOWER_CASE_MAP, value, value)
        }
    )+

    {
        def result = stringAdd(digits*);
        <> if (result == "") { <> "0" } else { <> result }
    }
/};

# Parses a list of code points, yielding a string containing a "\x...;"
# form.
def parCodePoints = {/
    codes = parCodePoint+
    {
        def value = listReduce("", codes) { result, index, code ::
            <> stringAdd(
                result,
                (if (index != 0) { <> "," })?*,
                code)
        };
        <> stringAdd("\\x", value, ";")
    }
/};

# Parses an entry description.
def parDescription = {/
    [! ",\n"]*
/};

# Parses an entity name.
def parName = {/
    chars = ["a".."z" "A".."Z" "0".."9" "."]+
    { <> stringFromTokenList(chars) }
/};

# Parses a single content line.
def parContentLine = {/
    string = parCodePoints
    parComma
    parDescription
    names = (parComma parName)+
    { <> [names*: string] }
/};

# Parses the entire file.
def parFile = {/
    lines = (
        # Skip empty lines.
        parLineEnd*
        parContentLine
    )*

    # Skip trailing empty lines.
    parLineEnd*

    (
        extras = [! "\n"]+
        {
            def string = stringFromTokenList(extras);
            io0Die(format("Unexpected line: %q", string))
        }
    )?

    { <> mapAdd(lines*) }
/};

def inPath = [listButLast(SELF_PATH)*, "entity-map.txt"];
def outPath = [listButLast(SELF_PATH)*, "entity-map-processed.txt"];
io0Note(format("Processing file: %q", inPath));

def text = io0ReadFileUtf8(inPath);
def result = pegApply(parFile, text);

def resultText = mapReduce("", result) { result, key, value ::
    def line = format("    \"%s\" = \"%s\"\n", key, value);
    <> stringAdd(result, line);
};

def outText = format("# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>
#
# GENERATED FILE. DO NOT MODIFY DIRECTLY.
# GENERATED FILE. DO NOT MODIFY DIRECTLY.
# GENERATED FILE. DO NOT MODIFY DIRECTLY.
#
# This file was generated with the entity-map program based on the
# entity-map.txt file as input. Rerun that program should the contents
# of this file need to be updated.

XML_ENTITIES = [
%s
];

<> [ XML_ENTITIES: XML_ENTITIES ]
",
resultText);

io0WriteFileUtf8(outPath, outText);

<> 0
