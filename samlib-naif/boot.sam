## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 0 Core Library
##
## This is a Samizdat Layer 0 program which defines all the
## core library functions and other bindings that aren't primitive.
## It returns the default global variable environment.
##

## The following declares the arguments passed to the library itself.
##
## * `PRIMITIVE_CONTEXT` is expected to be a map of all primitively-defined
##   variables. All these variables are also defined in the variable context
##   in which this file is evaluated.
##
## * `LIBRARY_PATH` is expected to be an absolute path (in the form of a list
##   of string components) naming the directory where library files are to be
##   found.

PRIMITIVE_CONTEXT, LIBRARY_PATH ->


##
## Private Definitions
##

## Flattens an absolute path to a simple name, optionally adding a suffix
## to the final path component.
##
## **Note:** This function is a (low rent) duplicate of functionality in
## `Io*` modules, because this function needs to be called before the `Io*`
## modules are loaded.
fn flattenPath(path, optSuffix?) {
    ## Prefix each component with `/`, and concatenate them all together.
    def withSlashes = collect(path, { elem <> cat("/", elem) });
    <> cat(withSlashes*, optSuffix*);
};

## Loads the named binary file if it exists.
fn loadBinaryIfPossible(name) {
    def path = flattenPath([LIBRARY_PATH*, name]);

    <> ifIs { <> Io0_flatFileExists(path) }
        { <> Lang0_evalBinary(PRIMITIVE_CONTEXT, path) }
};

## Reads and evaluates the named library file.
fn loadLibraryFile(name) {
    def path = flattenPath([LIBRARY_PATH*, name]);

    ifNot { <> Io0_flatFileExists(path) }
        { Io0_die(cat("No such core library file: ", path)) };

    def text = Io0_flatReadFileUtf8(path);
    def tree = Lang0_parseProgram(text);
    <> Lang0_eval(PRIMITIVE_CONTEXT, tree);
};

## Reads and evaluates the module system definition. Can handle it being
## either interpreted or binary.
fn makeModuleSystem() {
    def baseName = "modules/core/ModuleSystem/main.";
    def function = ifValueOr
        { <> loadBinaryIfPossible(cat(baseName, "samb")) }
        { <> loadLibraryFile(cat(baseName, "sam")) };

    <> function()
};

## Builds the core library, by treating it as a module definition to be
## loaded. The module exports `init`, which is called to produce the final
## global variable environment.
fn makeCoreLibrary() {
    def moduleSystem = makeModuleSystem();
    def loader =
        moduleSystem::makeIntraLoader(
            LIBRARY_PATH,
            @Null,    ## `null` isn't yet defined when this file is parsed.
            PRIMITIVE_CONTEXT);

    <> moduleSystem::intraLoadMain(loader)::init(LIBRARY_PATH)
};


##
## Main Definition
##

Io0_note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

Io0_note("    [fin]");
Io0_note("");

<> CORE_LIBRARY
