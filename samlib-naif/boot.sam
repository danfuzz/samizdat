## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 0 Core Library
##
## This is a Samizdat Layer 0 program which defines all the
## core library functions and other bindings that aren't primitive.
## It returns the default global variable environment.
##

## The following declares the arguments passed to the library itself.
##
## * `PRIMITIVE_CONTEXT` is expected to be a map of all primitively-defined
##   variables. All these variables are also defined in the variable context
##   in which this file is evaluated.
##
## * `LIBRARY_FLAT_DIR` is expected to be a flat path (simple string with
##   slashes separating components) naming the directory where library files
##   are to be found.

PRIMITIVE_CONTEXT, LIBRARY_FLAT_DIR ->


##
## Private Definitions
##

## Converts an unstructured string into a list-of-strings, by delimiting on
## the given character. Empty strings are discarded from the result list.
fn splitString(string, delimCh) {
    ## Appends `one` to the end of `list`, ignoring empty strings.
    fn appendNonempty(list, one) {
        <> ifIs { <> eq(one, "") }
            { <> list }
            { <> [list*, one] }
    };

    var str = string;
    var result = [];
    var nextItem = "";

    loop {
        ifIs { <> eq(str, "") }
            { return appendNonempty(result, nextItem) };

        def ch = Sequence_nth(str, 0);
        str := Sequence_sliceInclusive(str, 1);

        ifIs { <> eq(ch, delimCh) }
            {
                result := appendNonempty(result, nextItem);
                nextItem := ""
            }
            { nextItem := cat(nextItem, ch) }
    }
};

## Converts a flat path into an absolute structured (list of components)
## version. This prepends the current directory if the given path is
## not absolute.
fn convertFlatPath(flat) {
    def flatAbs = ifIs { <> eq(Sequence_nth(flat, 0), "/") }
        { <> flat }
        { <> cat(Io0_flatCwd(), "/", flat) };
    <> splitString(flatAbs, "/")
};

## Loads the named binary file if it exists.
fn loadBinaryIfPossible(name) {
    def path = cat(LIBRARY_FLAT_DIR, "/", name);

    <> ifIs { <> Io0_flatFileExists(path) }
        { <> Lang0_evalBinary(PRIMITIVE_CONTEXT, path) }
};

## Reads and evaluates the named library file.
fn loadLibraryFile(name) {
    def path = cat(LIBRARY_FLAT_DIR, "/", name);

    ifNot { <> Io0_flatFileExists(path) }
        { Io0_die(cat("No such core library file: ", path)) };

    def text = Io0_flatReadFileUtf8(path);
    def tree = Lang0_parseProgram(text);
    <> Lang0_eval(PRIMITIVE_CONTEXT, tree);
};

## Reads and evaluates the module system definition. Can handle it being
## either interpreted or binary.
fn makeModuleSystem() {
    def baseName = "modules/core/ModuleSystem/main.";
    def function = ifValueOr
        { <> loadBinaryIfPossible(cat(baseName, "samb")) }
        { <> loadLibraryFile(cat(baseName, "sam")) };

    <> function()
};

## Builds the core library, by treating it as a module definition to be
## loaded. The module exports `init`, which is called to produce the final
## global variable environment.
fn makeCoreLibrary() {
    def libraryDir = convertFlatPath(LIBRARY_FLAT_DIR);
    def moduleSystem = makeModuleSystem();
    def loader =
        moduleSystem::makeIntraLoader(
            libraryDir,
            @Null,    ## `null` isn't yet defined when this file is parsed.
            PRIMITIVE_CONTEXT);

    <> moduleSystem::intraLoadMain(loader)::init(libraryDir)
};


##
## Main Definition
##

Io0_note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

Io0_note("    [fin]");
Io0_note("");

<> CORE_LIBRARY
