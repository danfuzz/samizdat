## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 tree parser
##

def Io0 = moduleUse({name: ["core", "Io0"]});

def tokenize = submoduleUse("tokenize")::tokenize;


##
## Private Definitions
##

## Reports the given list of pending tokens as part of error processing.
fn reportError(pending) {
    Io0::note("Pending tokens:");

    Generator::filterPump(pending, Range::makeInclusiveRange(1, 50))
        { token, . -> Io0::note(cat("    ", Format::source(token))) };

    Io0::die("\nExtra tokens at end of program.")
};

## Set-like map of all lowercase identifier characters. Used to figure
## out if we're looking at a keyword in the `identifierString` rule.
def LOWER_ALPHA = {
    (Range::makeInclusiveRange("a", "z"))*: true
};

## Returns an `interpolate` node.
fn makeInterpolate(value) {
    <> @interpolate{value}
};

## Returns a `literal` node.
fn makeLiteral(value) {
    <> @literal{value}
};

## Returns a node representing a thunk (no-arg function) that returns the
## expression represented by the given node.
fn makeThunk(expression) {
    <> @closure{formals: [], statements: [], yield: expression}
};

## Returns a `varBind` node.
fn makeVarBind(name, value) {
    <> @varBind{name, value}
};

## Returns a `varDef` node.
fn makeVarDef(name, optValue?) {
    <> ifValue { <> optValue* }
        { value <> @varDef{name, value} }
        { <> @varDef{name} }
};

## Returns a `varDefMutable` node.
fn makeVarDefMutable(name, optValue?) {
    <> ifValue { <> optValue* }
        { value <> @varDefMutable{name, value} }
        { <> @varDefMutable{name} }
};

## Returns a `varRef` node.
fn makeVarRef(name) {
    <> @varRef{
        name,
        lvalue: { node <> makeVarBind(name, node) }
    }
};

## Returns a `call` node.
fn makeCall(function, actuals*) {
    <> @call{function, actuals}
};

## Returns a `call` node that names a function as a `varRef`.
fn makeCallName(name, actuals*) {
    <> @call{function: makeVarRef(name), actuals}
};

## Returns a collection access (`get`) expression. This is a `call` node
## of two arguments (a collection node and a key node).
fn makeGetExpression(collArg, keyArg) {
    <> makeCallName("get", collArg, keyArg)
};

## Returns an optional-value expression. This wraps `node` as
## `optValue { <> node }`.
fn makeOptValueExpression(node) {
    <> makeCallName("optValue", makeThunk(node))
};

## Returns a `call` node to a nonlocal exit with the given name and
## with optional expression value. If passed, the expression is allowed
## to evaluate to void, in which case the nonlocal exit yields void at
## its exit point.
fn makeCallNonlocalExit(name, optExpression?) {
    <> ifValue { <> optExpression* }
        { ex ->
            <> makeCallName("nonlocalExit",
                name,
                makeInterpolate(makeOptValueExpression(ex)))
        }
        { <> makeCallName("nonlocalExit", name) }
};


##
## Grammar rules
##
## The following is a near-transliteration of the tree grammar in
## the Samizdat Layer 0 and Samizdat Layer 1 specifications.
##

##
## Samizdat Layer 0 definitions
##

## Forward declaration required for integrating layer 1 definitions.
def parParser;

## Forward declarations.
def parAssignExpression;
def parFnExpression;
def parOpExpression;
def parProgramBody;
def parUnaryExpression;

## Documented in spec.
def parExpression = Peg::makeMainChoice(
    Peg::makeThunk { <> parAssignExpression },
    Peg::makeThunk { <> parFnExpression });

## Documented in spec.
def parParenExpression = Peg::makeMainSequence(
    Peg::makeToken("("),
    parExpression,
    Peg::makeOpt(
        Peg::makeSequence(
            Peg::makeToken(","),
            Peg::makeCode { ., . ->
                Io1::die("Comma not allowed within parenthesized expression.")
            })),
    Peg::makeToken(")"),
    Peg::makeCode { ., ex, ., . <> @expression{value: ex} });

## Documented in spec.
def parVarRef = Peg::makeMainSequence(
    Peg::makeToken("identifier"),
    Peg::makeCode { name <> makeVarRef(dataOf(name)) });

## Documented in spec.
def parVarDef = Peg::makeMainSequence(
    Peg::makeTokenSet("def", "var"),
    Peg::makeToken("identifier"),
    Peg::makeOpt(Peg::makeSequence(Peg::makeToken("="), parExpression)),
    Peg::makeCode { style, name, optExpr ->
        def nameString = dataOf(name);
        <> ifIs { <> hasType(style, "def") }
            { <> makeVarDef(nameString, optExpr*) }
            { <> makeVarDefMutable(nameString, optExpr*) }
    });

## Documented in spec.
def parYieldDef = Peg::makeMainSequence(
    Peg::makeToken("<"),
    Peg::makeToken("identifier"),
    Peg::makeToken(">"),
    Peg::makeCode { ., name, . <> dataOf(name) });

## Documented in spec.
def parOptYieldDef = Peg::makeMainChoice(
    Peg::makeSequence(
        parYieldDef,
        Peg::makeCode { y <> {yieldDef: y} }),
    Peg::makeResult({}));

## Documented in spec.
def parFormal = Peg::makeMainSequence(
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeToken("identifier"),
            Peg::makeCode { n <> {name: dataOf(n)} }),
        Peg::makeSequence(
            Peg::makeToken("."),
            Peg::makeResult({}))),
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeTokenSet("?", "*", "+"),
            Peg::makeCode { ., r <> {repeat: typeOf(r)} }),
        Peg::makeResult({})),
    Peg::makeCode { name, repeat <> {name*, repeat*} });

## Documented in spec.
def parFormalsList = Peg::makeMainChoice(
    Peg::makeSequence(
        parFormal,
        Peg::makeStar(Peg::makeSequence(Peg::makeToken(","), parFormal)),
        Peg::makeCode { one, rest <> [one, rest*] }),
    Peg::makeResult([]));

## Documented in spec.
def parProgramDeclarations = Peg::makeMainChoice(
    Peg::makeSequence(
        parOptYieldDef,
        parFormalsList,
        Peg::makeChoice(
            Peg::makeToken("->"),
            Peg::makeLookaheadSuccess(Peg::makeToken("<>"))),
        Peg::makeCode { yieldDef, formals, . ->
            <> {formals, yieldDef*}
        }),
    Peg::makeResult({formals: []}));

## Documented in spec.
def parProgram = Peg::makeMainSequence(
    parProgramDeclarations,
    Peg::makeThunk { . <> parProgramBody },
    Peg::makeCode { decls, body <> @closure{decls*, body*} });

## Documented in spec.
def parClosure = Peg::makeMainSequence(
    Peg::makeToken("{"),
    parProgram,
    Peg::makeToken("}"),
    Peg::makeCode { ., prog, . <> prog });

## Documented in spec.
def parNullaryClosure = Peg::makeMainSequence(
    parClosure,
    Peg::makeCode { c ->
        def formals = dataOf(c)::formals;
        ifIs { <> ne(formals, []) }
            { Io0::die("Invalid formal argument in code block.") };
        <> c
    });

## Documented in spec.
def parCodeOnlyClosure = Peg::makeMainSequence(
    parNullaryClosure,
    Peg::makeCode { c ->
        ifIs { <> dataOf(c)::yieldDef }
            { Io0::die("Invalid yield definition in code block.") };
        <> c
    });

## Documented in spec.
def parFnCommon = Peg::makeMainSequence(
    Peg::makeToken("fn"),
    Peg::makeOpt(
        Peg::makeSequence(
            parYieldDef,
            Peg::makeCode { ., y <> makeVarDef(y, makeVarRef("return")) })),
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeToken("identifier"),
            Peg::makeCode { ., ., n <> {name: dataOf(n)} }),
        Peg::makeResult({})),
    Peg::makeToken("("),
    parFormalsList,
    Peg::makeToken(")"),
    parCodeOnlyClosure,
    Peg::makeCode { ., returnDef, name, ., formals, ., code ->
        def codeMap = dataOf(code);
        def statements = [returnDef*, codeMap::statements*];
        <> @closure{
            codeMap*, name*,
            formals,
            yieldDef: "return",
            statements
        }
    });

## Documented in spec.
def parFnDef = Peg::makeMainSequence(
    parFnCommon,
    Peg::makeCode { closure <> dataOf(closure)::name },
    Peg::makeCode { closure, name ->
        ## `@topDeclaration` is split apart in the `programBody` rule.
        <> @topDeclaration{
            top:  makeVarDef(name),
            main: makeVarBind(name, closure)
        }
    });

## Documented in spec.
parFnExpression := Peg::makeMainSequence(
    parFnCommon,
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeCode { closure <> dataOf(closure)::name },
            Peg::makeCode { closure, name ->
                def mainClosure = @closure{
                    formals:    [],
                    statements: [makeVarDef(name)],
                    yield:      makeVarBind(name, closure)
                };

                <> makeCall(mainClosure)
            }),
        Peg::makeCode { closure <> closure }));

## Documented in spec.
def parInt = Peg::makeMainChoice(
    Peg::makeSequence(
        Peg::makeToken("-"),
        Peg::makeToken("int"),
        Peg::makeCode { ., i <> makeLiteral(Number::neg(dataOf(i))) }),
    Peg::makeSequence(
        Peg::makeToken("int"),
        Peg::makeCode { i <> makeLiteral(dataOf(i)) }));

## Documented in spec.
def parString = Peg::makeMainSequence(
    Peg::makeToken("string"),
    Peg::makeCode { s <> makeLiteral(dataOf(s)) });

## Documented in spec.
def parIdentifierString = Peg::makeMainChoice(
    parString,
    Peg::makeSequence(
        Peg::makeToken("identifier"),
        Peg::makeCode { ident <> makeLiteral(dataOf(ident)) }),
    Peg::makeSequence(
        Peg::any,
        Peg::makeCode { token ->
            <> ifNot { <> dataOf(token) }
                {
                    def type = typeOf(token);
                    def firstCh = Sequence::nth(type, 0);
                    <> ifIs { <> get(LOWER_ALPHA, firstCh) }
                        { <> makeLiteral(type) }
                }
            }));

## Documented in spec.
def parKey = Peg::makeMainChoice(
    Peg::makeSequence(
        parIdentifierString,
        Peg::makeToken(":"),
        Peg::makeCode { key, . <> key }),
    Peg::makeSequence(
        parExpression,
        Peg::makeToken(":"),
        Peg::makeCode { key, . <> key }));

## Documented in spec.
def parMapping = Peg::makeMainSequence(
    Peg::makeStar(parKey),
    parExpression,
    Peg::makeCode { keys, value ->
        <> ifIs { <> eq(keys, []) }
            { <out> ->
                ## No keys were specified, so the value must be either a
                ## whole-map interpolation or a variable-name-to-its-value
                ## binding.
                def type = typeOf(value);
                def data = dataOf(value);
                ifIs { <> eq(type, "interpolate") }
                    { <out> data::value };
                ifIs { <> eq(type, "varRef") }
                    {
                        <out> makeCallName("makeValueMap",
                            makeLiteral(data::name), value)
                    }
            }
            {
                ## One or more keys. The `value` is wrapped in an
                ## `expression` node here to prevent interpolation from
                ## being applied to `makeValueMap`.
                <> makeCallName("makeValueMap", keys*, @expression{value})
            }
    });

## Documented in spec.
def parMap = Peg::makeMainSequence(
    Peg::makeToken("{"),
    Peg::makeChoice(
        Peg::makeSequence(
            parMapping,
            Peg::makeStar(Peg::makeSequence(Peg::makeToken(","), parMapping)),
            Peg::makeCode { ., one, rest ->
                <> ifIs { <> eq(rest, []) }
                    { <> one }
                    { <> makeCallName("cat", one, rest*) }
            }),
        Peg::makeCode { . <> makeLiteral({}) }),
    Peg::makeToken("}"),
    Peg::makeCode { ., result, . <> result });

## Documented in spec.
def parListItem = Peg::makeMainChoice(
    Peg::makeSequence(
        parIdentifierString,
        Peg::makeToken(":"),
        Peg::makeCode { ., . ->
            Io0::die(
                "Mapping syntax not valid as a list item or call argument.")
        }),
    Peg::makeSequence(
        Peg::makeToken("&"),
        Peg::makeThunk { . <> parUnaryExpression },
        Peg::makeCode { ., ex <> @voidable{value: ex} }),
    parExpression);

## Documented in spec.
def parUnadornedList = Peg::makeMainChoice(
    Peg::makeSequence(
        parListItem,
        Peg::makeStar(
            Peg::makeSequence(Peg::makeToken(","), parListItem)),
        Peg::makeCode { one, rest <> [one, rest*] }),
    Peg::makeResult([]));

## Documented in spec.
def parList = Peg::makeMainSequence(
    Peg::makeToken("["),
    parUnadornedList,
    Peg::makeToken("]"),
    Peg::makeCode { ., expressions, . ->
        <> ifIs { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> makeCallName("makeList", expressions*) }
    });

## Documented in spec.
def parDeriv = Peg::makeMainSequence(
    Peg::makeToken("@"),
    Peg::makeChoice(parIdentifierString, parParenExpression),
    Peg::makeOpt(Peg::makeChoice(parParenExpression, parMap, parList)),
    Peg::makeCode { ., type, value ->
        <> makeCallName("makeValue", type, value*)
    });

## Documented in spec.
def parTerm = Peg::makeMainChoice(
    parVarRef, parInt, parString, parMap, parList,
    parDeriv, parClosure, parParenExpression,
    ## Defined by Samizdat Layer 1. The lookahead is just to make
    ## it clear what is required to "jump into" Layer 1 parsing.
    Peg::makeSequence(
        Peg::makeLookaheadSuccess(Peg::makeToken("{/")),
        Peg::makeThunk { . <> parParser }));

## Documented in spec.
def parActualsList = Peg::makeMainChoice(
    Peg::makeSequence(
        Peg::makeToken("("),
        parUnadornedList,
        Peg::makeToken(")"),
        Peg::makeStar(parClosure),
        Peg::makeCode { ., normalActuals, ., closureActuals ->
            <> [closureActuals*, normalActuals*]
        }),
    Peg::makePlus(parClosure));

## Documented in spec.
def parPostfixOperator = Peg::makeMainChoice(
    Peg::makeSequence(
        parActualsList,
        Peg::makeCode { actuals <> { node <> makeCall(node, actuals*) } }),
    Peg::makeSequence(
        Peg::makeToken("::"),
        parIdentifierString,
        Peg::makeCode { ., key <> { node <> makeGetExpression(node, key) } }),
    Peg::makeSequence(
        Peg::makeToken("*"),
        Peg::makeCode { . <> { node <> makeInterpolate(node) } }),
    Peg::makeSequence(
        Peg::makeToken("?"),
        Peg::makeCode { . <> { node <> makeOptValueExpression(node) } }));

## Documented in spec.
parUnaryExpression := Peg::makeMainSequence(
    Peg::makeChoice(
        Peg::makeSequence(
            parTerm,
            Peg::makeCode { base <> {base, prefixes: []} }),
        ## This is a stub representing the layer 2 part of the rule.
        Peg::fail),
    Peg::makeStar(parPostfixOperator),
    Peg::makeCode { basePrefixes, postfixes ->
        def prefixes = basePrefixes::prefixes;
        var result = basePrefixes::base;

        Generator::filterPump(postfixes) { op -> result := op(result) };
        Generator::filterPump(prefixes) { op -> result := op(result) };
        <> result
    });

## Documented in spec.
parOpExpression := parUnaryExpression;

## Documented in spec.
parAssignExpression := Peg::makeMainSequence(
    parOpExpression,
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeToken(":="),
            Peg::makeCode { base, . <> dataOf(base)::lvalue },
            parExpression,
            Peg::makeCode { base, ., lvalue, ex <> lvalue(ex) }),
        Peg::makeCode { base <> base }));

## Documented in spec.
def parStatement = Peg::makeChoice(
    parVarDef,
    parFnDef,
    parExpression);

## Documented in spec.
def parNonlocalExit = Peg::makeMainSequence(
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeToken("<"),
            parVarRef,
            Peg::makeToken(">"),
            Peg::makeCode { ., n, . <> n }),
        Peg::makeSequence(
            Peg::makeToken("return"),
            Peg::makeResult(makeVarRef("return")))),
    Peg::makeOpt(parExpression),
    Peg::makeCode { name, value ->
        <> makeCallNonlocalExit(name, value*)
    });

## Documented in spec.
def parYield = Peg::makeMainSequence(
    Peg::makeToken("<>"),
    Peg::makeChoice(
        Peg::makeSequence(
            parExpression,
            Peg::makeCode { ., ex <> {yield: ex} }),
        Peg::makeResult({})));

## Documented in spec.
parProgramBody := Peg::makeMainSequence(
    Peg::makeStar(Peg::makeToken(";")),
    Peg::makeStar(
        Peg::makeMainSequence(
            parStatement,
            Peg::makePlus(Peg::makeToken(";")),
            Peg::makeCode { s, . <> s })),
    Peg::makeChoice(
        Peg::makeMainSequence(
            Peg::makeChoice(parStatement, parNonlocalExit),
            Peg::makeCode { s <> {statements: [s]} }),
        Peg::makeMainSequence(
            parYield,
            Peg::makeCode { y <> {statements: [], y*} }),
        Peg::makeResult({statements: []})),
    Peg::makeStar(Peg::makeToken(";")),
    Peg::makeCode { ., most, last, . ->
        def rawStatements = [most*, last::statements*];
        def tops = Generator::filterAll(rawStatements)
            { s ->
                <> ifIs { <> hasType(s, "topDeclaration") }
                    { <> dataOf(s)::top }
            };
        def mains = Generator::filterAll(rawStatements)
            { s ->
                <> ifIs { <> hasType(s, "topDeclaration") }
                    { <> dataOf(s)::main }
                    { <> s }
            };
        <> {last*, statements: [tops*, mains*]}
    });

## Documented in spec.
def parExpressionOrError = Peg::makeMainSequence(
    parExpression,
    Peg::makeOpt(
        Peg::makeMainSequence(
            Peg::makePlus(Peg::any),
            Peg::makeCode { pending -> reportError(pending) })),
    Peg::makeCode { ex, . <> ex });

## Documented in spec.
def parProgramOrError = Peg::makeMainSequence(
    parProgram,
    Peg::makeOpt(
        Peg::makeMainSequence(
            Peg::makePlus(Peg::any),
            Peg::makeCode { pending -> reportError(pending) })),
    Peg::makeCode { prog, . <> prog });


##
## Samizdat Layer 1 definitions
##

## `choicePex` is the top-level parsing expression node type.
def parChoicePex;

## Map from parser tokens to derived value types for pexes.
def PEX_TYPES = {
    "&": "lookaheadSuccess",
    "!": "lookaheadFailure",
    "?": "opt",
    "*": "star",
    "+": "plus"
};

## Documented in spec.
parParser := Peg::makeMainSequence(
    Peg::makeToken("{/"),
    Peg::makeThunk { . <> parChoicePex },
    Peg::makeToken("/}"),
    Peg::makeCode { ., pex, . <> @parser{value: pex} });

## Documented in spec.
def parParenPex = Peg::makeMainSequence(
    Peg::makeToken("("),
    Peg::makeThunk { . <> parChoicePex },
    Peg::makeToken(")"),
    Peg::makeCode { ., pex, . <> pex });

## Documented in spec.
def parParserString = Peg::makeMainSequence(
    Peg::makeToken("string"),
    Peg::makeCode { s ->
        def value = dataOf(s);
        <> ifIs { <> eq(Collection::sizeOf(value), 1) }
            { <> @token(value) }
            { <> s }
    });

## Documented in spec.
def parParserToken = Peg::makeMainSequence(
    Peg::makeToken("@"),
    parIdentifierString,
    Peg::makeCode { ., type <> @token(dataOf(type)::value) });

## Documented in spec.
def parParserSetString = Peg::makeMainSequence(
    Peg::makeToken("string"),
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeToken(".."),
            Peg::makeToken("string"),
            Peg::makeCode { <out> s, ., end ->
                def startChar = dataOf(s);
                def endChar = dataOf(end);

                ## Reject non-single-character strings.
                ifIs { <> ne(1, Collection::sizeOf(startChar)) } { <out> };
                ifIs { <> ne(1, Collection::sizeOf(endChar)) } { <out> };

                <> cat(Range::makeInclusiveRange(startChar, endChar)*)
            }),
        Peg::makeCode { s <> dataOf(s) }));

## Documented in spec.
def parParserSet = Peg::makeMainSequence(
    Peg::makeToken("["),
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeToken("!"),
            Peg::makeResult("tokenSetComplement")),
        Peg::makeResult("tokenSet")),
    Peg::makeChoice(
        Peg::makeMainSequence(
            Peg::makePlus(parParserSetString),
            Peg::makeCode { strings <> [cat(strings*)*] }),
        Peg::makeMainSequence(
            Peg::makePlus(parParserToken),
            Peg::makeCode { tokens <> Generator::collect(tokens, dataOf) }),
        Peg::makeResult([])),
    Peg::makeToken("]"),
    Peg::makeCode { ., type, terminals, . <> @(type)(terminals) });

## Documented in spec.
def parParserCode = Peg::makeMainSequence(
    parNullaryClosure,
    Peg::makeCode { closure <> @code(dataOf(closure)) });


## Documented in spec.
def parParserThunk = Peg::makeMainSequence(
    Peg::makeToken("%"),
    parTerm,
    Peg::makeCode { ., term <> @thunk(term) });

## Documented in spec.
def parParserTerm = Peg::makeMainChoice(
    Peg::makeSequence(
        Peg::makeToken("."),
        Peg::makeResult(@any)),
    Peg::makeSequence(
        Peg::makeToken("("),
        Peg::makeToken(")"),
        Peg::makeResult(@empty)),
    parVarRef,
    parParserString,
    parParserToken,
    parParserSet,
    parParserCode,
    parParserThunk,
    parParenPex);

## Documented in spec.
def parRepeatPex = Peg::makeMainSequence(
    parParserTerm,
    Peg::makeChoice(
        Peg::makeSequence(
            Peg::makeTokenSet("?", "*", "+"),
            Peg::makeCode { term, repeat ->
                <> @(get(PEX_TYPES, typeOf(repeat)))(term)
            }),
        Peg::makeCode { term <> term }));

## Documented in spec.
def parLookaheadPex = Peg::makeMainChoice(
    Peg::makeSequence(
        Peg::makeTokenSet("&", "!"),
        parRepeatPex,
        Peg::makeCode { lookahead, pex ->
            <> @(get(PEX_TYPES, typeOf(lookahead)))(pex)
        }),
    parRepeatPex);

## Documented in spec.
def parNamePex = Peg::makeMainChoice(
    Peg::makeSequence(
        Peg::makeToken("identifier"),
        Peg::makeToken("="),
        parLookaheadPex,
        Peg::makeCode { name, ., pex ->
            <> @varDef{name: dataOf(name), value: pex}
        }),
    parLookaheadPex);

## Documented in spec.
def parSequencePex = Peg::makeMainSequence(
    Peg::makePlus(parNamePex),
    Peg::makeCode { items <> @sequence(items) });

## Documented in spec.
parChoicePex := Peg::makeMainSequence(
    parSequencePex,
    Peg::makeStar(
        Peg::makeSequence(
            Peg::makeToken("|"),
            parSequencePex)),
    Peg::makeCode { one, rest <> @choice[one, rest*] });


##
## Exported Definitions
##

## Documented in spec.
fn parseExpression(expression) {
    def tokens = ifIs { <> isString(expression) }
        { <> tokenize(expression) }
        { <> expression };

    <> Peg::apply(parExpressionOrError, tokens)
};

## Documented in spec.
fn parseProgram(program) {
    def tokens = ifIs { <> isString(program) }
        { <> tokenize(program) }
        { <> program };

    <> Peg::apply(parProgramOrError, tokens)
};

<> {
    parseExpression,
    parseProgram
}
