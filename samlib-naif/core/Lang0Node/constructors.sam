## Copyright 2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>


##
## Private definitions
##

## Makes a non-assignable (no `lvalue` binding) `varRef`.
fn makeSimpleVarRef(name) {
    <> @varRef{name}
};

## Variable reference to `catCollect`.
def REF_catCollect = makeSimpleVarRef("catCollect");

## Variable reference to `get`.
def REF_get = makeSimpleVarRef("get");

## Variable reference to `makeList`.
def REF_makeList = makeSimpleVarRef("makeList");

## Variable reference to `nonlocalExit`.
def REF_nonlocalExit = makeSimpleVarRef("nonlocalExit");

## Variable reference to `optValue`.
def REF_optValue = makeSimpleVarRef("optValue");


##
## Exported definitions
##

## Returns a `call` node. This handles conversion of interpolated arguments
## into a form that can be directly executed.
fn makeCall(function, actuals*) {
    ifIs { <> perEq(actuals, []) }
        {
            ## No actuals. Easy out.
            return makeDirectCall(function)
        };

    ## Convert the actuals as if interpolation needs to be handled. If in the
    ## end it doesn't, then the original actuals are used as-is.

    var pending = [];
    var cookedActuals = [];

    fn addCookedActual(actual) {
        cookedActuals := [cookedActuals*, actual];
    };

    fn addPendingToCooked() {
        addCookedActual(makeDirectCall(REF_makeList, pending*));
        pending := [];
    };

    Generator::filterPump(actuals) { actual ->
        ifIs { <> hasType(actual, "interpolate") }
            {
                ifIs { <> perNe(pending, []) } { addPendingToCooked() };
                addCookedActual(dataOf(actual)::value)
            }
            { pending := [pending*, actual] }
    };

    ifIs { <> perNe(pending, []) }
        {
            ifIs { <> perEq(cookedActuals, []) }
                {
                    ## There were no interpolated arguments.
                    return makeDirectCall(function, actuals*)
                };
            addPendingToCooked()
        };

    ## There was at least one interpolated argument.

    <> makeDirectApply(
        function,
        makeDirectCall(REF_catCollect, cookedActuals*))
};

## Returns a `call` node that names a function as a `varRef`.
fn makeCallName(name, actuals*) {
    <> makeCall(makeSimpleVarRef(name), actuals*)
};

## Returns a `call` node to a nonlocal exit reference and with optional
## expression value. If passed, the expression is allowed to evaluate to void,
## in which case the nonlocal exit yields void at its exit point.
fn makeCallNonlocalExit(nleRef, optExpression?) {
    <> ifValue { <> optExpression* }
        { ex ->
            <> makeCall(REF_nonlocalExit,
                nleRef,
                makeInterpolate(makeOptValueExpression(ex)))
        }
        { <> makeDirectCall(REF_nonlocalExit, nleRef) }
};

## Returns an `apply` node, without doing any special processing of actuals.
fn makeDirectApply(function, actuals) {
    <> @apply{function, actuals}
};

## Returns a `call` node, without doing any special processing of actuals.
fn makeDirectCall(function, actuals*) {
    <> @call{function, actuals}
};

## Returns a collection access (`get`) expression. This is a `call` node
## of two arguments (a collection node and a key node).
fn makeGetExpression(collArg, keyArg) {
    <> makeDirectCall(REF_get, collArg, keyArg)
};

## Returns an `interpolate` node.
fn makeInterpolate(value) {
    <> @interpolate{value}
};

## Returns a `literal` node.
fn makeLiteral(value) {
    <> @literal{value}
};

## Returns an optional-value expression. This wraps `node` as
## `optValue { <> node }`.
fn makeOptValueExpression(node) {
    <> makeCall(REF_optValue, makeThunk(node))
};

## Returns a node representing a thunk (no-arg function) that returns the
## expression represented by the given node.
fn makeThunk(expression) {
    <> @closure{formals: [], statements: [], yield: expression}
};

## Returns a `varBind` node.
fn makeVarBind(name, value) {
    <> @varBind{name, value}
};

## Returns a `varDef` node.
fn makeVarDef(name, optValue?) {
    <> ifValue { <> optValue* }
        { value <> @varDef{name, value} }
        { <> @varDef{name} }
};

## Returns a `varDefMutable` node.
fn makeVarDefMutable(name, optValue?) {
    <> ifValue { <> optValue* }
        { value <> @varDefMutable{name, value} }
        { <> @varDefMutable{name} }
};

## Returns a `varRef` node.
fn makeVarRef(name) {
    <> @varRef{
        name,
        lvalue: { node <> makeVarBind(name, node) }
    }
};

<> {
    makeCall,
    makeCallName,
    makeCallNonlocalExit,
    makeDirectApply,
    makeDirectCall,
    makeGetExpression,
    makeInterpolate,
    makeLiteral,
    makeOptValueExpression,
    makeThunk,
    makeVarBind,
    makeVarDef,
    makeVarDefMutable,
    makeVarRef
}
