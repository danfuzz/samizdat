## Copyright 2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Exported definitions
##

## Global variable names.
def NAMES = [
    "cat",
    "catCollect",
    "eq",
    "ge",
    "get",
    "gt",
    "ifIs",
    "ifNot",
    "ifValue",
    "ifValueOr",
    "ifValues",
    "le",
    "loop",
    "lt",
    "makeList",
    "makeValue",
    "makeValueMap",
    "ne",
    "nonlocalExit",
    "optValue",
    "totNe"
];

## Module-scoped names.
def MOD_NAMES = [
    {mod: "Bitwise",    name: "and"},
    {mod: "Bitwise",    name: "not"},
    {mod: "Bitwise",    name: "or"},
    {mod: "Bitwise",    name: "shl"},
    {mod: "Bitwise",    name: "shr"},
    {mod: "Bitwise",    name: "xor"},
    {mod: "Collection", name: "sizeOf"},
    {mod: "Format",     name: "formatterFor"},
    {mod: "Format",     name: "usual"},
    {mod: "Generator",  name: "filterAll"},
    {mod: "Generator",  name: "filterPump"},
    {mod: "Generator",  name: "makeRepeatGenerator"},
    {mod: "Generator",  name: "makeFilterGenerator"},
    {mod: "Number",     name: "add"},
    {mod: "Number",     name: "div"},
    {mod: "Number",     name: "divEu"},
    {mod: "Number",     name: "mod"},
    {mod: "Number",     name: "modEu"},
    {mod: "Number",     name: "mul"},
    {mod: "Number",     name: "neg"},
    {mod: "Number",     name: "sub"},
    {mod: "Range",      name: "makeExclusiveRange"},
    {mod: "Range",      name: "makeInclusiveRange"},
    {mod: "Range",      name: "makeOpenRange"},
    {mod: "Sequence",   name: "nthFromEnd"},
    {mod: "Sequence",   name: "reverse"},
    {mod: "Sequence",   name: "sliceGeneral"},
    {mod: "Sequence",   name: "sliceExclusive"},
    {mod: "Sequence",   name: "sliceInclusive"}
];

## Used in `MOD_NAMES` processing.
def REF_get = @varRef{name: "get"};


##
## Exported definitions
##

def REFS = cat(
    (Generator::filterAll(NAMES) { name <> {(name): @varRef{name}} })*,
    (Generator::filterAll(MOD_NAMES) { modName ->
        def mod = modName::mod;
        def name = modName::name;
        def modRef = @varRef{name: mod};
        def nameLit = @literal{value: name};
        def bindName = cat(mod, "_", name);
        <> {(bindName): @call{function: REF_get, actuals: [modRef, nameLit]}}
    })*
);

<> {REFS}
