## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `SerialGenerator` Type
##
## Payload is `[subGens*]`, a list of sub-generators.

#= language core.Lang0

def $Box      = moduleLoad(["core", "Box"]);
def $Sequence = moduleLoad(["core", "Sequence"]);

def $NullGenerator = intraLoad("NullGenerator");


##
## Exported Definitions
##

## Documented in spec.
export fn makeSerialGenerator(generators*) {
    ## Return the `nullGenerator` if we weren't passed any arguments.
    ifIs { <> eq(generators, []) }
        { return $NullGenerator::nullGenerator };

    ## Return the argument directly if we were only passed one.
    ## This saves some gratuitous call wrapping / double yields.
    ifIs { <> eq(get_size(generators), 1) }
        { return generators* };

    <> @SerialGenerator(generators)
};

## Documented in spec.
fn @@SerialGenerator.collect(optFilterFunction?) {
    ## Just use the standard implementation.
    <> Generator_stdCollect(this, optFilterFunction*)
};

## Documented in spec.
fn @@SerialGenerator.nextValue(box) {
    def subGens = dataOf(this);

    <> ifValue { <> get(subGens, 0) }
        { firstGen ->
            def moreGens = $Sequence::sliceInclusive(subGens, 1);
            def innerBox = $Box::makePromise();

            <> ifValue { <> nextValue(firstGen, innerBox) }
                { nextGenerator ->
                    store(box, fetch(innerBox));
                    <> @SerialGenerator[nextGenerator, moreGens*]
                }
                {
                    ## First generator was voided.
                    <> nextValue(
                        makeSerialGenerator(moreGens*),
                        box)
                }
        }
        {
            ## Totally voided.
            store(box)
        }
};
