## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `FilterGenerator` Type
##
## Payload is a map `{filterFunction: function, generator: subGen}`.
## `subGen` is expected to produce lists of arguments to apply.

#= language core.Lang0

import ./ParaGenerator :: makeParaGenerator;


##
## Exported Definitions
##

## Documented in spec.
export fn makeFilterGenerator(filterFunction, generators*) {
    return @FilterGenerator{
        filterFunction,
        generator: makeParaGenerator(generators*)
    }
};

## Documented in spec.
fn @@FilterGenerator.collect(optFilterFunction?) {
    ## Just use the standard implementation.
    return Generator_stdCollect(this, optFilterFunction*)
};

## Documented in spec.
fn @@FilterGenerator.nextValue(box) {
    var innerGen = this::generator;
    def filterFunction = this::filterFunction;
    var result;

    ## This loop handles the fact that the filter function is
    ## allowed to yield void to indicate a generated value is to
    ## be discarded.
    loop {
        ifValue { nextValue(innerGen, var result) }
            { nextGen ->
                ifValue { filterFunction(result*) }
                    { value ->
                        store(box, value);
                        return @FilterGenerator{
                            filterFunction,
                            generator: nextGen}
                    }
                    {
                        ## The filter discarded the value. As this doesn't
                        ## `return` (per se) it will fall through to the end
                        ## of the loop body and iterate.
                        innerGen := nextGen;
                    }
            }
            {
                ## The inner generator was voided.
                return
            }
    }
};
