## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `FilterGenerator` Type
##
## Payload is a map `{filterFunction: function, generator: subGen}`.
## `subGen` is expected to produce lists of arguments to apply.

#= language core.Lang0

import core.Box :: makePromise;

import ./ParaGenerator :: makeParaGenerator;


##
## Exported Definitions
##

## Documented in spec.
export fn makeFilterGenerator(filterFunction, generators*) {
    return @FilterGenerator{
        filterFunction,
        generator: makeParaGenerator(generators*)
    }
};

## Documented in spec.
fn @@FilterGenerator.collect(optFilterFunction?) {
    ## Just use the standard implementation.
    return Generator_stdCollect(this, optFilterFunction*)
};

## Documented in spec.
fn @@FilterGenerator.nextValue(box) {
    def filterFunction = this::filterFunction;

    ## This loop handles the fact that the filter function is
    ## allowed to yield void to indicate a generated value is to
    ## be discarded.
    var innerGen = this::generator;
    loop { /next ->
        def innerBox = makePromise();

        ifValue { nextValue(innerGen, innerBox) }
            { nextGen ->
                ifValue { filterFunction(fetch(innerBox)*) }
                    { value ->
                        store(box, value);
                        return @FilterGenerator(
                            {dataOf(this)*, generator: nextGen})
                    }
                    {
                        ## The filter discarded the value. Iterate!
                        innerGen := nextGen;
                        yield /next
                    }
            };

        ## The inner generator was voided.
        return
    }
};
