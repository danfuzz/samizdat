## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `FilterGenerator` Type
##
## Payload is a map `{filterFunction: function, generator: subGen}`.
## `subGen` is expected to produce lists of arguments to apply.

#= language core.Lang0

def $Box = moduleLoad(["core", "Box"]);

def $ParaGenerator = intraLoad("ParaGenerator");


##
## Exported Definitions
##

## Documented in spec.
export fn makeFilterGenerator(filterFunction, generators*) {
    <> @FilterGenerator{
        filterFunction,
        generator: $ParaGenerator::makeParaGenerator(generators*)
    }
};

## Documented in spec.
fn @@FilterGenerator.collect(optFilterFunction?) {
    ## Just use the standard implementation.
    <> Generator_stdCollect(this, optFilterFunction*)
};

## Documented in spec.
fn @@FilterGenerator.nextValue(box) {
    def filterFunction = this::filterFunction;

    ## This loop handles the fact that the filter function is
    ## allowed to yield void to indicate a generated value is to
    ## be discarded.
    var innerGen = this::generator;
    loop { <next> ->
        def innerBox = $Box::makePromise();

        ifValue { <> nextValue(innerGen, innerBox) }
            { nextGen ->
                ifValue { <> filterFunction(fetch(innerBox)*) }
                    { value ->
                        store(box, value);
                        return @FilterGenerator(
                            {dataOf(this)*, generator: nextGen})
                    }
                    {
                        ## The filter discarded the value. Iterate!
                        innerGen := nextGen;
                        <next>
                    }
            };

        ## The inner generator was voided.
        store(box);
        return
    }
};
