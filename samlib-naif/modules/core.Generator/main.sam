## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Generator functions
##

#= language core.Lang0

import core.Box :: nullBox;

export import ./FilterGenerator :: *;
export import ./ListWrapGenerator :: *;
export import ./NullGenerator :: *;
export import ./OptGenerator :: *;
export import ./ParaGenerator :: *;
export import ./RepeatGenerator :: *;
export import ./SerialGenerator :: *;
export import ./ValueGenerator :: *;
export import ./unbounded :: *;


##
## Exported Definitions
##

## Re-exported from globals (and proto module). Documented in spec.
export
    collect,
    maybeValue,
    nextValue;

## Re-exported from builtins. Documented in spec.
export def stdCollect = Generator_stdCollect;

## Re-exported from builtins. Documented in spec.
export def stdFetch = Generator_stdFetch;

## Documented in spec.
export fn collectAsMap(generator) {
    ## Avoid pointless map->generator->map conversion.
    return ifIs { hasClass(generator, Map) }
        { generator }
        { cat({}, generator*) }
};

## Documented in spec.
export fn filterAll(filterFunction, generators*) {
    return ifIs { eq(generators.get_size(), 1) }
        {
            ## We are filtering a single generator, so just use the
            ## special-case (and often more efficient) `collect`.
            collect(generators*, filterFunction)
        }
        {
            ## The general case.
            collect(makeFilterGenerator(filterFunction, generators*))
        }
};

## Documented in spec.
export fn filterPump(filterFunction, generators*) {
    var result = [];
    var innerResult;

    ifIs { eq(generators.get_size(), 1) }
        {
            ## Handle a single generator as a special case to avoid a lot of
            ## unnecessary wrapping / unwrapping.
            var gen = generators*;
            loop {
                ifValue { nextValue(gen, var innerResult) }
                    { nextGen ->
                        ifValue { filterFunction(innerResult) }
                            { value -> result := [value] };
                        gen := nextGen
                    }
                    {
                        ## The generator was voided.
                        return? result*
                    }
            }
        }
        {
            ## General case of multiple (or zero) generators.
            var gen = makeParaGenerator(generators*);
            loop {
                ifValue { nextValue(gen, var innerResult) }
                    { nextGen ->
                        ifValue { filterFunction(innerResult*) }
                            { value -> result := [value] };
                        gen := nextGen
                    }
                    {
                        ## The inner generator was voided.
                        return? result*
                    }
            }
        }
};

## Documented in spec.
export fn generatorPump(generator) {
    var gen = generator;
    var result;

    loop {
        gen := ifValueOr { nextValue(gen, var result) }
            { return? result }
    }
};
