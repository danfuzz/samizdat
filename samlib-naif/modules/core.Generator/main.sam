## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Generator functions
##

def Box        = moduleLoad(["core", "Box"]);
def Collection = moduleLoad(["core", "Collection"]);

def FilterGenerator   = intraLoad("FilterGenerator");
def ListWrapGenerator = intraLoad("ListWrapGenerator");
def NullGenerator     = intraLoad("NullGenerator");
def OptGenerator      = intraLoad("OptGenerator");
def ParaGenerator     = intraLoad("ParaGenerator");
def RepeatGenerator   = intraLoad("RepeatGenerator");
def SerialGenerator   = intraLoad("SerialGenerator");
def ValueGenerator    = intraLoad("ValueGenerator");
def unboundedCollect  = intraLoad("unboundedCollect");

##
## Exported Definitions
##

## Documented in spec.
fn collectAsMap(generator) {
    ## Avoid pointless map->generator->map conversion.
    ifIs { <> hasType(generator, Map) }
        { return generator };

    <> cat({}, generator*)
};

## Documented in spec.
fn filterAll(filterFunction, generators*) {
    <> ifIs { <> eq(Collection::sizeOf(generators), 1) }
        {
            ## We are filtering a single generator, so just use the
            ## special-case (and often more efficient) `collect`.
            <> collect(generators*, filterFunction)
        }
        {
            ## The general case.
            <> collect(
                FilterGenerator::makeFilterGenerator(
                    filterFunction, generators*))
        }
};

## Documented in spec.
fn filterPump(filterFunction, generators*) {
    ifIs { <> eq(Collection::sizeOf(generators), 1) }
        {
            ## Handle a single generator as a special case to avoid a lot of
            ## unnecessary wrapping / unwrapping.
            var gen = generators*;
            loop {
                def box = Box::makePromise();
                ifValue { <> nextValue(gen, box) }
                    { nextGen ->
                        filterFunction(fetch(box));
                        gen := nextGen
                    }
                    {
                        ## The generator was voided.
                        return
                    }
            }
        }
        {
            ## General case of multiple (or zero) generators.
            var gen = ParaGenerator::makeParaGenerator(generators*);
            loop {
                def box = Box::makePromise();
                ifValue { <> nextValue(gen, box) }
                    { nextGen ->
                        filterFunction(fetch(box)*);
                        gen := nextGen
                    }
                    {
                        ## The inner generator was voided.
                        return
                    }
            }
        }
};

## Documented in spec.
fn generatorPump(generator) {
    var gen = generator;

    loop {
        gen := ifValueOr { <> nextValue(gen, Box::nullBox) }
            { return }
    }
};

<> {
    ## Re-exported from builtins.
    stdCollect:              Generator_stdCollect,

    ## Re-exported from globals (and proto module).
    collect,
    interpolate,
    nextValue,
    optValue,

    ## Re-exported from intramodule files.
    makeFilterGenerator:     FilterGenerator::makeFilterGenerator,
    makeListWrapGenerator:   ListWrapGenerator::makeListWrapGenerator,
    makeOptGenerator:        OptGenerator::makeOptGenerator,
    makeParaGenerator:       ParaGenerator::makeParaGenerator,
    makeRepeatGenerator:     RepeatGenerator::makeRepeatGenerator,
    makeSerialGenerator:     SerialGenerator::makeSerialGenerator,
    makeValueGenerator:      ValueGenerator::makeValueGenerator,
    nullGenerator:           NullGenerator::nullGenerator,
    unboundedCollect:        unboundedCollect::unboundedCollect,

    ## Defined in this file.
    collectAsMap,
    filterAll,
    filterPump,
    generatorPump
}
