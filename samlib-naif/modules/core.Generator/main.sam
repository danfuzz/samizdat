## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Generator functions
##

#= language core.Lang0

import core.Box ::
    makePromise,
    nullBox;

export import ./FilterGenerator :: makeFilterGenerator;
export import ./ListWrapGenerator :: makeListWrapGenerator;
export import ./NullGenerator :: nullGenerator;
export import ./OptGenerator :: makeOptGenerator;
export import ./ParaGenerator :: makeParaGenerator;
export import ./RepeatGenerator :: makeRepeatGenerator;
export import ./SerialGenerator :: makeSerialGenerator;
export import ./ValueGenerator :: makeValueGenerator;
export import ./unboundedCollect :: unboundedCollect;


##
## Exported Definitions
##

## Re-exported from globals (and proto module). Documented in spec.
export
    collect,
    interpolate,
    nextValue,
    optValue;

## Re-exported from builtins. Documented in spec.
export def stdCollect = Generator_stdCollect;

## Documented in spec.
export fn collectAsMap(generator) {
    ## Avoid pointless map->generator->map conversion.
    ifIs { <> hasType(generator, Map) }
        { return generator };

    <> cat({}, generator*)
};

## Documented in spec.
export fn filterAll(filterFunction, generators*) {
    <> ifIs { <> eq(get_size(generators), 1) }
        {
            ## We are filtering a single generator, so just use the
            ## special-case (and often more efficient) `collect`.
            <> collect(generators*, filterFunction)
        }
        {
            ## The general case.
            <> collect(makeFilterGenerator(filterFunction, generators*))
        }
};

## Documented in spec.
export fn filterPump(filterFunction, generators*) {
    ifIs { <> eq(get_size(generators), 1) }
        {
            ## Handle a single generator as a special case to avoid a lot of
            ## unnecessary wrapping / unwrapping.
            var gen = generators*;
            loop {
                def box = makePromise();
                ifValue { <> nextValue(gen, box) }
                    { nextGen ->
                        filterFunction(fetch(box));
                        gen := nextGen
                    }
                    {
                        ## The generator was voided.
                        return
                    }
            }
        }
        {
            ## General case of multiple (or zero) generators.
            var gen = makeParaGenerator(generators*);
            loop {
                def box = makePromise();
                ifValue { <> nextValue(gen, box) }
                    { nextGen ->
                        filterFunction(fetch(box)*);
                        gen := nextGen
                    }
                    {
                        ## The inner generator was voided.
                        return
                    }
            }
        }
};

## Documented in spec.
export fn generatorPump(generator) {
    var gen = generator;

    loop {
        gen := ifValueOr { <> nextValue(gen, nullBox) }
            { return }
    }
};
