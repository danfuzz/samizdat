## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `sourceGeneral` and helpers
##

#= language core.Lang0

import core.Generator :: filterAll, makeFilterGenerator;

import ./identifier :: isIdentifier;
import ./int :: intWithBase;
import ./string :: stringChar;


## Helper for optionally adorning results.
fn adornIf(adorn, before, value, after) {
    return ifIs { eq(adorn, true) }
        { before.cat(value, after) }
        { value }
};

## Helper which concatenates a list of list or map element stringifications.
## It assumes that every element is a string that starts with `", "`, and it
## removes that prefix from the first element. As a special case, this returns
## `""` if given `[]` for `elems`.
fn collectionBody(elems) {
    ifIs { eq(elems, []) }
        { return "" };

    def one = elems.nth(0).sliceInclusive(2);
    return one.cat(elems.sliceInclusive(1)*)
};

## Values with special conversions.
def SPECIAL_VALUES = {
    (Bool) :       "Bool",
    (Class):       "Class",
    (Data):        "Data",
    (Int):         "Int",
    (List):        "List",
    (Map):         "Map",
    (Null):        "Null",
    (Record):      "Record",
    (String):      "String",
    (Symbol):      "Symbol",
    (SymbolTable): "SymbolTable",
    (Value):       "Value",
    (false):       "false",
    (null):        "null",
    (true):        "true"
};

## Stringifies a name, which must be a symbol, possibly with a prefix. If
## the prefix is empty and the symbol does not look like an identifier, then
## the result is backslash-prefixed in addition to being quoted.
fn nameString(prefix, name) {
    def nameString = name.toString();

    ifIs { isIdentifier(name) }
        { return prefix.cat(nameString) };

    def finalPrefix = ifValueOr { ne(prefix, "") } { "\\" };
    return finalPrefix.cat(sourceGeneral(nameString, true))
};

## Stringifies a map key.
fn keyString(key) {
    ifIs { hasClass(key, Symbol) }
        { return nameString("", key) };

    ifValue { SPECIAL_VALUES.get(key) }
        { string -> return "(".cat(string, ")") };

    return sourceGeneral(key, true)
};

## Stringifies a class.
fn Class_sourceGeneral(value, adorn) {
    ifValue { SPECIAL_VALUES.get(value) }
        { string -> return string };

    def name = className(value);

    ifNot { eq(classParent(value), Record) }
        { return "@@(opaque ".cat(keyString(name), ")") };

    return nameString("@@", name);
};

## Stringifies an int.
fn Int_sourceGeneral(value, adorn) {
    return intWithBase(value, 10)
};

## Stringifies a list.
fn List_sourceGeneral(value, adorn) {
    def listElems = filterAll(value)
        { elem -> ", ".cat(sourceGeneral(elem, true)) };

    return adornIf(adorn, "[", collectionBody(listElems), "]")
};

## Stringifies a map.
fn Map_sourceGeneral(value, adorn) {
    def mapElems = filterAll(value)
        { mapping ->
            def k = keyString(mapping.get_key());
            def v = sourceGeneral(mapping.get_value(), true);
            ", ".cat(k, ": ", v)
        };

    return adornIf(adorn, "{", collectionBody(mapElems), "}");
};

## Stringifies a string.
fn String_sourceGeneral(value, adorn) {
    def bodyChars = makeFilterGenerator(value)
        { ch -> stringChar(ch) };
    return adornIf(adorn, "\"", "".cat(bodyChars*), "\"")
};

## Stringifies a symbol.
fn Symbol_sourceGeneral(value, adorn) {
    ifIs { eq(adorn, false) }
        { return sourceGeneral(value.toString(), false) };

    def prefix = ifIs { symbolIsInterned(value) } { "@" } { "@+" };
    return nameString(prefix, value);
};

## Stringifies a symbol table.
fn SymbolTable_sourceGeneral(value, adorn) {
    ## Convert to a map, and stringify that, with the requisite `@` prefix
    ## if requested.
    def mapString = sourceGeneral({}.cat(value), adorn);
    return adornIf(adorn, "@", mapString, "")
};

## Stringifies a derived value or an opaque core value.
fn Value_sourceGeneral(value, adorn) {
    ifValue { SPECIAL_VALUES.get(value) }
        { string -> return string };

    def cls = get_class(value);
    def prefix = nameString("@", className(cls));

    ifNot { eq(classParent(cls), Record) }
        {
            ## Opaque value, possibly named.
            def body = ifValue { value.debugSymbol() }
                { name -> keyString(name) }
                { "..." };

            return prefix.cat("<", body, ">")
        };

    ## Derived data value.
    return prefix.cat("{", sourceGeneral(value.dataOf(), false), "}");
};

## Common code for the two `source*` variants, which takes an
## `adorn` flag.
export fn sourceGeneral(value, adorn) {
    return ifSwitch(
        { get_class(value) },
        {
            (Class):       { . -> Class_sourceGeneral(value, adorn)       },
            (Int):         { . -> Int_sourceGeneral(value, adorn)         },
            (List):        { . -> List_sourceGeneral(value, adorn)        },
            (Map):         { . -> Map_sourceGeneral(value, adorn)         },
            (String):      { . -> String_sourceGeneral(value, adorn)      },
            (Symbol):      { . -> Symbol_sourceGeneral(value, adorn)      },
            (SymbolTable): { . -> SymbolTable_sourceGeneral(value, adorn) }
        },
        { . -> Value_sourceGeneral(value, adorn) }
    )
};
