## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Value stringification
##

#= language core.Lang0

import core.Generator :: filterAll, makeFilterGenerator;
import core.Sequence :: sliceInclusive;

import ./identifier :: isIdentifier;
import ./int :: intWithBase;
import ./string :: stringChar;


##
## Private Definitions
##

##
## `sourceGeneral` and helpers
##

## Common generic for the two `source*` variants, which takes an
## `adorn` flag.
fn .sourceGeneral(adorn);

## Helper for optionally adorning results.
fn adornIf(adorn, before, value, after) {
    return ifIs { totalEq(adorn, true) }
        { cat(before, value, after) }
        { value }
};

## Helper which concatenates a list of list or map element stringifications.
## It assumes that every element is a string that starts with `", "`, and it
## removes that prefix from the first element. As a special case, this returns
## `""` if given `[]` for `elems`.
fn collectionBody(elems) {
    ifIs { totalEq(elems, []) }
        { return "" };

    def one = sliceInclusive(get(elems, 0), 2);
    return cat(one, sliceInclusive(elems, 1)*)
};

## Values with special conversions.
def SPECIAL_VALUES = {
    (Data):        "Data",
    (DerivedData): "DerivedData",
    (Int):         "Int",
    (List):        "List",
    (Map):         "Map",
    (String):      "String",
    (Type):        "Type",
    (Uniqlet):     "Uniqlet",
    (Value):       "Value",
    (false):       "false",
    (null):        "null",
    (true):        "true"
};

## Stringifies a key (or derived value name).
fn keyString(key) {
    ifIs { isIdentifier(key) }
        { return key };

    ifValue { get(SPECIAL_VALUES, key) }
        { string -> return cat("(", string, ")") };

    return sourceGeneral(key, true)
};

## Stringifies an int.
fn Int.sourceGeneral(adorn) {
    return intWithBase(this, 10)
};

## Stringifies a list.
fn List.sourceGeneral(adorn) {
    def listElems = filterAll(this)
        { elem -> cat(", ", sourceGeneral(elem, true)) };

    return adornIf(adorn, "[", collectionBody(listElems), "]")
};

## Stringifies a map.
fn Map.sourceGeneral(adorn) {
    def mapElems = filterAll(this)
        { mapping ->
            def key = keyString(get_key(mapping));
            def value = sourceGeneral(get_value(mapping), true);
            cat(", ", key, ": ", value)
        };

    return adornIf(adorn, "{", collectionBody(mapElems), "}");
};

## Stringifies a string.
fn String.sourceGeneral(adorn) {
    def bodyChars = makeFilterGenerator(this)
        { ch -> stringChar(ch) };
    return adornIf(adorn, "\"", cat("", bodyChars*), "\"")
};

## Stringifies a type.
fn Type.sourceGeneral(adorn) {
    ifValue { get(SPECIAL_VALUES, this) }
        { string -> return string };

    def name = typeName(this);

    ifNot { eq(typeParent(this), DerivedData) }
        { return cat("@@(opaque ", sourceGeneral(name, true), ")") };

    def body = ifIs { hasType(name, String) }
        { ifValueOr { isIdentifier(name) } { sourceGeneral(name, true) } }
        { cat("(", sourceGeneral(name, true), ")") };

    return adornIf(adorn, "@@", body, "")
};

## Stringifies a derived value or an opaque core value.
fn Value.sourceGeneral(adorn) {
    ifValue { get(SPECIAL_VALUES, this) }
        { string -> return string };

    def type = get_type(this);
    def name = typeName(type);
    def typeStr = ifIs { hasType(name, String) }
        {
            ## The type is a string.
            ifValueOr { isIdentifier(name) } { sourceGeneral(name, true) }
        }
        {
            ## General case for type.
            cat("(", sourceGeneral(type, true), ")")
        };
    def prefix = cat("@", typeStr);

    ifNot { eq(typeParent(type), DerivedData) }
        {
            ## Opaque value, possibly named.
            def body = ifValue { debugName(this) }
                { name -> keyString(name) }
                { "..." };

            return cat(prefix, "<", body, ">")
        };

    return ifValue { dataOf(this) }
        { data ->
            ## Derived data value with payload. List and map payloads don't
            ## need parens around them.
            def dataStr = sourceGeneral(data, true);
            ifIs { hasType(data, List) }
                { return cat(prefix, dataStr) };
            ifIs { hasType(data, Map) }
                { return cat(prefix, dataStr) };
            cat(prefix, "(", dataStr, ")")
        }
        {
            ## Type-only transparent derived value.
            prefix
        };
};


##
## `humanString`
##

## Generic for producing a human-oriented string of the argument.
fn .humanString();

## Human-stringifies a list, which recursively flattens it using
## `humanString`.
fn List.humanString() {
    def elems = makeFilterGenerator(humanString, this);
    return cat("", elems*)
};

## Human-stringifies a string, which just returns the string as-is.
fn String.humanString() {
    return this
};

## Default human-stringifier, which just calls through to
## `sourceGeneral`.
fn Value.humanString() {
    return sourceGeneral(this, true)
};


##
## Exported Definitions
##

## Documented in spec.
export fn int(value, optBase?) {
    def base = ifValueOr { optBase* } { 10 };

    ifIs { lt(base, 2) }
        { die("Invalid base for int.") };

    ifIs { gt(base, 36) }
        { die("Invalid base for int.") };

    return intWithBase(value, base)
};

## Documented in spec.
export fn intHex(arg) {
    return intWithBase(arg, 16)
};

## Documented in spec.
export fn source(value?) {
    return ifValue { value* }
        { value -> sourceGeneral(value, true) }
        { "void" }
};

## Documented in spec.
export fn sourceUnadorned(value?) {
    return ifValue { value* }
        { value -> sourceGeneral(value, false) }
        { "void" }
};

## Documented in spec.
export fn usual(value?) {
    return ifValue { value* }
        { value -> humanString(value) }
        { "" }
};

## Mapping from format escape characters to their respective handler functions.
def FORMATTERS = {
    q: source,
    Q: sourceUnadorned,
    s: usual,
    x: intHex
};

## Documented in spec.
##
## This is listed out of (alphabetical) order, as it uses `FORMATTERS`, which
## is defined in terms of other exported functions.
export fn formatterFor(formatSpec) {
    return ifValueOr { get(FORMATTERS, formatSpec) }
        { die("Unrecognized format spec: ", source(formatSpec)) }
};
