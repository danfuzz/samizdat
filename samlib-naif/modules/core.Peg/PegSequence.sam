## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `PegSequence` class
##

#= language core.Lang0

import core.Generator :: filterPump;

import ./PegResult :: empty;


##
## Class Definition
##
## Payload: {rules: [rule*]}

## Secret used to control access to this class.
def SECRET = @secret.makeAnonymous();

## Class being defined here.
def PegSequence = makeObjectClass(@PegSequence, SECRET);

## Documented in spec.
fn PegSequence.parse(box, input, items*) {
    ## Each rule after the first gets passed as additional arguments
    ## the matched results of all the previous rules, in order.

    def data = this.objectDataOf(SECRET);
    var remainingInput = input;
    var results = items;  ## Includes initial items and each parsed value.
    var result = null;

    ## This is akin to `for (rule in data::rules) { ... }`.
    filterPump(data::rules) { rule ->
        ifValue { rule.parse(var result, remainingInput, results*) }
            { newInput ->
                remainingInput := newInput;
                results := [results*, result]
            }
            {
                ## Propagate the failure.
                return
            }
    };

    box* := result;
    return remainingInput
};


##
## Exported Definitions
##

## Documented in spec.
export fn makeSequence(rules*) {
    ## Trivial case: No rules. Return the empty rule.
    ifIs { eq(rules, []) }
        { return empty };

    ## Trivial case: One rule. Return that rule directly.
    ifIs { eq(rules.get_size(), 1) }
        { return rules* };

    ## The general case.
    return makeObject(PegSequence, SECRET, @{rules})
};
