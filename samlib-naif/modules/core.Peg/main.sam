## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## PEG (Parsing Expression Grammar) support
##

def Box       = moduleLoad(["core", "Box"]);
def Generator = moduleLoad(["core", "Generator"]);
def Sequence  = moduleLoad(["core", "Sequence"]);


##
## Type Definitions
##

## `parse(peg, box, input, items*)`
def parse = makeRegularGeneric("parse", 3);

## Documented in spec.
def any = @PegAny;

## Documented in spec.
def empty = @PegResult(null);

## Documented in spec.
def eof = @PegEof;

## Documented in spec.
def fail = @PegFail;

## Documented in spec.
fn PegAny_parse(peg, box, input, .*) {
    <> nextValue(input, box)
};
genericBind(parse, @@PegAny, PegAny_parse);

## Documented in spec.
fn PegChoice_parse(peg, box, input, items*) {
    Generator::filterPump(dataOf(peg)) { rule ->
        def innerBox = Box::makePromise();
        ifValue { <> parse(rule, innerBox, input, items*) }
            { newInput ->
                store(box, fetch(innerBox));
                return newInput
            }
    };

    ## No rule succeeded.
    store(box)
};
genericBind(parse, @@PegChoice, PegChoice_parse);

## Documented in spec.
fn PegCode_parse(peg, box, input, items*) {
    <> ifValue { <> dataOf(peg)(items*) }
        { result ->
            store(box, result);
            <> input
        }
        { store(box) };
};
genericBind(parse, @@PegCode, PegCode_parse);

## Documented in spec.
fn PegEof_parse(peg, box, input, .*) {
    <> ifIs { <> nextValue(input, Box::nullBox) }
        { store(box) }
        {
            store(box, null);
            <> input
        }
};
genericBind(parse, @@PegEof, PegEof_parse);

## Documented in spec.
fn PegFail_parse(peg, box, input, .*) {
    store(box)
};
genericBind(parse, @@PegFail, PegFail_parse);

## Documented in spec.
fn PegLookaheadFailure_parse(peg, box, input, items*) {
    <> ifIs { <> parse(dataOf(peg), Box::nullBox, input, items*) }
        { store(box) }
        {
            store(box, null);
            <> input
        }
};
genericBind(parse, @@PegLookaheadFailure, PegLookaheadFailure_parse);

## Documented in spec.
fn PegLookaheadSuccess_parse(peg, box, input, items*) {
    <> ifIs { <> parse(dataOf(peg), box, input, items*) }
        { <> input }
};
genericBind(parse, @@PegLookaheadSuccess, PegLookaheadSuccess_parse);

## Documented in spec.
fn PegMain_parse(peg, box, input, .*) {
    ## The point of this implementation is to drop the `items` context.
    <> parse(dataOf(peg), box, input)
};
genericBind(parse, @@PegMain, PegMain_parse);

## Documented in spec.
fn PegOpt_parse(peg, box, input, items*) {
    def innerBox = Box::makePromise();
    <> ifValue { <> parse(dataOf(peg), innerBox, input, items*) }
        { newInput ->
            store(box, [fetch(innerBox)]);
            <> newInput
        }
        {
            store(box, []);
            <> input
        }
};
genericBind(parse, @@PegOpt, PegOpt_parse);

## Documented in spec.
fn PegRepeat_parse(peg, box, input, items*) {
    def rule = peg::rule;
    var remainingInput = input;
    var results = []; ## Values that have been parsed by the inner rule.

    loop {
        def innerBox = Box::makePromise();
        ifValue { <> parse(rule, innerBox, remainingInput, items*) }
            { newInput ->
                ## Successfully parsed the inner rule.
                remainingInput := newInput;
                results := [results*, fetch(innerBox)]
            }
            {
                ## Failed to parse the inner rule.
                ifValue { <> peg::minSize }
                    { minSize ->
                        ifIs { <> lt(sizeOf(results), minSize) }
                            {
                                ## Did not parse minimum required count.
                                store(box);
                                return
                            }
                    };
                store(box, results);
                return remainingInput
            }
    }
};
genericBind(parse, @@PegRepeat, PegRepeat_parse);

## Documented in spec.
fn PegResult_parse(peg, box, input, .*) {
    store(box, dataOf(peg));
    <> input
};
genericBind(parse, @@PegResult, PegResult_parse);

## Documented in spec.
fn PegSequence_parse(peg, box, input, items*) {
    ## Each rule after the first gets passed as additional arguments
    ## the matched results of all the previous rules, in order.

    var remainingInput = input;
    var results = items; ## Includes intial items and each parsed value.

    ## This is akin to `for (rule in dataOf(peg)) { ... }`.
    Generator::filterPump(dataOf(peg)) { rule ->
        def innerBox = Box::makePromise();
        ifValue { <> parse(rule, innerBox, remainingInput, results*) }
            { newInput ->
                remainingInput := newInput;
                results := [results*, fetch(innerBox)]
            }
            {
                ## Propagate the failure.
                store(box);
                return
            }
    };

    store(box, Sequence::nthFromEnd(results, 0));
    <> remainingInput
};
genericBind(parse, @@PegSequence, PegSequence_parse);

## Documented in spec.
fn PegThunk_parse(peg, box, input, items*) {
    <> ifValue { <> dataOf(peg)(items*) }
        { thunkResult <> parse(thunkResult, box, input, items*) }
};
genericBind(parse, @@PegThunk, PegThunk_parse);

## Documented in spec.
fn PegTokenSet_parse(peg, box, input, items*) {
    def innerBox = Box::makePromise();

    ifValue { <> nextValue(input, innerBox) }
        { newInput ->
            def item = fetch(innerBox);
            ifIs { <> get(peg, get_type(item)) }
                {
                    store(box, item);
                    return newInput
                }
        };

    ## Either EOF or no match.
    store(box);
};
genericBind(parse, @@PegTokenSet, PegTokenSet_parse);

## Documented in spec.
fn PegTokenSetComplement_parse(peg, box, input, items*) {
    def innerBox = Box::makePromise();

    ifValue { <> nextValue(input, innerBox) }
        { newInput ->
            def item = fetch(innerBox);
            ifNot { <> get(peg, get_type(item)) }
                {
                    store(box, item);
                    return newInput
                }
        };

    ## Either EOF or no match.
    store(box);
};
genericBind(parse, @@PegTokenSetComplement, PegTokenSetComplement_parse);


##
## Exported Definitions
##

## Private helper for `makeCharSet*`, which takes a string and produces a
## list of token types for the characters.
fn typeListFromString(string) {
    <> collect(string, { ch <> @@(ch) })
};

## Private helper for `make*Set*`, which takes a `sense` argument and
## produces the desired rule.
fn genericMakeTokenSet(sense, types) {
    def set = {types*: true}; ## A set-like map of all the token types.

    ifIs { <> eq(set, {}) }
        {
            ## Trivial case: Empty set. Return an appropriate absolute rule.
            return ifIs { <> eq(sense, true) }
                { <> fail }
                { <> any }
        };

    <> ifIs { <> eq(sense, true) }
        { <> @PegTokenSet(set) }
        { <> @PegTokenSetComplement(set) }
};

## Documented in spec.
fn makeResult(value) {
    <> @PegResult(value)
};

## Documented in spec.
fn makeCharSet(strings*) {
    ## Make a combined string, passing it to the general token set constructor,
    ## which then splays all the characters out as a set of map keys.
    <> genericMakeTokenSet(true, typeListFromString(cat("", strings*)))
};

## Documented in spec.
fn makeCharSetComplement(strings*) {
    ## See comment in `makeCharSet`.
    <> genericMakeTokenSet(false, typeListFromString(cat("", strings*)))
};

## Documented in spec.
fn makeChoice(rules*) {
    ## Trivial case: No rules. Return the failure rule.
    ifIs { <> eq(rules, []) }
        { return @PegFail };

    ## Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(sizeOf(rules), 1) }
        { return rules* };

    ## The general case.
    <> @PegChoice(rules)
};

## Documented in spec.
fn makeCode(function) {
    <> @PegCode(function)
};

## Documented in spec.
fn makeLookaheadFailure(rule) {
    ## Optimiziation: Representation of `!.`.
    ifIs { <> eq(rule, @PegAny) }
        { return @PegEof };

    ## Optimization: Representation of `!()`.
    ifIs { <> eq(rule, empty) }
        { return @PegFail };

    ## The general case.
    <> @PegLookaheadFailure(rule)
};

## Documented in spec.
fn makeLookaheadSuccess(rule) {
    <> @PegLookaheadSuccess(rule)
};

## Documented in spec.
fn makeMainChoice(rules*) {
    <> @PegMain(makeChoice(rules*))
};

## Documented in spec.
fn makeMainSequence(rules*) {
    <> @PegMain(makeSequence(rules*))
};

## Documented in spec.
fn makeOpt(rule) {
    <> @PegOpt(rule)
};

## Documented in spec.
fn makePlus(rule) {
    <> @PegRepeat{rule, minSize: 1}
};

## Documented in spec.
fn makeSequence(rules*) {
    ## Trivial case: No rules. Return the empty rule.
    ifIs { <> eq(rules, []) }
        { return empty };

    ## Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(sizeOf(rules), 1) }
        { return rules* };

    ## The general case.
    <> @PegSequence(rules)
};

## Documented in spec.
fn makeStar(rule) {
    <> @PegRepeat{rule}
};

## Documented in spec.
fn makeThunk(function) {
    <> @PegThunk(function)
};

## Documented in spec.
fn makeString(string) {
    ## Trivial case: Empty string. Return an always-successful yield of `@""`.
    ifIs { <> eq(string, "") }
        { return @PegResult(@"") };

    ## Trivial case: One-char string. Return a simple one-char rule.
    ifIs { <> eq(sizeOf(string), 1) }
        { return makeToken(@@(string)) };

    ## This is implemented as, in effect, `(@"1" @"2" ... { <> string })`,
    ## which allows us to minimize code duplication.

    ## Make a list of rules per character.
    def types = typeListFromString(string);
    def chars = collect(types, makeToken);

    <> @PegSequence[chars*, @PegResult(@(string))]
};

## Documented in spec.
fn makeToken(type) {
    ## This is just uses a single-item token set. The performance difference
    ## between that and doing a more special-case single item type check is
    ## probably negligible.
    <> @PegTokenSet{(type): null}
};

## Documented in spec.
fn makeTokenSet(tokens*) {
    <> genericMakeTokenSet(true, tokens)
};

## Documented in spec.
fn makeTokenSetComplement(tokens*) {
    <> genericMakeTokenSet(false, tokens)
};


##
## Miscellaneous functions
##

## Documented in spec.
fn apply(rule, input) {
    def box = Box::makePromise();
    def generator = ifIs { <> hasType(input, String) }
        {
            ## This converts generated characters into tokens with the
            ## characters as the type.
            <> Generator::makeFilterGenerator(input) { ch <> @(ch) }
        }
        { <> input };

    <> ifIs { <> parse(rule, box, generator) }
        { <> fetch(box) }
};

## Documented in spec.
fn stringFromTokenList(tokens) {
    <> cat("", collect(tokens, get_typeName)*)
};


##
## Export mechanics
##

<> {
    any,
    apply,
    empty,
    eof,
    fail,
    makeCharSet,
    makeCharSetComplement,
    makeChoice,
    makeCode,
    makeLookaheadFailure,
    makeLookaheadSuccess,
    makeMainChoice,
    makeMainSequence,
    makeOpt,
    makePlus,
    makeResult,
    makeSequence,
    makeStar,
    makeString,
    makeThunk,
    makeToken,
    makeTokenSet,
    makeTokenSetComplement,
    parse,
    stringFromTokenList
}
