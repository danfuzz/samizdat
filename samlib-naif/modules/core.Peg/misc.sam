## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## PEG (Parsing Expression Grammar) support
##

#= language core.Lang0

import core.Generator :: makeFilterGenerator;

import ./PegResult :: makeResult;
import ./PegSequence :: makeSequence;
import ./PegTokenSet :: makeToken, makeTokenSet;
import ./PegTokenSetComplement :: makeTokenSetComplement;


##
## Private Definitions
##

## Helper for `makeCharSet*`, which takes a string and produces a
## list of token classes for the characters.
fn classListFromString(string) {
    return string.collect({ ch -> @@(ch) })
};


##
## Exported Definitions
##

## Documented in spec.
export fn apply(rule, input) {
    def result;
    def generator = ifIs { hasClass(input, String) }
        {
            ## This converts generated characters into tokens with the
            ## characters as the class name.
            makeFilterGenerator(input) { ch -> @(@@(ch)) }
        }
        { input };

    return? ifIs { rule.parse(var result, generator) }
        { result }
};

## Documented in spec.
export fn makeCharSet(strings*) {
    ## Make a combined string, passing it to the general token set constructor,
    ## which then splays all the characters out as a set of map keys.
    return makeTokenSet(classListFromString(cat("", strings*))*)
};

## Documented in spec.
export fn makeCharSetComplement(strings*) {
    ## See comment in `makeCharSet`.
    return makeTokenSetComplement(classListFromString(cat("", strings*))*)
};

## Documented in spec.
export fn makeString(string) {
    ## Trivial case: Empty string. Return an always-successful yield of `@""`.
    ifIs { eq(string, "") }
        { return makeResult(@"") };

    ## Trivial case: One-char string. Return a simple one-char rule.
    ifIs { eq(string.get_size(), 1) }
        { return makeToken(@@(string)) };

    ## This is implemented as, in effect, `(@"1" @"2" ... { string })`,
    ## which allows us to minimize code duplication.

    ## Make a list of rules per character.
    def clses = classListFromString(string);
    def chars = clses.collect(makeToken);

    return makeSequence(chars*, makeResult(@(@@(string))))
};

## Documented in spec.
export fn stringFromTokenList(tokens) {
    return "".cat(tokens.collect(get_className)*)
};
