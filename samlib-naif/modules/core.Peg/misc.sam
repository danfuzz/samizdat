## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## PEG (Parsing Expression Grammar) support
##

#= language core.Lang0

import core.Generator :: FilterGenerator;

import ./PegResult :: *;
import ./PegSequence :: *;
import ./PegTokenSet :: makeToken, makeTokenSet;
import ./PegTokenSetComplement :: makeTokenSetComplement;


##
## Private Definitions
##

## Helper for `makeCharSet*` and `makeString`, which takes a string and
## produces a list of token names for the characters.
fn nameListFromString(string) {
    return string.collect { ch -> cast(Symbol, ch) }
};


##
## Exported Definitions
##

## Documented in spec.
export fn apply(rule, input) {
    def result;
    def generator = ifIs { String.accepts(input) }
        {
            ## This converts generated characters into tokens with the
            ## characters as the class name.
            FilterGenerator.new(input) { ch -> @(cast(Symbol, ch)){} }
        }
        { input };

    return? ifIs { rule.parse(result?, generator) }
        { result }
};

## Documented in spec.
export fn makeCharSet(strings*) {
    ## Make a combined string, passing it to the general token set constructor,
    ## which then splays all the characters out as a set of map keys.
    return makeTokenSet(nameListFromString("".cat(strings*))*)
};

## Documented in spec.
export fn makeCharSetComplement(strings*) {
    ## See comment in `makeCharSet`.
    return makeTokenSetComplement(nameListFromString("".cat(strings*))*)
};

## Documented in spec.
export fn makeString(string) {
    def resultType = cast(Symbol, string);

    ## Trivial case: Empty string. Return an always-successful yield of `@""`.
    ifIs { eq(string, "") }
        { return PegResult.new(@""{}) };

    ## Trivial case: One-char string. Return a simple one-char rule.
    ifIs { eq(string.get_size(), 1) }
        { return makeToken(resultType) };

    ## This is implemented as, in effect, `(@"1" @"2" ... { string })`,
    ## which allows us to minimize code duplication.

    ## Make a list of rules per character.
    def names = nameListFromString(string);
    def chars = names.collect(makeToken);

    return PegSequence.new(chars*, PegResult.new(@(resultType){}))
};

## Documented in spec.
export fn stringFromTokenList(tokens) {
    return "".cat((tokens.collect { t -> t.get_name() })*)
};

## Documented in spec.
export fn symbolFromTokenList(tokens) {
    return cast(Symbol, stringFromTokenList(tokens))
};
