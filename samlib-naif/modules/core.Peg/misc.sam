## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## PEG (Parsing Expression Grammar) support
##

#= language core.Lang0

import core.Box :: nullBox;
import core.Generator :: filterPump, makeFilterGenerator;

import ./PegAny :: any;
import ./PegEof :: eof;
import ./PegFail :: fail;
import ./PegResult :: empty, makeResult;
import ./protocol :: parse;


##
## Class Definitions
##

## Documented in spec.
fn @@PegChoice.parse(box, input, items*) {
    filterPump(this::rules) { rule ->
        ifValue { parse(rule, box, input, items*) }
            { newInput -> return newInput }
    };

    ## No rule succeeded.
    return
};

## Documented in spec.
fn @@PegCode.parse(box, input, items*) {
    return? ifValue { this::function(items*) }
        { result ->
            box* := result;
            input
        }
};

## Documented in spec.
fn @@PegLookaheadFailure.parse(box, input, items*) {
    return? ifNot { parse(this::rule, nullBox, input, items*) }
        {
            box* := null;
            input
        }
};

## Documented in spec.
fn @@PegLookaheadSuccess.parse(box, input, items*) {
    return? ifIs { parse(this::rule, box, input, items*) }
        { input }
};

## Documented in spec.
fn @@PegMain.parse(box, input, .*) {
    ## The point of this implementation is to drop the `items` context.
    return? parse(this::rule, box, input)
};

## Documented in spec.
fn @@PegRepeat.parse(box, input, items*) {
    var remainingInput = input;
    var results = [];  ## Values that have been parsed by the inner rule.

    fn doLoop() { /out ->
        def rule = this::rule;
        var result;

        def maxCheck = ifValue { this::maxSize }
            { maxSize ->
                { ->
                    ifIs { eq(get_size(results), maxSize) }
                        { yield /out }
                }
            }
            { {->} };

        loop {
            ifValue { parse(rule, var result, remainingInput, items*) }
                { newInput ->
                    ## Successfully parsed the inner rule.
                    remainingInput := newInput;
                    results := [results*, result];
                    maxCheck()
                }
                {
                    ## Failed to parse the inner rule.
                    yield /out
                }
        }
    };

    doLoop();

    ## Check for minimum match count. Store result and return success if
    ## appropriate.
    return? ifIs { ge(get_size(results), this::minSize) }
        {
            box* := results;
            remainingInput
        }
};

## Documented in spec.
fn @@PegSequence.parse(box, input, items*) {
    ## Each rule after the first gets passed as additional arguments
    ## the matched results of all the previous rules, in order.

    var remainingInput = input;
    var results = items;  ## Includes intial items and each parsed value.
    var result = null;

    ## This is akin to `for (rule in this::rules) { ... }`.
    filterPump(this::rules) { rule ->
        ifValue { parse(rule, var result, remainingInput, results*) }
            { newInput ->
                remainingInput := newInput;
                results := [results*, result]
            }
            {
                ## Propagate the failure.
                return
            }
    };

    box* := result;
    return remainingInput
};

## Documented in spec.
fn @@PegThunk.parse(box, input, items*) {
    return? ifValue { this::function(items*) }
        { thunkResult -> parse(thunkResult, box, input, items*) }
};

## Documented in spec.
fn @@PegTokenSet.parse(box, input, items*) {
    def result;

    return? ifValue { nextValue(input, var result) }
        { newInput ->
            ifIs { get(this::set, get_class(result)) }
                {
                    box* := result;
                    newInput
                }
        }
};

## Documented in spec.
fn @@PegTokenSetComplement.parse(box, input, items*) {
    def result;

    return? ifValue { nextValue(input, var result) }
        { newInput ->
            ifNot { get(this::set, get_class(result)) }
                {
                    box* := result;
                    newInput
                }
        }
};


##
## Private Definitions
##

## Helper for `makeCharSet*`, which takes a string and produces a
## list of token classes for the characters.
fn classListFromString(string) {
    return collect(string, { ch -> @@(ch) })
};

## Helper for `make*Set*`, which takes a `sense` argument and
## produces the desired rule.
fn genericMakeTokenSet(sense, clses) {
    def set = {clses*: true};  ## A set-like map of all the token classes.

    ifIs { eq(set, {}) }
        {
            ## Trivial case: Empty set. Return an appropriate absolute rule.
            return ifIs { eq(sense, true) } { fail } { any }
        };

    return ifIs { eq(sense, true) }
        { @PegTokenSet{set} }
        { @PegTokenSetComplement{set} }
};


##
## Exported Definitions
##

## Documented in spec.
export fn apply(rule, input) {
    def result;
    def generator = ifIs { hasClass(input, String) }
        {
            ## This converts generated characters into tokens with the
            ## characters as the class name.
            makeFilterGenerator(input) { ch -> @(@@(ch)) }
        }
        { input };

    return? ifIs { parse(rule, var result, generator) }
        { result }
};

## Documented in spec.
export fn makeCharSet(strings*) {
    ## Make a combined string, passing it to the general token set constructor,
    ## which then splays all the characters out as a set of map keys.
    return genericMakeTokenSet(true, classListFromString(cat("", strings*)))
};

## Documented in spec.
export fn makeCharSetComplement(strings*) {
    ## See comment in `makeCharSet`.
    return genericMakeTokenSet(false, classListFromString(cat("", strings*)))
};

## Documented in spec.
export fn makeChoice(rules*) {
    ## Trivial case: No rules. Return the failure rule.
    ifIs { eq(rules, []) }
        { return fail };

    ## Trivial case: One rule. Return that rule directly.
    ifIs { eq(get_size(rules), 1) }
        { return rules* };

    ## The general case.
    return @PegChoice{rules}
};

## Documented in spec.
export fn makeCode(function) {
    return @PegCode{function}
};

## Documented in spec.
export fn makeLookaheadFailure(rule) {
    ## Optimiziation: Representation of `!.`.
    ifIs { eq(rule, any) }
        { return eof };

    ## Optimization: Representation of `!()`.
    ifIs { eq(rule, empty) }
        { return fail };

    ## The general case.
    return @PegLookaheadFailure{rule}
};

## Documented in spec.
export fn makeLookaheadSuccess(rule) {
    return @PegLookaheadSuccess{rule}
};

## Documented in spec.
export fn makeMainChoice(rules*) {
    return @PegMain{rule: makeChoice(rules*)}
};

## Documented in spec.
export fn makeMainSequence(rules*) {
    return @PegMain{rule: makeSequence(rules*)}
};

## Documented in spec.
export fn makeParserThunk(function) {
    return @PegThunk{function}
};

## Documented in spec.
export fn makeRepeat(rule, optMinSize?, optMaxSize?) {
    def minSize = ifValueOr { optMinSize* } { 0 };
    def maxMap = ifValue { optMaxSize* } { sz -> {maxSize: sz} } { {} };
    return @PegRepeat{maxMap*, minSize, rule}
};

## Documented in spec.
export fn makeSequence(rules*) {
    ## Trivial case: No rules. Return the empty rule.
    ifIs { eq(rules, []) }
        { return empty };

    ## Trivial case: One rule. Return that rule directly.
    ifIs { eq(get_size(rules), 1) }
        { return rules* };

    ## The general case.
    return @PegSequence{rules}
};

## Documented in spec.
export fn makeString(string) {
    ## Trivial case: Empty string. Return an always-successful yield of `@""`.
    ifIs { eq(string, "") }
        { return makeResult(@"") };

    ## Trivial case: One-char string. Return a simple one-char rule.
    ifIs { eq(get_size(string), 1) }
        { return makeToken(@@(string)) };

    ## This is implemented as, in effect, `(@"1" @"2" ... { string })`,
    ## which allows us to minimize code duplication.

    ## Make a list of rules per character.
    def clses = classListFromString(string);
    def chars = collect(clses, makeToken);

    return makeSequence(chars*, makeResult(@(@@(string))))
};

## Documented in spec.
export fn makeToken(cls) {
    ## This is just uses a single-item token set. The performance difference
    ## between that and doing a more special-case single item class check is
    ## probably negligible.
    return makeTokenSet(cls)
};

## Documented in spec.
export fn makeTokenSet(clses*) {
    return genericMakeTokenSet(true, clses)
};

## Documented in spec.
export fn makeTokenSetComplement(clses*) {
    return genericMakeTokenSet(false, clses)
};

## Documented in spec.
export fn stringFromTokenList(tokens) {
    return cat("", collect(tokens, get_className)*)
};
