## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## PEG (Parsing Expression Grammar) support
##

#= language core.Lang0

import core.Generator :: makeFilterGenerator;

import ./PegAny :: any;
import ./PegFail :: fail;
import ./PegResult :: makeResult;
import ./PegSequence :: makeSequence;
import ./protocol :: parse;


##
## Class Definitions
##

## Documented in spec.
fn @@PegTokenSet.parse(box, input, items*) {
    def result;

    return? ifValue { nextValue(input, var result) }
        { newInput ->
            ifIs { get(this::set, get_class(result)) }
                {
                    box* := result;
                    newInput
                }
        }
};

## Documented in spec.
fn @@PegTokenSetComplement.parse(box, input, items*) {
    def result;

    return? ifValue { nextValue(input, var result) }
        { newInput ->
            ifNot { get(this::set, get_class(result)) }
                {
                    box* := result;
                    newInput
                }
        }
};


##
## Private Definitions
##

## Helper for `makeCharSet*`, which takes a string and produces a
## list of token classes for the characters.
fn classListFromString(string) {
    return collect(string, { ch -> @@(ch) })
};

## Helper for `make*Set*`, which takes a `sense` argument and
## produces the desired rule.
fn genericMakeTokenSet(sense, clses) {
    def set = {clses*: true};  ## A set-like map of all the token classes.

    ifIs { eq(set, {}) }
        {
            ## Trivial case: Empty set. Return an appropriate absolute rule.
            return ifIs { eq(sense, true) } { fail } { any }
        };

    return ifIs { eq(sense, true) }
        { @PegTokenSet{set} }
        { @PegTokenSetComplement{set} }
};


##
## Exported Definitions
##

## Documented in spec.
export fn apply(rule, input) {
    def result;
    def generator = ifIs { hasClass(input, String) }
        {
            ## This converts generated characters into tokens with the
            ## characters as the class name.
            makeFilterGenerator(input) { ch -> @(@@(ch)) }
        }
        { input };

    return? ifIs { parse(rule, var result, generator) }
        { result }
};

## Documented in spec.
export fn makeCharSet(strings*) {
    ## Make a combined string, passing it to the general token set constructor,
    ## which then splays all the characters out as a set of map keys.
    return genericMakeTokenSet(true, classListFromString(cat("", strings*)))
};

## Documented in spec.
export fn makeCharSetComplement(strings*) {
    ## See comment in `makeCharSet`.
    return genericMakeTokenSet(false, classListFromString(cat("", strings*)))
};

## Documented in spec.
export fn makeString(string) {
    ## Trivial case: Empty string. Return an always-successful yield of `@""`.
    ifIs { eq(string, "") }
        { return makeResult(@"") };

    ## Trivial case: One-char string. Return a simple one-char rule.
    ifIs { eq(get_size(string), 1) }
        { return makeToken(@@(string)) };

    ## This is implemented as, in effect, `(@"1" @"2" ... { string })`,
    ## which allows us to minimize code duplication.

    ## Make a list of rules per character.
    def clses = classListFromString(string);
    def chars = collect(clses, makeToken);

    return makeSequence(chars*, makeResult(@(@@(string))))
};

## Documented in spec.
export fn makeToken(cls) {
    ## This is just uses a single-item token set. The performance difference
    ## between that and doing a more special-case single item class check is
    ## probably negligible.
    return makeTokenSet(cls)
};

## Documented in spec.
export fn makeTokenSet(clses*) {
    return genericMakeTokenSet(true, clses)
};

## Documented in spec.
export fn makeTokenSetComplement(clses*) {
    return genericMakeTokenSet(false, clses)
};

## Documented in spec.
export fn stringFromTokenList(tokens) {
    return cat("", collect(tokens, get_className)*)
};
