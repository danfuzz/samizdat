## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Baseline I/O functions
##


def Collection = moduleLoad(["core", "Collection"]);
def Format     = moduleLoad(["core", "Format"]);
def Generator  = moduleLoad(["core", "Generator"]);
def Io0        = moduleLoad(["core", "Io0"]);
def Number     = moduleLoad(["proto", "Number"]);
def Peg        = moduleLoad(["core", "Peg"]);
def Range      = moduleLoad(["core", "Range"]);
def Sequence   = moduleLoad(["core", "Sequence"]);


##
## Private Definitions: `parPathString`
##

## Parses a single path component.
def parPathComponent = {:
    ## Ignore duplicate slashes, but require at least one. Note: The parser
    ## is only ever called on a string that begins with a slash.
    "/"+

    ## Match the component text. This is a `*` and not a `+` rule, in order to
    ## successfully match a string-final empty component (that is, a trailing
    ## slash on the overall path string).
    component = [! "/"]*
    { <> Peg::stringFromTokenList(component) }
:};

## Parses a regular (non-up-directory) component. The `..` check ensures that
## `..` only gets parsed as part of a balanced `name/..` pair.
def parRegularComponent = {:
    component = parPathComponent
    {
        <> ifIs { <> ne(component, "..") }
            { <> [component] }
    }
:};

## Parses a matched set of components that are collectively ignored, e.g.
## `"/x/y/../.."` or `"/."`.
def parIgnoredComponent;
parIgnoredComponent := {:
    component = parRegularComponent

    (
        { <> eq(component, ["."]) }
    |
        (%parIgnoredComponent)?
        dotdot = parPathComponent
        { <> eq(dotdot, "..") }
    )

    { <> [] }
:};

## Helper for `pathFromFlat` which parses absolute path strings
## into components. This canonicalizes the path by ignoring duplicate
## slashes, `.` components, and matched `name/..` pairs.
def parPathString = {:
    components = (parIgnoredComponent | parRegularComponent)+

    (
        .
        { <> "Invalid `..` component in path" }
    |
        { <> cat(components*) }
    )
:};


##
## Private Definitions
##

## Helper for `flatFromPath` which validates a single path component.
## Yields an error string on invalid. Parsing fails for valid components.
def parErrorFromPathComponent = {:
    ".." !.
    { <> "Invalid `..` component in path." }
|
    "." !.
    { <> "Invalid `.` component in path." }
|
    !.
    { <> "Invalid empty component in path." }
|
    [! "/\0"]+
    (
        "/"
        { <> "Invalid `/` in path." }
    |
        "\0"
        { <> "Invalid `\\0` in path." }
    )
:};

## Checks whether the given alleged prefix is actually a prefix of the
## given path, or equal to it.
fn isPrefix(prefix, path) {
    def prefixSize = Collection::sizeOf(prefix);

    ifIs { <> gt(prefixSize, Collection::sizeOf(path)) }
        {
            ## The "prefix" is longer than the path, so it can't actually be
            ## a prefix.
            return
        };

    <> eq(prefix, Sequence::sliceExclusive(path, 0, prefixSize))
};

## Dies with the given message including the given path.
fn dieWith(msg, path) {
    die(cat(msg, ": ", Format::source(path)))
};

## Helper for `sandboxedReader` which does symbolic link resolution,
## respecting the sandbox directory.
fn resolveLinks(sandboxDirectory, path) {
    var result = path;
    var limit = 50;

    loop {
        ifIs { <> perLe(limit, 0) }
            { die("Too many links in symbolic link chain.") };

        ifNot { <> isPrefix(sandboxDirectory, result) }
            { die("Symbolic link escapes sandbox directory.") };

        <> ifValue { <> readLink(result) }
            { newPath ->
                result := newPath;
                limit := Number::sub(limit, 1)
            }
            { return result }
    }
};


##
## Exported Definitions
##

## Documented in spec.
fn fileExists(path) {
    <> ifIs { <> Io0::flatFileExists(flatFromPath(path)) }
        { <> path }
};

## Documented in spec.
fn flatFromPath(path) {
    ifIs { <> eq(path, []) }
        { dieWith("Invalid empty path", path) };

    def gen =
        Generator::makeFilterGenerator(
            path, Range::makeOpenRange(Collection::sizeOf(path), -1))
            { <out> one, n ->
                ## This test skips the check on the last path component, if it
                ## happens to be empty (which is the only valid case of an
                ## empty path component).
                ifIs { <> eq([one, n], ["", 1]) }
                    { <out> "/" }
                    {
                        ifValue
                            { <> Peg::apply(parErrorFromPathComponent, one) }
                            { error -> dieWith(error, path) }
                    };
                <> cat("/", one)
            };

    <> cat(gen*)
};

## Documented in spec.
fn pathFromFlat(string) {
    ## Reject the empty string.
    ifIs { <> eq(string, "") }
        { dieWith("Invalid path", "") };

    ## Prepend the current directory if the path isn't absolute.
    def absoluteString = ifIs { <> eq(Sequence::nth(string, 0), "/") }
        { <> string }
        { <> cat(Io0::flatCwd(), "/", string) };

    ## Parse the string into components (or an error string).
    def components = Peg::apply(parPathString, absoluteString);

    ifIs { <> hasType(components, String) }
        { dieWith(components, string) };

    <> components
};

## Documented in spec.
fn readFileUtf8(path) {
    <> Io0::flatReadFileUtf8(flatFromPath(path))
};

## Documented in spec.
fn readLink(path) {
    <> ifValue { <> Io0::flatReadLink(flatFromPath(path)) }
        { newPath <> pathFromFlat(newPath) }
};

## Documented in spec.
fn sandboxedReader(directory) {
    <> { path ->
        def fullPath = resolveLinks(directory, [directory*, path*]);
        <> readFileUtf8(fullPath);
    }
};

## Documented in spec.
fn writeFileUtf8(path, text) {
    <> Io0::flatWriteFileUtf8(flatFromPath(path), text)
};

<> {
    fileExists,
    flatFromPath,
    pathFromFlat,
    readFileUtf8,
    readLink,
    sandboxedReader,
    writeFileUtf8
}
