## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `SerialGenerator` Type
##
## Payload is `[subGens*]`, a list of sub-generators.

def Box = moduleLoad(["core", "Box"]);
def Sequence = moduleLoad(["core", "Sequence"]);

def NullGenerator = localLoad(["NullGenerator"]);


##
## Exported Definitions
##

## Documented in spec.
fn makeSerialGenerator(generators*) {
    ## Return the `nullGenerator` if we weren't passed any arguments.
    ifIs { <> eq(generators, []) }
        { return NullGenerator::nullGenerator };

    ## Return the argument directly if we were only passed one.
    ## This saves some gratuitous call wrapping / double yields.
    ifIs { <> eq(Collection::sizeOf(generators), 1) }
        { return generators* };

    <> @SerialGenerator(generators)
};

## Documented in spec.
fn SerialGenerator_nextValue(gen, box) {
    def subGens = dataOf(gen);

    <> ifValue { <> get(subGens, 0) }
        { firstGen ->
            def moreGens = Sequence::sliceInclusive(subGens, 1);
            def innerBox = Box::makePromise();

            <> ifValue { <> nextValue(firstGen, innerBox) }
                { nextGenerator ->
                    Box::store(box, Box::fetch(innerBox));
                    <> @SerialGenerator[nextGenerator, moreGens*]
                }
                {
                    ## First generator was voided.
                    <> nextValue(
                        makeSerialGenerator(moreGens*),
                        box)
                }
        }
        {
            ## Totally voided.
            Box::store(box)
        }
};
genericBind(nextValue, @@SerialGenerator, SerialGenerator_nextValue);

## Just use the standard implementation.
genericBind(collect, @@SerialGenerator, Generator_stdCollect);

<> {
    makeSerialGenerator
}
