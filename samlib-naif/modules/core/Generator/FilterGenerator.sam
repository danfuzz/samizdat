## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `FilterGenerator` Type
##
## Payload is a map `[filterFunction: function, generator: subGen]`.
## `subGen` is expected to produce lists of arguments to apply.

def Box = moduleLoad(["core", "Box"]);

def ParaGenerator = localLoad(["ParaGenerator"]);


##
## Exported Definitions
##

## Documented in spec.
fn makeFilterGenerator(filterFunction, generators*) {
    <> @FilterGenerator{
        filterFunction,
        generator: ParaGenerator::makeParaGenerator(generators*)
    }
};

## Documented in spec.
fn FilterGenerator_nextValue(gen, box) {
    def payload = dataOf(gen);
    def filterFunction = payload::filterFunction;

    ## This loop handles the fact that the filter function is
    ## allowed to yield void to indicate a generated value is to
    ## be discarded.
    var innerGen = payload::generator;
    loop { <next> ->
        def innerBox = Box::makePromise();

        ifValue { <> nextValue(innerGen, innerBox) }
            { nextGen ->
                ifValue { <> filterFunction(Box::fetch(innerBox)*) }
                    { value ->
                        Box::store(box, value);
                        return @FilterGenerator(
                            Collection::put(payload, "generator", nextGen))
                    }
                    {
                        ## The filter discarded the value. Iterate!
                        innerGen := nextGen;
                        <next>
                    }
            };

        ## The inner generator was voided.
        Box::store(box);
        return
    }
};
genericBind(nextValue, @@FilterGenerator, FilterGenerator_nextValue);

## Just use the standard implementation.
genericBind(collect, @@FilterGenerator, Generator_stdCollect);

<> {
    makeFilterGenerator
}
