## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Module loading mechanism
##
## **Note:** When running fully interpreted, this file is loaded twice. The
## first time is before any other in-language definitions are made, which is
## why there are references to internal-form names instead of the more
## usual `Module::name` style.
##

##
## Private definitions
##

## Set-like map of characters that are not allowed in module components.
def INVALID_MODULE_CHARS = {[".", "/", "\0"]*: @Null};

## Helper for `flattenModulePath`, which processes a single component. It
## rejects empty components and components with dots, slashes, or null
## characters (`\0`) in them. It returns the component prefixed with `.`
## on success.
fn flattenModuleComponent(component) {
    ifIs { <> eq(component, "") }
        { Io0_die("Invalid module path component: empty string") };
    ifNot { <> hasType(component, String) }
        { Io0_die("Invalid module path component: not a string") };

    ## `collect` is used here as a "for each," ignoring the collected result.
    collect(component,
        { ch ->
            ifIs { <> get(INVALID_MODULE_CHARS, ch) }
                { Io0_die("Invalid character in module path component.") }
        });

    <> cat(".", component)
};

## Flattens a module path (list of component names) to a simple string, which
## corresponds to both the "human" name of the module and the directory name
## that the module could be found in.
fn flattenModulePath(name) {
    ifIs { <> eq(name, []) }
        { Io0_die("Invalid module path: empty list") };
    ifNot { <> hasType(name, List) }
        { Io0_die("Invalid module path: not a list") };

    ## Validate each component, prefixing them with `.`. Concatenate them all
    ## together, and drop the leading `.`.
    def withDots = collect(name, flattenModuleComponent);
    <> Sequence_sliceInclusive(cat(withDots*), 1)
};

## Flattens an absolute path to a simple name, optionally adding a suffix
## to the final path component.
##
## **Note:** This function is a (low rent) duplicate of functionality in
## `Io*` modules, because this function needs to be called before the `Io*`
## modules are loaded.
fn flattenPath(path, optSuffix?) {
    ## Prefix each component with `/`, and concatenate them all together.
    def withSlashes = collect(path, { elem <> cat("/", elem) });
    <> cat(withSlashes*, optSuffix*);
};

## Flattens a (presumably relative) path to a string, for use when emitting
## messages to the console.
fn humanPath(path) {
    ## Prefix each component with `/`, concatenate them all together, and
    ## drop the leading `/`.
    def withSlashes = collect(path, { elem <> cat("/", elem) });
    <> Sequence_sliceInclusive(cat(withSlashes*), 1)
};

## Updates a map-containing box to have the given additional / replacement
## binding.
fn updateMapBox(box, key, value) {
    def newMap = { Box_fetch(box)*, (key): value };
    Box_store(box, newMap)
};


##
## Generic functions
##

## Documented in spec.
def moduleLoad = makeRegularGeneric("moduleLoad", 2, 2);

## Documented in spec.
def intraLoad   = makeRegularGeneric("intraLoad", 2, 2);
def intraRead   = makeRegularGeneric("intraRead", 2, 2);
def intraExists = makeRegularGeneric("intraExists", 2, 2);


##
## Type Definition: `ModuleLoader`
##
## Payload:
## * `next` -- next `ModuleLoader` to check when trying to find a module
## * `basePath` -- absolute path prefix for all loading. Relative subdirectory
##   paths correspond to modules
## * `globals` -- global variable context to use when loading
## * `loadedBox` -- map from partial paths to the results of loading
##
## TODO: This should be an opaque type.
##

## Helper for `moduleLoad` which does the actual loading.
fn doModuleLoad(md, dotName) {
    def data = dataOf(md);
    def modulePath = [data::basePath*, dotName];

    def infoPath = flattenPath([modulePath*, "main.saminfo"]);
    <> ifIs { <> Io0_flatFileExists(infoPath) }
        {
            Io0_note(cat("    ", dotName));
            def loader = makeIntraLoader(modulePath, md, data::globals);

            ## A successful void module load result gets silently transformed
            ## to the empty map.
            def result = ifValueOr { <> intraLoadMain(loader) }
                { <> {} };

            Io0_note("        Done.");
            <> result
        }
};

## Documented in spec.
genericBind(
    moduleLoad,
    @@ModuleLoader,
    fn ModuleLoader_moduleLoad(md, path) {
        def data = dataOf(md);
        def loadedBox = data::loadedBox;
        def dotName = flattenModulePath(path);

        ## The loaded map maps paths to `"loading"` for a load-in-progress
        ## and to `[result]` for a successfully-loaded result.

        ifValue { <> get(Box_fetch(loadedBox), dotName) }
            { found ->
                ifIs { <> eq(found, "loading") }
                    { Io0_die(cat("Module load loop: ", dotName)) };
                return found*
            };

        updateMapBox(loadedBox, dotName, "loading");

        def result = ifValueOr { <> doModuleLoad(md, dotName) }
            { <> moduleLoad(data::next, path) };

        updateMapBox(loadedBox, dotName, [result]);
        <> result
    });

## Documented in spec.
genericBind(
    moduleLoad,
    @@Null,
    fn Null_moduleLoad(md, path) {
        Io0_die(cat("Module not found: ", flattenModulePath(path)))
    });

## Documented in spec.
fn makeModuleLoader(path, nextModuleLoader, globals) {
    <> @ModuleLoader{
        globals,
        next: nextModuleLoader,
        basePath: path,
        loadedBox: Box_makeCell({})
    }
};


##
## Type Definition: `IntraLoader`
##
## Payload:
## * `moduleLoader` -- module loader
## * `basePath` -- absolute path prefix for all loading
## * `globals` -- global variable context to use when loading
## * `languageModule` -- language module to use when loading
## * `loadedBox` -- map from partial paths to the results of loading
##
## TODO: This should be an opaque type.
##

## Helper for `intraLoad` which does the actual loading.
fn doLocalLoad(ml, path) {
    Io0_note(cat("        ", humanPath(path)));
    def data = dataOf(ml);
    def pathPrefix = [data::basePath*, path*];

    def binPath = flattenPath(pathPrefix, ".samb");
    ifIs { <> Io0_flatFileExists(binPath) }
        {
            def func = Lang0_evalBinary(data::globals, binPath);
            return func()
        };

    def sourcePath = flattenPath(pathPrefix, ".sam");
    ifIs { <> Io0_flatFileExists(sourcePath) }
        {
            def lang = data::languageModule;
            def text = Io0_flatReadFileUtf8(sourcePath);
            def tree = lang::parseProgram(text);
            def func = lang::eval(data::globals, tree);
            return func()
        };

    Io0_die(cat("Missing code: ", sourcePath));
};

## Documented in spec.
genericBind(
    intraExists,
    @@IntraLoader,
    fn IntraLoader_intraExists(ml, path) {
        def data = dataOf(ml);
        def fullPath = flattenPath([data::basePath*, path*]);
        <> ifIs { <> Io0_flatFileExists(fullPath) }
            { <> path }
    });

## Documented in spec.
genericBind(
    intraLoad,
    @@IntraLoader,
    fn IntraLoader_intraLoad(ml, path) {
        def data = dataOf(ml);
        def loadedBox = data::loadedBox;

        ## Local loads are allowed to return void, so we track a list of
        ## the result. That is, a void return ends up being `[]`.

        ifValue { <> get(Box_fetch(loadedBox), path) }
            { found -> return found* };

        def optResult = doLocalLoad(ml, path)?;
        updateMapBox(loadedBox, path, optResult);
        <> optResult*
    });

## Documented in spec.
genericBind(
    intraRead,
    @@IntraLoader,
    fn IntraLoader_intraRead(ml, path) {
        def data = dataOf(ml);
        def fullPath = flattenPath([data::basePath*, path*]);

        ifNot { <> Io0_flatFileExists(fullPath) }
            { Io0_die(cat("Missing resource: ", fullPath)) };

        <> Io0_flatReadFileUtf8(fullPath)
    });

## Documented in spec.
fn makeIntraLoader(path, nextModuleLoader, globals) {
    ## If the module info file (`main.saminfo`) exists, it must evaluate to a
    ## map. If it does not exist, create minimal "anonymous" module info.
    def infoPath = flattenPath([path*, "main.saminfo"]);
    def moduleInfo = ifIs { <> Io0_flatFileExists(infoPath) }
        {
            def text = Io0_flatReadFileUtf8(infoPath);
            <> Lang0_eval(globals, Lang0_parseExpression(text))
        }
        { <> {name: [], version: "0"} };

    def moduleLoader = makeModuleLoader(
        [path*, "modules"], nextModuleLoader, globals);

    ## Forward declaration, for recursive references in the `module_*`
    ## functions immediately below.
    def result;

    fn module_intraExists(path)   { <> intraExists(result, path)      };
    fn module_intraLoad(path)     { <> intraLoad(result, path)        };
    fn module_intraRead(path)     { <> intraRead(result, path)        };
    fn module_moduleLoad(path)    { <> moduleLoad(moduleLoader, path) };
    fn module_moduleLoader()      { <> moduleLoader                   };

    def fullGlobals = {
        globals*,
        intraExists:       module_intraExists,
        intraLoad:         module_intraLoad,
        intraRead:         module_intraRead,
        moduleLoad:        module_moduleLoad,
        moduleLoader:      module_moduleLoader
    };

    def languageName = ifValueOr { <> get(moduleInfo, "language") }
        { <> "Lang2" };
    def languageModule = ifIs { <> ne(languageName, "none") }
        { <> module_moduleLoad(["core", languageName]) }
        {
            ## Language `none`, a special case used when loading files before
            ## `Lang0` is defined.
            <> {
                eval:         Lang0_eval,
                parseProgram: Lang0_parseProgram
            }
        };

    result := @IntraLoader{
        languageModule,
        moduleLoader,
        globals: fullGlobals,
        basePath: path,
        loadedBox: Box_makeCell({})
    };

    <> result
};


##
## Exported Definitions
##

## Documented in spec.
fn intraLoadMain(loader) {
    <> intraLoad(loader, ["main"])
};

## Documented in spec.
fn run(path, moduleLoader, globals, args*) {
    def loader = makeIntraLoader(path, moduleLoader, globals);
    def optMainModule = intraLoadMain(loader)?;

    ifIs { <> eq(optMainModule, []) }
        { Io0_die("No exports from module's `main`.") };

    def mainModule = optMainModule*;

    ifNot { <> hasType(mainModule, Map) }
        { Io0_die("Non-map export from module's `main`.") };

    def optMain = mainModule::main?;

    ifIs { <> eq(optMain, []) }
        { Io0_die("No `main` export from module's `main`.") };

    <> (optMain*)(args*)
};

<> {
    intraLoad,
    intraLoadMain,
    intraRead,
    intraExists,
    makeIntraLoader,
    makeModuleLoader,
    moduleLoad,
    run
}
