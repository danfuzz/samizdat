## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Module loading mechanism
##
## **Note:** When running fully interpreted, this file is loaded three times.
## The first time is before any other in-language definitions are made;
## Notably, `null` isn't yet defined, so we manually define it early in the
## file.
##

## This directive only has an effect when the module system loads *itself*
## in a chained loader. The primordial / bootstrap module system gets loaded
## as a layer 0 file no matter what the directive says (or doesn't say).
#= language core.Lang0


## Bootstrap modules `core.Code`, `core.Io0`, and `core.Lang0`. Bindings
## are all as documented in the spec. These are set up here in order to
## avoid the infinite regress of trying to load these modules as their
## own prerequisites.

def $Code = {
    eval:       Code_eval,
    evalBinary: Code_evalBinary
};

def $Io0 = {
    cwd:           Io0_cwd,
    fileType:      Io0_fileType,
    readFileUtf8:  Io0_readFileUtf8,
    readLink:      Io0_readLink,
    writeFileUtf8: Io0_writeFileUtf8
};

def $Lang0 = {
    languageOf:      Lang0_languageOf,
    parseExpression: Lang0_parseExpression,
    parseProgram:    Lang0_parseProgram,
    simplify:        Lang0_simplify,
    tokenize:        Lang0_tokenize
};

## Makes an entry for `BOOTSTRAP_MODULES`.
fn makeBootstrapEntry(exports) {
    <> @module{
        exports,
        info: {
            exports:   {Collection_keyList(exports)*: Value},
            imports:   {},
            resources: {}
        }
    }
};

def BOOTSTRAP_MODULES = {
    @external("core.Code"):  makeBootstrapEntry($Code),
    @external("core.Io0"):   makeBootstrapEntry($Io0),
    @external("core.Lang0"): makeBootstrapEntry($Lang0)
};


##
## Private definitions
##

## See header comment.
def null = @Null;

## Default language module to use, when language is unspecified.
def DEFAULT_LANGUAGE = "core.Lang2";

## Set-like map of characters that are allowed in module and file components.
def VALID_COMPONENT_CHARS = {
    "_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"*: null
};

## Gets the file name suffix of the last component of the given path.
## **Note:** This is written in a super-oddball way, because of how little
## core library is actually available at this point.
fn fileNameSuffix(path) {
    var gotDot = 0;
    var result = "";

    ## `collect` is used here as a "for-each," ignoring the collected result.
    collect(path,
        { ch ->
            ifIs { <> eq(ch, "/") }
                {
                    ## New path component.
                    gotDot := 0;
                }
                {
                    ifIs { <> eq(ch, ".") }
                        {
                            gotDot := 1;
                            result := "";
                        }
                        { result := cat(result, ch) }
                }
        });

    <> ifIs { <> eq(gotDot, 0) }
        { <> "" }
        { <> result }
};

## Helper for `checkExternalSource`: Validates a character pair.
fn checkExternalSourcePair(lastCh, ch) {
    ifIs { <> eq(ch, ".") }
        {
            ifIs { <> eq(lastCh, ".") }
                { die("Invalid external source: empty component") };
            return
        };

    ifNot { <> get(VALID_COMPONENT_CHARS, ch) }
        { die(cat("Invalid external source: bad character \"", ch, "\"")) }
};

## Validates an external `source`. This returns the given `source` if it
## is a valid external source, or void if it is some other kind of source.
## If `source` is marked `@external` but is improperly-formed, this dies
## with an error.
fn checkExternalSource(source) {
    ifNot { <> hasType(source, @@external) }
        { return };

    def name = dataOf(source);

    ifNot { <> hasType(name, String) }
        { die("Invalid external source: not a string") };
    ifIs { <> eq(name, "") }
        { die("Invalid external source: empty string") };

    var lastCh = ".";  ## Init to `"."` to make the first check work out.

    ## `collect` is used here as a "for-each," ignoring the collected result.
    collect(name,
        { ch ->
            checkExternalSourcePair(lastCh, ch);
            lastCh := ch
        });

    checkExternalSourcePair(lastCh, ".");
    <> source
};

## Helper for `checkInternalSource`: Validates a character pair.
fn checkInternalSourcePair(lastCh, ch) {
    ifIs { <> eq(ch, "/") }
        {
            ifIs { <> eq(lastCh, "/") }
                { die("Invalid internal source: empty component") };
            ifIs { <> eq(lastCh, ".") }
                { die("Invalid internal source: empty suffix") };
            return
        };

    ifIs { <> eq(ch, ".") }
        {
            ifIs { <> eq(lastCh, "/") }
                { die("Invalid internal source: component-initial dot") };
            ifIs { <> eq(lastCh, ".") }
                { die("Invalid internal source: double dot") };
            return
        };

    ifNot { <> get(VALID_COMPONENT_CHARS, ch) }
        { die(cat("Invalid internal source: bad character \"", ch, "\"")) }
};

## Validates an internal `source`. This returns the given `source` if it
## is a valid internal source, or void if it is some other kind of source.
## If `source` is marked `@internal` but is improperly-formed, this dies
## with an error.
fn checkInternalSource(source) {
    ifNot { <> hasType(source, @@internal) }
        { return };

    def path = dataOf(source);

    ifNot { <> hasType(path, String) }
        { die("Invalid internal source: not a string") };
    ifIs { <> eq(path, "") }
        { die("Invalid internal source: empty string") };

    var lastCh = "/";  ## Init to `"/"` to make the first check work out.

    ## `collect` is used here as a "for-each," ignoring the collected result.
    collect(path,
        { ch ->
            checkInternalSourcePair(lastCh, ch);
            lastCh := ch;
        });

    checkInternalSourcePair(lastCh, "/");
    <> source
};

## Validates an absolute file path string. It must be a string and start with
## `"/"`.
fn checkAbsolutePath(path) {
    ifIs { <> eq(path, "") }
        { die("Invalid file path: empty string") };
    ifNot { <> hasType(path, String) }
        { die("Invalid file path: not a string") };
    ifNot { <> eq(get(path, 0), "/") }
        { die("Invalid file path: not absolute") }
};

## Returns a human-oriented string name for a source.
fn sourceString(source) {
    ifIs { <> hasType(source, @@internal) }
        { return cat("./", dataOf(source)) };
    ifIs { <> hasType(source, @@external) }
        { return dataOf(source) };

    die("Bad module / resource `source`.")
};

## Loads the standard global environment using the given `loader`.
fn loadGlobals(loader) {
    <> loadModule(loader, @external("core.Globals"))::fullEnvironment()
};

## Given source text, returns a parsed tree form, using the given `loader`
## to find the apprpriate parser.
fn treeFromText(loader, text) {
    def languageName = ifValueOr { <> $Lang0::languageOf(text) }
        { <> DEFAULT_LANGUAGE };
    def lang = loadModule(loader, @external(languageName));

    ## TODO: Provide a real `resolveFn` here.
    def resolveFn = { . <> };
    <> lang::simplify(lang::parseProgram(text), resolveFn);
};

## Updates a map-containing box to have the given additional / replacement
## binding.
fn updateMapBox(box, key, value) {
    def newMap = { fetch(box)*, (key): value };
    store(box, newMap)
};


##
## Type definition: `Loader` protocol
##

## Documented in spec.
export fn .resolve(source);

## Documented in spec.
export fn .readResource(source, format);

## Documented in spec.
export fn loadModule(loader, source) {
    <> ifValue { <> resolve(loader, source) }
        { resolved <> resolved::exports }
        { die(cat("Module not found: ", sourceString(source))) }
};

## Documented in spec.
export fn loadResource(loader, source, format) {
    <> ifValueOr { <> readResource(loader, source, format) }
        { die(cat("Resource not found: ", sourceString(source))) }
};


##
## Type Definition: `null` as a `Loader`
##

## Documented in spec.
fn @@Null.readResource(source, format) {
    ## Returns void, always.
};

## Documented in spec.
fn @@Null.resolve(source) {
    <> ifIs { <> checkExternalSource(source) }
        { <> get(BOOTSTRAP_MODULES, source) }
};


##
## Type Definition: `ExternalLoader`
##
## Payload:
## * `nextLoader` -- next loader to check when trying to find a module.
## * `basePath` -- absolute path prefix for all loading, with trailing `/`.
##   Direct subdirectory names correspond to modules.
## * `globals` -- global variable environment to use when loading.
## * `loadedBox` -- map from partial paths to the results of loading.
##
## TODO: This should be an opaque type.
##

## Helper for `resolve` which does the actual resolution / loading.
fn doExternalResolve(loader, source) {
    def modulePath = cat(loader::basePath, dataOf(source));

    <> ifIs { <> eq($Io0::fileType(modulePath)?, ["directory"]) }
        {
            note(cat("    ", sourceString(source)));

            def loader =
                makeInternalLoader(modulePath, loader::globals, loader);
            def result = resolveMain(loader);

            note("        Done.");
            <> result
        }
};

## Documented in spec.
fn @@ExternalLoader.readResource(source, format) {
    ## Always just defer to the next loader.
    <> readResource(this::nextLoader, source, format)
};

## Documented in spec.
fn @@ExternalLoader.resolve(source) {
    ifNot { <> checkExternalSource(source) }
        {
            ## Not an external source, so punt to the next loader.
            return resolve(this::nextLoader, source)
        };

    def loadedBox = this::loadedBox;

    ## The loaded map maps paths to `"loading"` for a load-in-progress,
    ## `"notFound"` for a known-missing module, and to a `@module` for
    ## a successfully-loaded result.
    ifValue { <> get(fetch(loadedBox), source) }
        { found ->
            ifIs { <> hasType(found, @@module) }
                { return found };
            ifIs { <> eq(found, "notFound") }
                { return };
            ifIs { <> eq(found, "loading") }
                { die(cat("Module load loop: ", sourceString(source))) };
        };

    updateMapBox(loadedBox, source, "loading");

    def result = ifValueOr { <> doExternalResolve(this, source) }
        {
            <> ifValueOr { <> resolve(this::nextLoader, source) }
                { <> "notFound" }
        };

    updateMapBox(loadedBox, source, result);

    <> ifNot { <> eq(result, "notFound") }
        { <> result }
};

## Documented in spec.
export fn makeExternalLoader(path, globals, nextLoader) {
    checkAbsolutePath(path);

    ## Check for existence and directoriness.
    def pathType = $Io0::fileType(path)?;
    ifIs { <> eq(pathType, []) }
        {
            ## No such file or directory.
            return nextLoader
        };
    ifNot { <> eq(pathType*, "directory") }
        {
            die(cat("Module loader path exists but is not a directory: ",
                path))
        };

    <> @ExternalLoader{
        basePath: cat(path, "/"),
        globals,
        nextLoader,
        loadedBox: Box_makeCell({})
    }
};


##
## Type Definition: `InternalLoader`
##
## Payload:
## * `nextLoader` -- next loader to check when trying to find a module.
## * `basePath` -- absolute path prefix for all loading, with trailing `/`.
## * `globals` -- global variable environment to use when loading.
## * `loadedBox` -- map from partial paths to the results of loading.
##
## TODO: This should be an opaque type.
##

## Convenient helper which just resolves a top-level `main` file.
fn resolveMain(loader) {
    <> resolve(loader, @internal("main"))
};

## Helper for `resolve` which does the actual resolution / loading.
fn doInternalResolve(loader, source) {
    note(cat("        ", sourceString(source)));

    def pathPrefix = cat(loader::basePath, dataOf(source));
    def binPath = cat(pathPrefix, ".samb");

    ifIs { <> eq($Io0::fileType(binPath)?, ["file"]) }
        {
            def func = $Code::evalBinary(loader::globals, binPath);
            return func()
        };

    def sourcePath = cat(pathPrefix, ".sam");
    ifIs { <> eq($Io0::fileType(sourcePath)?, ["file"]) }
        {
            def text = $Io0::readFileUtf8(sourcePath);
            def tree = treeFromText(loader::nextLoader, text);
            def func = $Code::eval(loader::globals, tree);

            return ifValueOr { <> func() }
                { die(cat("No result from module: ", sourcePath)) }
        };

    die(cat("Missing code: ", sourcePath));
};

## `readResource` implementation for format `type`.
fn readResource_type(fullPath) {
    <> $Io0::fileType(fullPath)
};

## `readResource` implementation for format `utf8`.
fn readResource_utf8(fullPath) {
    ifNot { <> eq($Io0::fileType(fullPath)?, ["file"]) }
        { die(cat("Missing resource: ", fullPath)) };

    <> $Io0::readFileUtf8(fullPath)
};

## Map from format names to corresponding `readResource` implementations.
def INTERNAL_READERS = {
    type: readResource_type,
    utf8: readResource_utf8
};

## Documented in spec.
fn @@InternalLoader.readResource(source, format) {
    ifNot { <> checkInternalSource(source) }
        {
            ## Not an internal source, so punt to the next loader.
            return readResource(this::nextLoader, source, format)
        };

    def fullPath = cat(this::basePath, dataOf(source));

    <> ifValue { <> get(INTERNAL_READERS, format) }
        { reader <> reader(fullPath) }
        { die(cat("Unsupported resource format: ", format)) }
};

## Documented in spec.
fn @@InternalLoader.resolve(source) {
    ifNot { <> checkInternalSource(source) }
        {
            ## Not an internal source, so punt to the next loader.
            return resolve(this::nextLoader, source)
        };

    def loadedBox = this::loadedBox;

    ifValue { <> get(fetch(loadedBox), source) }
        { found -> return found };

    def result = doInternalResolve(this, source);
    updateMapBox(loadedBox, source, result);
    <> result
};

## Documented in spec.
export fn makeInternalLoader(path, globals, nextLoader) {
    checkAbsolutePath(path);
    def basePath = cat(path, "/");
    def modulesDir = cat(basePath, "modules");
    def externLoader = makeExternalLoader(modulesDir, globals, nextLoader);

    ## Forward declaration, for recursive references in the `module_*`
    ## functions immediately below.
    def loader;

    fn glo_loadModule(source)           { <> loadModule(loader, source)           };
    fn glo_loadResource(source, format) { <> loadResource(loader, source, format) };
    fn glo_thisLoader()                 { <> loader                               };

    def fullGlobals = {
        globals*,
        loadModule:   glo_loadModule,
        loadResource: glo_loadResource,
        thisLoader:   glo_thisLoader
    };

    loader := @InternalLoader{
        basePath,
        nextLoader: externLoader,
        globals:    fullGlobals,
        loadedBox:  Box_makeCell({})
    };

    <> loader
};


##
## Private Definitions: Single-file running
##

## Makes a global environment sufficient for evaluating a single file.
fn makeFileGlobals(loader) {
    fn glo_loadModule(source) { <> loadModule(loader, source) };
    fn glo_thisLoader()       { <> loader                     };

    <> {
        loadGlobals(loader)*,
        loadModule: glo_loadModule,
        thisLoader: glo_thisLoader
    }
};

## Runs a program which has been `eval`ed. This works for both text and
## binary programs. This calls the given `programFunc`. If it returns
## a module that exports `main`, then this in turn calls that `main`,
## returning whatever that does. If not, this returns whatever the original
## function call returned (including void).
fn runProgram(programFunc, args) {
    def optResult = programFunc()?;

    ifIs { <> eq(optResult, []) }
        { return };

    def result = optResult*;

    ifIs { <> hasType(result, @@module) }
        {
            ifValue { <> result::exports::main }
                { main -> return main(args*) }
        };

    return result;
};

## Helper for `runFile`, which handles program text.
fn runTextFile(path, loader, args) {
    def globals = makeFileGlobals(loader);
    def text = $Io0::readFileUtf8(path);
    def tree = treeFromText(loader, text);
    def func = $Code::eval(globals, tree);

    <> runProgram(func, args)
};

## Helper for `runFile`, which handles binaries.
fn runBinaryFile(path, loader, args) {
    def globals = makeFileGlobals(loader);
    def func = $Code::evalBinary(globals, path);

    <> runProgram(func, args)
};


##
## Exported Definitions
##

## Documented in spec.
export fn main(libraryPath, primitiveGlobals) {
    note("\nLoading core library `main`...");
    def loader = makeInternalLoader(libraryPath, primitiveGlobals, null);
    def mainModule = resolveMain(loader)::exports;
    def mainFunction = mainModule::main;
    <> mainModule::main(libraryPath, primitiveGlobals)
};

## Documented in spec.
export fn run(path, loader, args*) {
    def globals = loadGlobals(loader);
    def mainLoader = makeInternalLoader(path, globals, loader);
    def mainModule = resolveMain(mainLoader)::exports;
    def optMain = mainModule::main?;

    ifIs { <> eq(optMain, []) }
        { die("No `main` export from module's `main`.") };

    <> (optMain*)(args*)
};

## Documented in spec.
export fn runFile(path, loader, args*) {
    def suffix = fileNameSuffix(path);

    ifIs { <> eq(suffix, "sam") }
        { return runTextFile(path, loader, args) };

    ifIs { <> eq(suffix, "samb") }
        { return runBinaryFile(path, loader, args) };

    die(cat("Unknown file name suffix: ", suffix))
};
