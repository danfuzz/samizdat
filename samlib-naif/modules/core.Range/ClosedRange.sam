## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `ClosedRange` Class
##
## Payload: `{start: intOrChar, increment: int, size: int}`

#= language core.Lang0

import core.Generator :: nullGenerator, stdCollect;

import ./rangeAdd :: *;


##
## Class Definition
##

## Secret used to control access to this class.
def SECRET = @secret.makeAnonymous();

## Class being defined here.
def ClosedRange = makeObjectClass(@ClosedRange, SECRET);

## Documented in spec.
fn ClosedRange.collect(optFilterFunction?) {
    ## Just use the standard implementation.
    return stdCollect(this, optFilterFunction*)
};

## Documented in spec.
fn ClosedRange.fetch() {
    ## Just use the standard implementation.
    return Generator_stdFetch(this)
};

## Documented in spec.
fn ClosedRange.nextValue(box) {
    def data = this.objectDataOf(SECRET);

    return? ifValue { ge(data::size, 0) }
        { size ->
            def firstValue = data::firstValue;
            def increment = data::increment;
            box* := firstValue;
            makeClosedRange(
                rangeAdd(firstValue, increment),
                size.sub(1),
                increment)
        }
};


##
## Exported Definitions
##

## Documented in spec.
export fn makeClosedRange(firstValue, size, optIncrement?) {
    def increment = ifValueOr { optIncrement* } { 1 };

    ifNot { hasClass(size, Int) }
        { die("`size` must be an int.") };

    return ifIs { gt(size, 0) }
        { makeObject(ClosedRange, SECRET, @{firstValue, increment, size}) }
        { nullGenerator }
};

## Documented in spec.
export fn makeExclusiveRange(firstValue, limit, optIncrement?) {
    ## `totalEq` ensures that `firstValue` and `limit` have the same class.
    def isEmpty = firstValue.totalEq(limit)?;
    def firstInt = firstValue.toInt();
    def limitInt = limit.toInt();
    def increment = ifValueOr { optIncrement* } { 1 };

    ## `totalEq` ensures that `increment` is an int.
    ifIs { increment.totalEq(0) }
        {
            return ifIs { isEmpty* }
                { nullGenerator }
                { makeClosedRange(firstValue, 1, 0) }
        };

    ## `increment.sign()` is either `-1` or `+1`, which when subtracted from
    ## limit "pushes" the limit in the right direction to make the truncated
    ## division produce the correct result size.
    def size =
        limitInt.sub(firstInt).sub(increment.sign()).div(increment).add(1);

    ifIs { le(size, 0) }
        { return nullGenerator };

    return makeClosedRange(firstValue, size, increment);
};

## Documented in spec.
export fn makeInclusiveRange(firstValue, limit, optIncrement?) {
    def increment = ifValueOr { optIncrement* } { 1 };

    ## This just ensures that `firstValue` and `limit` have the same class.
    firstValue.totalEq(limit);

    ## `totalEq` ensures that `increment` is an int.
    ifIs { increment.totalEq(0) }
        { return makeClosedRange(firstValue, 1, 0) };

    def firstInt = firstValue.toInt();
    def limitInt = limit.toInt();
    def size = limitInt.sub(firstInt).div(increment).add(1);

    ifIs { le(size, 0) }
        { return nullGenerator };

    return makeClosedRange(firstValue, size, increment);
};
