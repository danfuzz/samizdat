## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## `ClosedRange` and `OpenRange` Types
##
## `ClosedRange` payload: `{start: intOrChar, increment: int, size: int}`
## `OpenRange` payload: `{start: intOrChar, increment: int}`

def $Generator = moduleLoad(["core", "Generator"]);
def $Number    = moduleLoad(["proto", "Number"]);


##
## Private Definitions
##

## `rangeAdd` generic, used to increment ints and chars.
def rangeAdd = makeRegularGeneric("rangeAdd", 2, 2);

fn Int_rangeAdd(value, increment) {
    <> $Number::add(value, increment)
};
genericBind(rangeAdd, Int, Int_rangeAdd);

fn String_rangeAdd(value, increment) {
    <> toString($Number::add(toInt(value), increment))
};
genericBind(rangeAdd, String, String_rangeAdd);


##
## Exported Definitions: `ClosedRange`
##

## Documented in spec.
fn makeClosedRange(firstValue, size, optIncrement?) {
    def increment = ifValueOr { <> optIncrement* } { <> 1 };

    ifNot { <> hasType(size, Int) }
        { die("`size` must be an int.") };

    <> ifIs { <> gt(size, 0) }
        {
            <> @ClosedRange{firstValue, increment, size}
        }
        { <> $Generator::nullGenerator }
};

## Documented in spec.
fn makeExclusiveRange(firstValue, limit, optIncrement?) {
    ## `totalEq` ensures that `firstValue` and `limit` have the same type.
    ## `optValue({ <> x})` == `x?`.
    def isEmpty = optValue { <> totalEq(firstValue, limit) };
    def firstInt = toInt(firstValue);
    def limitInt = toInt(limit);
    def increment = ifValueOr { <> optIncrement* } { <> 1 };

    ## `totalEq` ensures that `increment` is an int.
    ifIs { <> totalEq(increment, 0) }
        {
            return ifIs { <> isEmpty* }
                { <> $Generator::nullGenerator }
                { <> makeClosedRange(firstValue, 1, 0) }
        };

    ## `sign(increment)` is either `-1` or `+1`, which when subtracted from
    ## limit "pushes" the limit in the right direction to make the truncated
    ## division produce the correct result size.
    def size =
        $Number::add(1,
            $Number::div(
                $Number::sub(
                    $Number::sub(limitInt, firstInt),
                    $Number::sign(increment)),
                increment));

    ifIs { <> le(size, 0) }
        { return $Generator::nullGenerator };

    <> makeClosedRange(firstValue, size, increment);
};

## Documented in spec.
fn makeInclusiveRange(firstValue, limit, optIncrement?) {
    def increment = ifValueOr { <> optIncrement* } { <> 1 };

    ## This ensures that `firstValue` and `limit` have the same type.
    totalEq(firstValue, limit);

    ## `totalEq` ensures that `increment` is an int.
    ifIs { <> totalEq(increment, 0) }
        { return makeClosedRange(firstValue, 1, 0) };

    def firstInt = toInt(firstValue);
    def limitInt = toInt(limit);
    def size = $Number::add(1,
        $Number::div(
            $Number::sub(limitInt, firstInt),
            increment));

    ifIs { <> le(size, 0) }
        { return $Generator::nullGenerator };

    <> makeClosedRange(firstValue, size, increment);
};

## Documented in spec.
fn ClosedRange_nextValue(range, box) {
    <> ifValue { <> ge(range::size, 0) }
        { size ->
            def firstValue = range::firstValue;
            def increment = range::increment;
            store(box, firstValue);
            <> makeClosedRange(
                rangeAdd(firstValue, increment),
                $Number::sub(size, 1),
                increment)
        }
        {
            ## Voided.
            store(box);
        }
};
genericBind(nextValue, @@ClosedRange, ClosedRange_nextValue);

## Just use the standard implementation.
genericBind(collect, @@ClosedRange, $Generator::stdCollect);


##
## Exported Definitions: `OpenRange`
##

## Documented in spec.
fn makeOpenRange(firstValue, optIncrement?) {
    def increment = ifValueOr { <> optIncrement* } { <> 1 };

    <> @OpenRange{firstValue, increment}
};

## Just use the standard "unbounded" implementation.
genericBind(collect, @@OpenRange, $Generator::unboundedCollect);

## Documented in spec.
fn OpenRange_nextValue(range, box) {
    def firstValue = range::firstValue;
    def increment = range::increment;

    store(box, firstValue);
    <> makeOpenRange(rangeAdd(firstValue, increment), increment)
};
genericBind(nextValue, @@OpenRange, OpenRange_nextValue);


##
## Overall exports
##

<> {
    makeClosedRange,
    makeExclusiveRange,
    makeInclusiveRange,
    makeOpenRange
}
