## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Sequence functions
##

def $Number   = moduleLoad(["proto", "Number"]);
def $Sequence = moduleLoad(["proto", "Sequence"]);

## This just binds generics without adding exports.
intraLoad("SequenceGenerator");


##
## Exported Definitions
##

## Documented in spec.
export fn nthFromEnd(seq, n) {
    def index =
        $Number::sub(get_size(seq), $Number::add(n, 1));
    <> nth(seq, index)
};

## Documented in spec.
export fn sliceGeneral(seq, style, start, optEnd?) {
    def limit = $Number::sub(get_size(seq), 1);
    def func = ifIs { <> eq(style, @exclusive) }
        { <> $Sequence::sliceExclusive }
        { <> $Sequence::sliceInclusive };
    def startIndex = ifIs { <> hasType(start, @@fromStart) }
        { <> dataOf(start) }
        { <> $Number::sub(limit, dataOf(start)) };
    def optEndIndex = (ifValue { <> optEnd* }
        { end ->
            <> ifIs { <> hasType(end, @@fromStart) }
                { <> dataOf(end) }
                { <> $Number::sub(limit, dataOf(end)) }
        })?;

    <> func(seq, startIndex, optEndIndex*)
};

## Re-exported from proto.
export def nth            = $Sequence::nth;
export def reverse        = $Sequence::reverse;
export def sliceExclusive = $Sequence::sliceExclusive;
export def sliceInclusive = $Sequence::sliceInclusive;
