## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Command line interpreter
##

def $FilePath     = moduleLoad(["core", "FilePath"]);
def $Format       = moduleLoad(["core", "Format"]);     ## Implicitly used.
def $Generator    = moduleLoad(["core", "Generator"]);  ## Implicitly used.
def $Globals      = moduleLoad(["core", "Globals"]);
def $Io0          = moduleLoad(["core", "Io0"]);
def $Lang2        = moduleLoad(["core", "Lang2"]);
def $ModuleSystem = moduleLoad(["core", "ModuleSystem"]);
def $Number       = moduleLoad(["proto", "Number"]);    ## Implicitly used.
def $Peg          = moduleLoad(["core", "Peg"]);        ## Implicitly used.
def $Range        = moduleLoad(["core", "Range"]);      ## Implicitly used.
def $Sequence     = moduleLoad(["core", "Sequence"]);   ## Implicitly used.


##
## Private Definitions
##

## Parses a single `\0`-terminated word. Yields a simple string.
def parWord = {:
    chars = [! "\0"]*
    "\0"
    { <> $Peg::stringFromTokenList(chars) }
:};

## Parses a key prefix of a word, not including the ending `=`.
def parKey = {:
    chars = [! "=\0"]+
    { <> $Peg::stringFromTokenList(chars) }
:};

## Parses a key-value option word. Yields a single-mapping map of
## `{(key): value}`.
def parKeyValue = {:
    "--"
    key = parKey
    "="
    value = parWord
    { <> {(key): value} }
:};

## Parses a non-value flag option word. Yields a single-mapping map of
## `{(flag): true}`.
def parFlag = {:
    "--"
    flag = parWord

    ## The `!=` rejects plain `--`.
    { <> (flag != "") & {(flag): true} }
:};

## Parses a syntactically invalid option. This includes words that start with
## just a single dash and are not *just* `-` (which is a valid non-option
## argument); as well as options with empty keys (`--=...`).
def parError = {:
    ch1 = "-"
    ch2 = [! "-\0"]
    word = parWord
    {
        def value = "\[stringFromTokens(ch1, ch2), word]";
        note("Unknown option: \%q(value)");
        <> {error: true}
    }
:};

## Parses and yields an arbitrary option (including errors).
def parOption = {:
    parKeyValue | parFlag | parError
:};

## Parses the entire list of argument words. Yields a map of
## `{options: {k: v, ...}, args: [arg, ...]}`.
def parArguments = {:
    optionList = parOption*
    "--\0"?
    args = parWord*
    {
        def options = {}.cat(optionList*);
        if (options::error) {
            die("Invalid option(s).")
        };
        <> {options, args}
    }
:};

## Gets the language layer suffix (or suffix-like-thing) from a file path.
fn suffixFromPath(filePath) {
    def finalName = $FilePath::get_file(filePath);
    if (finalName == ".") {
        ## Explicit "this directory" as the final path component; assume it
        ## indicates a module directory.
        return "module"
    };

    def dotsAt = [index in (0..), elem in finalName <> (elem == ".") & index];
    if (dotsAt == []) {
        ## No suffix on the name; assume it names a module directory.
        return "module"
    };

    <> finalName[dotsAt[^0] + 1..]
};

## Makes a global environment, given file path and command-line arguments.
fn makeGlobals(filePath, args) {
    <> {
        ## The standard global environment.
        $Globals::fullEnvironment()*,

        ## Use the system module loader.
        moduleLoad
    }
};

## Runs a program which has been `eval`ed. This works for both text and
## binary programs. This calls the given `programFunc`. If it returns
## a map that binds `main`, then this in turn calls that `main`, returning
## whatever that does. If not, this returns whatever the original function
## call returned (including void).
fn runProgram(programFunc, filePath, args) {
    def optResult = programFunc()?;

    if (optResult == []) {
        return
    };

    def result = optResult*;

    if (hasType(result, Map) & result::main) {
        return result::main(filePath, args*)
    } else {
        return result
    }
};

## Runs a module-form command-line. In this case, a named directory is
## loaded as a module. It is expected to export a `main()` function, which
## is called with the Posix-style command-line arguments.
fn runModule(modulePath, args) {
    <> $ModuleSystem::run(
        modulePath, $Globals::fullEnvironment(), moduleLoader(),
        modulePath, args*)
};

## Runs a simple-file-form command-line. The indicated file is read as a
## top-level program, and evaluated. The (function) result of evaluation is
## called with no arguments. The result of that call (including void) is
## returned, *except* if the result is a map that binds `main`. In the latter
## case, the `main` is called, passing it the usual `main()` arguments.
fn runFile(langLayer, filePath, args) {
    def globals = makeGlobals(filePath, args);
    def programText = $Io0::readFileUtf8(filePath);
    def langModule = moduleLoad(["core", cat("Lang", langLayer)]);
    def parsedProgram = langModule::parseProgram(programText);
    def evalled = langModule::eval(globals, parsedProgram);

    <> runProgram(evalled, filePath, args)
};

## Runs a binary library command-line. The global environment is set up the
## same as for `runFile`, and it is called in the same manner.
fn runBinary(filePath, args) {
    def globals = makeGlobals(filePath, args);
    def evalled = $Lang2::evalBinary(globals, filePath);

    <> runProgram(evalled, filePath, args)
};


##
## Exported Definitions
##

## Documented in spec.
export fn parseArgs(args) {
    ## Make a unified string with each argument "\0"-terminated.
    def argString = "\[ arg in args <> [arg, "\0"] ]";

    ## Use the peg grammar above to split the arguments back apart.
    <> $Peg::apply(parArguments, argString)
};

## Documented in spec.
export fn runCommandLine(rawArgs*) {
    def parsedArgs = parseArgs(rawArgs);
    def options = parsedArgs::options;
    def argWords = parsedArgs::args;

    def filePath = (def p = argWords[0])
        & $FilePath::fixPath(p, $Io0::cwd())
        | "/dev/stdin";
    def args = argWords[1..] | [];

    def suffix = options::suffix | suffixFromPath(filePath);

    if (suffix == "module") {
        return runModule(filePath, args)
    } else if (suffix == "samb") {
        return runBinary(filePath, args)
    };

    def langLayer = (suffix == "sam") & "2" | suffix[^0];

    <> runFile(langLayer, filePath, args)
};
