## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Simple I/O functions
##

def Collection = moduleLoad(["core", "Collection"]);
def Number     = moduleLoad(["proto", "Number"]);
def Sequence   = moduleLoad(["core", "Sequence"]);


##
## Private Definitions
##

## Does a type / content check on `path`.
fn checkPath(path) {
    ifNot { <> hasType(path, String) }
        { die("Invalid non-string path.") };
    ifIs { <> eq(path, "") }
        { die("Invalid empty path.") };
};


##
## Exported Definitions
##

## Documented in spec.
def flatCwd = Io0_cwd;

## Documented in spec.
fn absolutePath(path, optBase?) {
    checkPath(path);

    <> ifIs { <> eq(get(path, 0), "/") }
        { <> path }
        {
            def base = ifValue { <> optBase* }
                { b <> absolutePath(b) }
                { <> flatCwd() };
            <> cat(base, "/", path)
        }
};

## Documented in spec.
fn directoryOf(path) {
    checkPath(path);

    var at = Collection::sizeOf(path);

    ## Back up over any path-final slashes. If we hit the start of the path,
    ## then that means the path was all slashes, making the result be `"/"`.
    { <out> ->
        loop {
            at := Number::sub(at, 1);

            def ch = get(path, at);
            ifIs { <> ne(ch, "/") } { <out> };
            ifIs { <> eq(at, 0) } { return "/" };
        }
    }();

    ## Back up until the next-final slash. If we hit the start of the path,
    ## then that means there was no slash, making the result be `"."`. If
    ## the next-final slash is at the start of the path, then the result is
    ## `"/"`.
    loop {
        ifIs { <> eq(at, 0) } { return "." };
        at := Number::sub(at, 1);

        def ch = get(path, at);
        ifIs { <> eq(ch, "/") }
            {
                ifIs { <> eq(at, 0) } { return "/" };
                return Sequence::sliceExclusive(path, 0, at)
            };
    }
};

## Documented in spec.
fn fileOf(path) {
    checkPath(path);

    var at = Collection::sizeOf(path);

    ## Back up over any path-final slashes. If we hit the start of the path,
    ## then that means the path was all slashes, making the result be `"/"`.
    { <out> ->
        loop {
            at := Number::sub(at, 1);

            def ch = get(path, at);
            ifIs { <> ne(ch, "/") } { <out> };
            ifIs { <> eq(at, 0) } { return "/" };
        }
    }();

    def endAt = at; ## The index of the final character of the result.

    ## Back up until the next-final slash. If we hit the start of the path,
    ## then that means there was no slash, making the result be the entire
    ## `path` minus any path-final slashes.
    loop {
        ifIs { <> eq(at, 0) }
            { return Sequence::sliceInclusive(path, 0, endAt) };

        at := Number::sub(at, 1);

        def ch = get(path, at);
        ifIs { <> eq(ch, "/") }
            {
                at := Number::add(at, 1);
                return Sequence::sliceInclusive(path, at, endAt)
            };
    }
};

<> {
    ## Re-exported from primitives.
    flatCwd:           Io0_cwd,
    flatReadLink:      Io0_readLink,
    flatFileExists:    Io0_fileExists,
    flatReadFileUtf8:  Io0_readFileUtf8,
    flatWriteFileUtf8: Io0_writeFileUtf8,

    ## Defined in this file.
    absolutePath,
    directoryOf,
    fileOf
}
