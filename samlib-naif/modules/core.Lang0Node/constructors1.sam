## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Collection;
import core.Generator;


##
## Exported Definitions
##

## Documented in spec.
export fn makeApply(function, actuals) {
    <> @apply{function, actuals}
};

## Documented in spec.
export fn makeCall(function, actuals*) {
    <> @call{function, actuals}
};

## Documented in spec.
export fn makeCallLiterals(function, actuals*) {
    def literals = $Generator::filterAll(actuals) { one <> makeLiteral(one) };
    <> makeCall(function, literals*)
};

## Documented in spec.
export fn makeCallThunks(function, actuals*) {
    def thunks = $Generator::filterAll(actuals) { one <> makeThunk(one) };
    <> makeCall(function, thunks*)
};

## Documented in spec.
export fn makeExport(node) {
    <> @export{value: node}
};

## Documented in spec.
export fn makeExportSelection(names+) {
    <> @exportSelection{select: names}
};

## Documented in spec.
export fn makeJump(function, optValue?) {
    def value = ifValue { <> optValue* }
        { v <> makeMaybe(v) }
        { <> @void };

    <> @jump{function, value}
};

## Documented in spec.
export fn makeLiteral(value) {
    <> @literal{value}
};

## Documented in spec.
export fn makeMaybe(value) {
    <> @maybe{value}
};

## Documented in spec.
export fn makeNoYield(value) {
    <> @noYield{value}
};

## Documented in spec.
export fn makeThunk(expression) {
    <> @closure{formals: [], statements: [], yield: makeMaybe(expression)}
};

## Documented in spec.
export fn makeVarBind(name, value) {
    <> @varBind{name, value}
};

## Documented in spec.
export fn makeVarDef(name, optValue?) {
    <> ifValue { <> optValue* }
        { value <> @varDef{name, value} }
        { <> @varDef{name} }
};

## Documented in spec.
export fn makeVarDefMutable(name, optValue?) {
    <> ifValue { <> optValue* }
        { value <> @varDefMutable{name, value} }
        { <> @varDefMutable{name} }
};

## Documented in spec.
export fn makeVarRef(name) {
    <> @varRef{name}
};

## Documented in spec.
export fn makeVarRefLvalue(name) {
    <> @varRef{
        name,
        lvalue: { node <> makeVarBind(name, node) }
    }
};

## Documented in spec.
export fn withFormals(node, formals) {
    <> @(get_type(node)){dataOf(node)*, formals}
};

## Documented in spec.
export fn withoutInterpolate(node) {
    <> @(get_type(node))($Collection::del(dataOf(node), "interpolate"))
};

## Documented in spec.
export fn withoutIntermediates(node) {
    def data = $Collection::del(
        $Collection::del(dataOf(node), "lvalue"),
        "interpolate");

    <> @(get_type(node))(data)
};
