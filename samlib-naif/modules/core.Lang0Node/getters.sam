## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Generator;
import core.Sequence;
import proto.Number;

import ./misc ::
    formalsMaxArgs,
    formalsMinArgs;


##
## Private Definitions
##

## Splits a string into a list of strings, dividing on the given character.
fn splitAtChar(s, ch) {
    var result = [];
    var current = "";

    fn addCurrentToResult() {
        result := [result*, current];
        current := ""
    };

    ## This uses `collect` just for the filter function, ignoring the
    ## collected result.
    collect(s, { one ->
        ifIs { <> eq(one, ch) }
            { addCurrentToResult() }
            { current := cat(current, one) }
    });

    addCurrentToResult();
    <> result
};


##
## Exported Definitions
##

## Documented in spec.
export fn get_actuals(node) {
    <> node::actuals
};

## Documented in spec.
export fn .get_baseName();

## Documented in spec.
fn @@external.get_baseName() {
    def components = splitAtChar(dataOf(this), ".");
    <> $Sequence::nthFromEnd(components, 0)
};

## Documented in spec.
fn @@internal.get_baseName() {
    def components = splitAtChar(dataOf(this), "/");
    def last = $Sequence::nthFromEnd(components, 0);
    def parts = splitAtChar(last, ".");

    <> get(parts, 0)
};

## Documented in spec.
export fn .get_definedNames();

## Documented in spec.
fn @@export.get_definedNames() {
    <> get_definedNames(get_nodeValue(this))
};

## Documented in spec.
fn @@importModule.get_definedNames() {
    <> [get_name(this)]
};

## Documented in spec.
fn @@importModuleSelection.get_definedNames() {
    def prefix = get_prefix(this);
    def select = ifValueOr { <> get_select(this) }
        { die("Cannot call `get_definedNames` on unresolved import.") };

    <> $Generator::filterAll(select) { name <> cat(prefix, name) }
};

## Documented in spec.
fn @@importResource.get_definedNames() {
    <> [get_name(this)]
};

## Documented in spec.
fn @@varDef.get_definedNames() {
    <> [get_name(this)]
};

## Documented in spec.
fn @@varDefMutable.get_definedNames() {
    <> [get_name(this)]
};

## Documented in spec.
fn Value.get_definedNames() {
    <> []
};

## Documented in spec.
export fn get_formals(node) {
    <> node::formals
};

## Documented in spec.
export fn get_format(node) {
    <> node::format
};

## Documented in spec.
export fn get_function(node) {
    <> node::function
};

## Documented in spec.
export fn get_id(node) {
    <> node::id
};

## Documented in spec.
export fn get_info(node) {
    <> node::info
};

## Documented in spec.
export fn get_interpolate(node) {
    <> node::interpolate
};

## Documented in spec.
export fn get_lvalue(node) {
    <> node::lvalue
};

## Documented in spec.
export fn get_maxArgs(node) {
    <> formalsMaxArgs(get_formals(node))
};

## Documented in spec.
export fn get_minArgs(node) {
    <> formalsMinArgs(get_formals(node))
};

## Documented in spec.
export fn get_name(node) {
    <> node::name
};

## Documented in spec.
export fn get_nodeValue(node) {
    <> node::value
};

## Documented in spec.
export fn get_prefix(node) {
    <> node::prefix
};

## Documented in spec.
export fn get_select(node) {
    <> node::select
};

## Documented in spec.
export fn get_source(node) {
    <> node::source
};

## Documented in spec.
export fn get_statements(node) {
    <> node::statements
};

## Documented in spec.
export fn get_yieldNode(node) {
    <> node::yield
};

## Documented in spec.
export fn get_yieldDef(node) {
    <> node::yieldDef
};
