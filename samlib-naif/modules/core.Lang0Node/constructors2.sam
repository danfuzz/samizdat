## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Generator;

import ./constructors1 ::
    makeApply,
    makeCall,
    makeLiteral,
    makeThunk,
    makeVarBind,
    makeVarDef,
    makeVarRef;

import ./getters ::
    get_baseName,
    get_name,
    get_interpolate,
    get_format,
    get_nodeValue,
    get_prefix,
    get_select,
    get_source,
    get_statements,
    get_yield;

import ./refs :: REFS;


##
## Exported definitions
##

## Documented in spec.
export fn makeCallOrApply(function, actuals*) {
    ifIs { <> perEq(actuals, []) }
        {
            ## No actuals. Easy out.
            return makeCall(function)
        };

    ## Convert the actuals as if interpolation needs to be handled. If in the
    ## end it doesn't, then the original actuals are used as-is. This converts
    ## runs of non-interpolated actuals to `makeList(ac, ac, ...)`, which
    ## converts cleanly at runtime as part of the ultimate call to `cat`.

    var pending = [];       ## Non-interpolated actuals, to be `makeList`ed.
    var cookedActuals = []; ## Fully-processed actuals (of either type).

    fn addToCooked(actual) {
        cookedActuals := [cookedActuals*, actual];
    };

    fn addPendingToCooked() {
        ifIs { <> perNe(pending, []) }
            {
                addToCooked(makeCall(REFS::makeList, pending*));
                pending := [];
            }
    };

    $Generator::filterPump(actuals) { actual ->
        ifValue { <> get_interpolate(actual) }
            { node ->
                addPendingToCooked();
                addToCooked(makeCall(REFS::collect, node))
            }
            { pending := [pending*, actual] }
    };

    ifIs { <> perEq(cookedActuals, []) }
        {
            ## There were no interpolated arguments.
            return makeCall(function, actuals*)
        };

    ## There is at least one interpolated argument.

    addPendingToCooked();

    <> ifIs { <> nth(cookedActuals, 1) }
        {
            ## More than one actual. Use `cat`.
            <> makeApply(function,
                makeCall(REFS::cat, cookedActuals*))
        }
        {
            ## Only one. Use it directly as the actuals for the `apply` node.
            <> makeApply(function, cookedActuals*)
        }
};

## Documented in spec.
export fn .makeDynamicImport();

## Documented in spec.
fn @@importModule.makeDynamicImport() {
    ## The translation is approximately `def name = load(source)`, with `load`
    ## replaced by either `moduleLoad` or `intraLoad`.

    def name = get_name(this);
    def source = get_source(this);
    def loadRef = ifIs { <> hasType(source, @@external) }
        { <> REFS::moduleLoad }
        { <> REFS::intraLoad };

    <> [makeVarDef(name, makeCall(loadRef, makeLiteral(dataOf(source))))]
};

## Documented in spec.
fn @@importModuleSelection.makeDynamicImport() {
    ## The translation is along the same lines as for `importModule`
    ## translations, except as a list of statements, one per binding being
    ## imported, each one wrapped in a `get` call, e.g. `def name =
    ## get(load(source), "name")`.

    def prefix = get_prefix(this);
    def source = get_source(this);

    def select = ifValueOr
        { <> get_select(this) }
        {
            ## TODO: In order to handle wildcard imports, this function will
            ## have to be able to ask for the list of exports from arbitrary
            ## modules. This will probably mean adding an argument to the
            ## generic function for a "module oracle" of some sort.
            die("TODO: wildcard selection import")
        };

    def loadRef = ifIs { <> hasType(source, @@external) }
        { <> REFS::moduleLoad }
        { <> REFS::intraLoad };
    def loadCall = makeCall(loadRef, makeLiteral(dataOf(source)));

    <> $Generator::filterAll(select) { name ->
        <> makeVarDef(cat(prefix, name),
            makeCall(REFS::get, loadCall, makeLiteral(name)))
    };
};

## Documented in spec.
fn @@importResource.makeDynamicImport() {
    ## The translation is approximately `def name = intraRead(source, format)`.

    def name = get_name(this);
    def format = get_format(this);
    def source = get_source(this);

    ifIs { <> hasType(source, @@external) }
        { die("Cannot import external resource.") };

    <> [
        makeVarDef(name,
            makeCall(REFS::intraRead,
                makeLiteral(dataOf(source)),
                makeLiteral(format)))
    ]
};

## Documented in spec.
export fn makeGet(collArg, keyArg) {
    <> makeCall(REFS::get, collArg, keyArg)
};

## Documented in spec.
export fn makeImport(baseData) {
    var data = baseData;  ## Modified in some cases below.

    ifValue { <> data::select }
        { select ->
            ## It's a module binding selection.

            ifIs { <> data::name }
                { die("Import selection name must be a prefix.") };
            ifIs { <> data::format }
                { die("Cannot import selection of resource.") };

            ifNot { <> data::prefix }
            {
                ## Default to empty string for `prefix`.
                data := {data*, prefix: ""}
            };

            ifIs { <> hasType(select, @@"*") }
                {
                    ## It's a wildcard import.
                    data := $Collection::del(data, "select");
                };

            return @importModuleSelection(data)
        };

    ifNot { <> data::name }
        {
            ## No `name` provided, so figure out a default one.
            data := {data*, name: cat("$", get_baseName(data::source))}
        };

    ifIs { <> data::format }
        {
            ## It's a resource.
            ifIs { <> hasType(data::source, @@external) }
                { die("Cannot import external resource.") };
            return @importResource(data)
        };

    ## It's a whole-module import.
    <> @importModule(data)
};

## Documented in spec.
export fn makeInterpolate(node) {
    <> @call{function: REFS::interpolate, actuals: [node], interpolate: node}
};

## Documented in spec.
export fn makeOptValue(node) {
    <> makeCall(REFS::optValue, makeThunk(node))
};

## Documented in spec.
export fn withDynamicImports(node) {
    def rawStatements = get_statements(node);

    ifIs { <> eq(rawStatements, []) }
        {
            ## Nothing to convert. Easy out!
            return node
        };

    def converted = $Generator::filterAll(rawStatements) { <out> s ->
        ifIs { <> hasType(s, @@importModule) }
            { <out> makeDynamicImport(s) };
        ifIs { <> hasType(s, @@importModuleSelection) }
            { <out> makeDynamicImport(s) };
        ifIs { <> hasType(s, @@importResource) }
            { <out> makeDynamicImport(s) };
        <> [s]
    };

    def statements = cat(converted*);
    <> @(get_typeName(node)){dataOf(node)*, statements}
};

## Documented in spec.
export fn withExport(node, optExport?) {
    def exp = ifValueOr { <> optExport* } { <> get_name(node) };
    <> @(get_typeName(node)){dataOf(node)*, export: exp}
};

## Documented in spec.
export fn withSimpleDefs(node) {
    def rawStatements = get_statements(node);

    def tops = $Generator::filterAll(rawStatements) { s ->
        def defNode = ifIs { hasType(s, @@export) }
            { <> get_nodeValue(s) }
            { <> s };

        <> ifIs { <> defNode::top }
            { <> makeVarDef(get_name(defNode)) }
    };

    def mains = $Generator::filterAll(rawStatements) { <out> s ->
        def defNode = ifIs { hasType(s, @@export) }
            { <> get_nodeValue(s) }
            { <> s };

        ifIs { <> defNode::top }
            { <out> makeVarBind(get_name(defNode), get_nodeValue(defNode)) };

        ifIs { <> hasType(s, @@export) }
            { <out> get_nodeValue(s) };

        ifIs { <> hasType(s, @@exportSelection) }
            { <out> };

        <> s
    };

    def exports = $Generator::filterAll(rawStatements) { <out> s ->
        ifIs { <> hasType(s, @@exportSelection) }
            {
                <out> $Generator::filterAll(get_select(s)) { name ->
                    <> makeCall(REFS::makeValueMap,
                        makeLiteral(name), makeVarRef(name))
                }
            };

        ifIs { <> hasType(s, @@export) }
            {
                def inner = get_nodeValue(s);
                ifValue { <> get_name(inner) }
                    { name ->
                        <out> [makeCall(REFS::makeValueMap,
                            makeLiteral(name), makeVarRef(name))]
                    };
                die("TODO: export import ... :: ...")
            };

        ifIs { <> hasType(s, @@varDef) }
            {
                ifValue { <> s::export } { exp ->
                    <out> [makeCall(REFS::makeValueMap,
                        makeLiteral(exp), makeVarRef(s::name))]
                }
            };
    };

    def optYield = ifIs { <> eq(exports, []) }
        { <> {} }
        {
            ## Turn the `exports` into a yield, but also reject a node with
            ## a pre-existing `yield` binding.
            ifIs { get_yield(node) }
                { die("Cannot mix `export` and `yield`.") };
            <> {yield: makeCall(REFS::cat, cat(exports*)*)}
        };

    <> @(get_typeName(node)){
        dataOf(node)*,
        optYield*,
        statements: [tops*, mains*]
    }
};

## Documented in spec.
export fn withTop(node) {
    <> @(get_typeName(node)){dataOf(node)*, top: true}
};
