## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

def $Generator = moduleLoad(["core", "Generator"]);

def $constructors1 = intraLoad("constructors1");
def makeApply   = $constructors1::makeApply;
def makeCall    = $constructors1::makeCall;
def makeLiteral = $constructors1::makeLiteral;
def makeThunk   = $constructors1::makeThunk;
def makeVarBind = $constructors1::makeVarBind;
def makeVarDef  = $constructors1::makeVarDef;
def makeVarRef  = $constructors1::makeVarRef;

def $getters = intraLoad("getters");
def get_interpolate = $getters::get_interpolate;
def get_name        = $getters::get_name;
def get_nodeValue   = $getters::get_nodeValue;
def get_statements  = $getters::get_statements;
def get_yield       = $getters::get_yield;

def REFS = intraLoad("refs")::REFS;


##
## Exported definitions
##

## Documented in spec.
export fn makeCallOrApply(function, actuals*) {
    ifIs { <> perEq(actuals, []) }
        {
            ## No actuals. Easy out.
            return makeCall(function)
        };

    ## Convert the actuals as if interpolation needs to be handled. If in the
    ## end it doesn't, then the original actuals are used as-is. This converts
    ## runs of non-interpolated actuals to `makeList(ac, ac, ...)`, which
    ## converts cleanly at runtime as part of the ultimate call to `cat`.

    var pending = [];       ## Non-interpolated actuals, to be `makeList`ed.
    var cookedActuals = []; ## Fully-processed actuals (of either type).

    fn addToCooked(actual) {
        cookedActuals := [cookedActuals*, actual];
    };

    fn addPendingToCooked() {
        ifIs { <> perNe(pending, []) }
            {
                addToCooked(makeCall(REFS::makeList, pending*));
                pending := [];
            }
    };

    $Generator::filterPump(actuals) { actual ->
        ifValue { <> get_interpolate(actual) }
            { node ->
                addPendingToCooked();
                addToCooked(makeCall(REFS::collect, node))
            }
            { pending := [pending*, actual] }
    };

    ifIs { <> perEq(cookedActuals, []) }
        {
            ## There were no interpolated arguments.
            return makeCall(function, actuals*)
        };

    ## There is at least one interpolated argument.

    addPendingToCooked();

    <> ifIs { <> nth(cookedActuals, 1) }
        {
            ## More than one actual. Use `cat`.
            <> makeApply(function,
                makeCall(REFS::cat, cookedActuals*))
        }
        {
            ## Only one. Use it directly as the actuals for the `apply` node.
            <> makeApply(function, cookedActuals*)
        }
};

## Documented in spec.
export fn makeGet(collArg, keyArg) {
    <> makeCall(REFS::get, collArg, keyArg)
};

## Documented in spec.
export fn makeInterpolate(node) {
    <> @call{function: REFS::interpolate, actuals: [node], interpolate: node}
};

## Documented in spec.
export fn makeOptValue(node) {
    <> makeCall(REFS::optValue, makeThunk(node))
};

## Documented in spec.
export fn withExport(node, optExport?) {
    def exp = ifValueOr { <> optExport* } { <> get_name(node) };
    <> @(get_typeName(node)){dataOf(node)*, export: exp}
};

## Documented in spec.
export fn withSimpleDefs(node) {
    def rawStatements = get_statements(node);

    def tops = $Generator::filterAll(rawStatements) { s ->
        <> ifIs { <> hasType(s, @@varDef) }
            {
                <> ifIs { <> s::top }
                    { <> makeVarDef(get_name(s)) }
            }
    };

    def mains = $Generator::filterAll(rawStatements) { <out> s ->
        ifIs { <> hasType(s, @@varDef) }
            {
                ifIs { <> s::top }
                    { <out> makeVarBind(get_name(s), get_nodeValue(s)) }
            };
        <> ifNot { <> hasType(s, @@export) }
            { <> s }
    };

    def exports = $Generator::filterAll(rawStatements) { <out> s ->
        ifNot { <> hasType(s, @@varDef) }
            {
                ifNot { <> hasType(s, @@export) }
                    { <out> }
            };

            <> ifValue { <> s::export }
                { exp ->
                    <> makeCall(REFS::makeValueMap,
                        makeLiteral(exp), makeVarRef(s::name))
                }
    };

    def optYield = ifIs { <> eq(exports, []) }
        { <> {} }
        {
            ## Turn the `exports` into a yield, but also reject a node with
            ## a pre-existing `yield` binding.
            ifIs { get_yield(node) }
                { die("Cannot mix `export` and `yield`.") };
            <> {yield: makeCall(REFS::cat, exports*)}
        };

    <> @(get_typeName(node)){
        dataOf(node)*,
        optYield*,
        statements: [tops*, mains*]
    }
};

## Documented in spec.
export fn withTop(node) {
    <> @(get_typeName(node)){dataOf(node)*, top: true}
};
