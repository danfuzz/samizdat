## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang1

import core.Format;
import core.Generator;
import core.LangNode :: *;
import core.Sequence;
import proto.Number;


##
## Private Definitions
##

## Int value of Unicode code point `0`.
def CHAR_0 = toInt("0");

## Parses and returns a base-10 unsigned int, or returns void if the string
## doesn't represent such a number.
fn intOrVoid(string) {
    var value = 0;

    $Generator::filterPump(string) { ch ->
        ifIs { perLt(ch, "0") } { return };
        ifIs { perGt(ch, "9") } { return };
        def digit = $Number::sub(toInt(ch), CHAR_0);
        value := $Number::add($Number::mul(value, 10), digit);
    };

    return value
};

## Returns the maximum of the given values. Returns `-1` if given no values,
## and never returns a value less than `-1`.
fn maxOf(values*) {
    var max = -1;

    $Generator::filterPump(values) { v ->
        ifIs { perGt(v, max) }
            { max := v }
    };

    return max
};

## Returns a safe index for the given `base` that is safe with respect
## to all the other given `names`.
fn safeIndexForNames(base, names*) {
    def baseSz = get_size(base);

    def indexes = $Generator::filterAll(names) { name /next ->
        ifIs { perLt(get_size(name), baseSz) }
            {
                ## Can't possibly be a prefix, so no conflict.
                yield /next
            };
        ifIs { perEq(base, name) } { yield /next -1 };
        ifIs { perEq(base, $Sequence::sliceExclusive(name, 0, baseSz)) }
            { yield? /next intOrVoid($Sequence::sliceInclusive(name, baseSz)) }
    };

    return ifIs { perEq(indexes, []) }
        { -1 }
        { $Number::add(maxOf(indexes*), 1) }
};

## Maps / reduces `safeIndex` over the given nodes.
fn safeIndexForNodes(base, nodes*) {
    def indexes = $Generator::filterAll(nodes)
        { node -> safeIndex(node, base) };
    return maxOf(indexes*)
};

## Returns a safe (unused) index for the given `base` variable name, with
## regard to the contents of `node`.
fn safeIndex(node, base) {
    return ifSwitch(
        { get_class(node) },
        {
            @@apply: { . ->
                safeIndexForNodes(base,
                    get_function(node),
                    get_values(node));
            },

            @@call: { . ->
                safeIndexForNodes(base,
                    get_function(node),
                    get_values(node)*);
            },

            @@closure: { . ->
                def namesIndex = safeIndexForNames(base,
                    get_name(node)?*,
                    get_yieldDef(node)?*);
                def nodesIndex = safeIndexForNodes(base,
                    get_statements(node)*,
                    get_yieldNode(node));

                maxOf(namesIndex, nodesIndex)
            },

            @@exportSelection: { . ->
                safeIndexForNames(base, get_select(node)*)
            },

            @@fetch: { . ->
                safeIndexForNodes(base, get_target(node))
            },

            @@importModuleSelection: { . ->
                ## I don't think this can come up in practice (nor the other
                ## `import*` variants, really). So, just fail hard. Note: The
                ## only situation this can't actually be made to work is on
                ## wildcard imports (since when this is called, we don't
                ## necessarily know the full set of exports from a module).
                die("Cannot perform `safeIndex` on `importModuleSelection` node.")
            },

            @@store: { . ->
                safeIndexForNodes(base, get_target(node), get_nodeValue(node))
            },

            @@literal:
            @@void: { . ->
                -1
            },

            @@varDef:
            @@varDefMutable: { . ->
                def nameIndex =
                    safeIndexForNames(base, get_name(node));
                def valueIndex =
                    safeIndexForNodes(base, get_nodeValue(node)?*);
                maxOf(nameIndex, valueIndex)
            },

            @@export:
            @@maybe:
            @@noYield: { . ->
                safeIndexForNodes(base, get_nodeValue(node))
            },

            @@importModule:
            @@importResource:
            @@varRef: { . ->
                safeIndexForNames(base, get_name(node));
            }
        })
};


##
## Exported Definitions
##

## Makes a variable name by combining `base` with `index`. Handles the case
## where `index` is `-1` consistently with the other functions exported here.
export fn makeVarName(base, index) {
    return ifIs { eq(index, -1) }
        { base }
        { cat(base, $Format::int(index)) }
};

## Returns an unused variable name within `node`, either the given `base` or
## `base` suffixed with an unsigned int.
export fn safeVarName(base, node) {
    return makeVarName(base, safeIndex(node, base))
};

## Returns a safe index to be used within `node` to suffix the given `base`
## variable name. Returns `-1` if `base` itself is unused. Any index at or
## after the return value is safe to use.
export fn safeVarIndex(base, node) {
    ## NB: This call has the opposite argument order to the exported function.
    return safeIndex(node, base)
};
