## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang1

def $Format     = moduleLoad(["core", "Format"]);
def $Generator  = moduleLoad(["core", "Generator"]);
def $Lang0Node  = moduleLoad(["core", "Lang0Node"]);
def $Number     = moduleLoad(["proto", "Number"]);
def $Sequence   = moduleLoad(["core", "Sequence"]);

## Int value of Unicode code point `0`.
def CHAR_0 = toInt("0");

## Parses and returns a base-10 unsigned int, or returns void if the string
## doesn't represent such a number.
fn intOrVoid(string) {
    var value = 0;

    $Generator::filterPump(string) { ch ->
        ifIs { <> perLt(ch, "0") } { return };
        ifIs { <> perGt(ch, "9") } { return };
        def digit = $Number::sub(toInt(ch), CHAR_0);
        value := $Number::add($Number::mul(value, 10), digit);
    };

    <> value
};

## Returns the maximum of the given values. Returns `-1` if given no values,
## and never returns a value less than `-1`.
fn maxOf(values*) {
    var max = -1;

    $Generator::filterPump(values) { v ->
        ifIs { <> perGt(v, max) }
            { max := v }
    };

    <> max
};

## Returns a safe index for the given `base` that is safe with respect
## to all the other given `names`.
fn safeIndexForNames(base, names*) {
    def baseSz = get_size(base);

    def indexes = $Generator::filterAll(names) { <next> name ->
        ifIs { <> perLt(get_size(name), baseSz) }
            {
                ## Can't possibly be a prefix, so no conflict.
                <next>
            };
        ifIs { <> perEq(base, name) } { <next> -1 };
        ifIs { <> perEq(base, $Sequence::sliceExclusive(name, 0, baseSz)) }
            { <next> intOrVoid($Sequence::sliceInclusive(name, baseSz)) };
    };

    <> ifIs { <> perEq(indexes, []) }
        { <> -1 }
        { <> $Number::add(maxOf(indexes*), 1) }
};

## Generic `node.safeIndex(base)`, returns a safe (unused) index for the
## given `base` variable name, with regard to the contents of `node`.
fn .safeIndex(base);

## Maps / reduces `safeIndex` over the given nodes.
fn safeIndexForNodes(base, nodes*) {
    def indexes = $Generator::filterAll(nodes)
        { node <> safeIndex(node, base) };
    <> maxOf(indexes*)
};

fn @@apply.safeIndex(base) {
    <> safeIndexForNodes(base,
        $Lang0Node::get_function(this),
        $Lang0Node::get_actuals(this));
};

fn @@call.safeIndex(base) {
    <> safeIndexForNodes(base,
        $Lang0Node::get_function(this),
        $Lang0Node::get_actuals(this)*);
};

fn @@closure.safeIndex(base) {
    def namesIndex = safeIndexForNames(base,
        $Lang0Node::get_name(this)?*,
        $Lang0Node::get_yieldDef(this)?*);
    def nodesIndex = safeIndexForNodes(base,
        $Lang0Node::get_statements(this)*,
        $Lang0Node::get_yield(this)?*);

    <> maxOf(namesIndex, nodesIndex)
};

fn @@jump.safeIndex(base) {
    <> safeIndexForNodes(base,
        $Lang0Node::get_function(this),
        $Lang0Node::get_nodeValue(this)?*);
};

fn @@literal.safeIndex(base) {
    <> -1
};

fn @@varBind.safeIndex(base) {
    def nameIndex =
        safeIndexForNames(base, $Lang0Node::get_name(this));
    def valueIndex =
        safeIndexForNodes(base, $Lang0Node::get_nodeValue(this));
    <> maxOf(nameIndex, valueIndex)
};

fn @@varDef.safeIndex(base) {
    def nameIndex =
        safeIndexForNames(base, $Lang0Node::get_name(this));
    def valueIndex =
        safeIndexForNodes(base, $Lang0Node::get_nodeValue(this)?*);
    <> maxOf(nameIndex, valueIndex)
};

fn @@varDefMutable.safeIndex(base) {
    def nameIndex =
        safeIndexForNames(base, $Lang0Node::get_name(this));
    def valueIndex =
        safeIndexForNodes(base, $Lang0Node::get_nodeValue(this)?*);
    <> maxOf(nameIndex, valueIndex)
};

fn @@varRef.safeIndex(base) {
    <> safeIndexForNames(base, $Lang0Node::get_name(this))
};

## Makes a variable name by combining `base` with `index`. Handles the case
## where `index` is `-1` consistently with the other functions exported here.
export fn makeVarName(base, index) {
    <> ifIs { <> eq(index, -1) }
        { <> base }
        { <> cat(base, $Format::int(index)) }
};

## Returns an unused variable name within `node`, either the given `base` or
## `base` suffixed with an unsigned int.
export fn safeVarName(base, node) {
    <> makeVarName(base, safeIndex(node, base))
};

## Returns a safe index to be used within `node` to suffix the given `base`
## variable name. Returns `-1` if `base` itself is unused. Any index at or
## after the return value is safe to use.
export fn safeVarIndex(base, node) {
    ## In addition to having the opposite argument order, this keeps the
    ## generic function `safeIndex` private to this file.
    <> safeIndex(node, base)
};
