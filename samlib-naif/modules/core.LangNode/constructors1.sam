## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Collection :: del;
import core.Generator :: filterAll;


##
## Exported Definitions
##

## Documented in spec.
export fn makeApply(function, optValues?) {
    def values = ifValueOr { optValues* } { @void };
    return @apply{function, values}
};

## Documented in spec.
export fn makeBasicClosure(map) {
    return @closure{
        formals:    [],
        statements: [],
        map*
    }
};

## Documented in spec.
export fn makeCall(function, values*) {
    return @call{function, values}
};

## Documented in spec.
export fn makeCallLiterals(function, values*) {
    def literals = filterAll(values) { one -> makeLiteral(one) };
    return makeCall(function, literals*)
};

## Documented in spec.
export fn makeExport(node) {
    return @export{value: node}
};

## Documented in spec.
export fn makeExportSelection(names+) {
    return @exportSelection{select: names}
};

## Documented in spec.
export fn makeLiteral(value) {
    return @literal{value}
};

## Documented in spec.
export fn makeMaybe(value) {
    return @maybe{value}
};

## Documented in spec.
export fn makeNoYield(value) {
    return @noYield{value}
};

## Documented in spec.
export fn makeNonlocalExit(function, optValue?) {
    def value = ifValueOr { optValue* } { @void };
    return @nonlocalExit{function, value}
};

## Documented in spec.
export fn makeVarDef(name, optValue?) {
    return ifValue { optValue* }
        { value -> @varDef{name, value} }
        { @varDef{name} }
};

## Documented in spec.
export fn makeVarDefMutable(name, optValue?) {
    return ifValue { optValue* }
        { value -> @varDefMutable{name, value} }
        { -> @varDefMutable{name} }
};

## Documented in spec.
export fn makeVarRef(name) {
    return @varRef{name}
};

## Documented in spec.
export fn makeVarRefLvalue(name) {
    return @varRef{
        name,
        lvalue: { node -> makeVarStore(name, node) }
    }
};

## Documented in spec.
export fn makeVarStore(name, value) {
    return @varStore{name, value}
};

## Documented in spec.
export fn withFormals(node, formals) {
    return @(get_type(node)){dataOf(node)*, formals}
};

## Documented in spec.
export fn withName(node, name) {
    return @(get_type(node)){dataOf(node)*, name}
};

## Documented in spec.
export fn withYieldDef(node, name) {
    def map = dataOf(node);
    def newBindings = ifValue { map::yieldDef }
        { origName ->
            ## There's already a `yieldDef`. Prepend a variable definition
            ## statement instead of clobbering the existing binding.
            {statements: [makeVarDef(name, makeVarRef(origName))]}
        }
        { {yieldDef: name} };

    return @(get_type(node)){map*, newBindings*}
};

## Documented in spec.
export fn withYieldDefIfAbsent(node, name) {
    return ifIs { node::yieldDef }
        { node }
        { withYieldDef(node, name) }
};

## Documented in spec.
export fn withoutInterpolate(node) {
    return @(get_type(node))(del(dataOf(node), "interpolate"))
};

## Documented in spec.
export fn withoutIntermediates(node) {
    def data = del(
        del(dataOf(node), "lvalue"),
        "interpolate");

    return @(get_type(node))(data)
};
