## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Generator;
import core.Sequence;
import proto.Number;

import ./misc ::
    formalsMaxArgs,
    formalsMinArgs;


##
## Private Definitions
##

## Splits a string into a list of strings, dividing on the given character.
fn splitAtChar(s, ch) {
    var result = [];
    var current = "";

    fn addCurrentToResult() {
        result := [result*, current];
        current := ""
    };

    ## This uses `collect` just for the filter function, ignoring the
    ## collected result.
    collect(s, { one ->
        ifIs { eq(one, ch) }
            { addCurrentToResult() }
            { current := cat(current, one) }
    });

    addCurrentToResult();
    return result
};


##
## Exported Definitions
##

## Documented in spec.
export fn .get_baseName();

## Documented in spec.
fn @@external.get_baseName() {
    def components = splitAtChar(dataOf(this), ".");
    return $Sequence::nthFromEnd(components, 0)
};

## Documented in spec.
fn @@internal.get_baseName() {
    def components = splitAtChar(dataOf(this), "/");
    def last = $Sequence::nthFromEnd(components, 0);
    def parts = splitAtChar(last, ".");

    return get(parts, 0)
};

## Documented in spec.
export fn .get_definedNames();

## Documented in spec.
fn @@export.get_definedNames() {
    return get_definedNames(get_nodeValue(this))
};

## Documented in spec.
fn @@importModule.get_definedNames() {
    return [get_name(this)]
};

## Documented in spec.
fn @@importModuleSelection.get_definedNames() {
    def prefix = get_prefix(this);
    def select = ifValueOr { get_select(this) }
        { die("Cannot call `get_definedNames` on unresolved import.") };

    return $Generator::filterAll(select) { name -> cat(prefix, name) }
};

## Documented in spec.
fn @@importResource.get_definedNames() {
    return [get_name(this)]
};

## Documented in spec.
fn @@varDef.get_definedNames() {
    return [get_name(this)]
};

## Documented in spec.
fn @@varDefMutable.get_definedNames() {
    return [get_name(this)]
};

## Documented in spec.
fn Value.get_definedNames() {
    return []
};

## Documented in spec.
export fn get_formals(node) {
    return node::formals
};

## Documented in spec.
export fn get_format(node) {
    return node::format
};

## Documented in spec.
export fn get_function(node) {
    return node::function
};

## Documented in spec.
export fn get_id(node) {
    return node::id
};

## Documented in spec.
export fn get_info(node) {
    return? node::info
};

## Documented in spec.
export fn get_interpolate(node) {
    return? node::interpolate
};

## Documented in spec.
export fn get_lvalue(node) {
    return? node::lvalue
};

## Documented in spec.
export fn get_maxArgs(node) {
    return formalsMaxArgs(get_formals(node))
};

## Documented in spec.
export fn get_minArgs(node) {
    return formalsMinArgs(get_formals(node))
};

## Documented in spec.
export fn get_name(node) {
    return? node::name
};

## Documented in spec.
export fn get_nodeValue(node) {
    return? node::value
};

## Documented in spec.
export fn get_pex(node) {
    return node::pex
};

## Documented in spec.
export fn get_pexes(node) {
    return node::pexes
};

## Documented in spec.
export fn get_prefix(node) {
    return node::prefix
};

## Documented in spec.
export fn get_select(node) {
    return? node::select
};

## Documented in spec.
export fn get_source(node) {
    return node::source
};

## Documented in spec.
export fn get_statements(node) {
    return node::statements
};

## Documented in spec.
export fn get_target(node) {
    return node::target
};

## Documented in spec.
export fn get_values(node) {
    return node::values
};

## Documented in spec.
export fn get_yieldNode(node) {
    return? node::yield
};

## Documented in spec.
export fn get_yieldDef(node) {
    return? node::yieldDef
};
