## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Generator :: filterAll;
import ./constructors1 :: makeGet, makeVarFetch;
import ./literals :: SYMS, makeLiteral;


##
## Private Definitions
##

## Global variable names / regular variable references.
def NAMES = [
    @break,
    @continue,
    @eq,
    @ge,
    @gt,
    @ifIs,
    @ifNot,
    @ifSwitch,
    @ifValue,
    @ifValueAnd,
    @ifValueAndElse,
    @ifValueOr,
    @le,
    @loadModule,
    @loadResource,
    @loop,
    @lt,
    @maybeValue,
    @ne,
    @perGe,
    @perGt,
    @perLe,
    @perLt,
    @perNe,
    @return,
    @totalNe
];

## Module-scoped names.
def MOD_NAMES = [
    {mod: @Format,    name: @formatterFor},
    {mod: @Format,    name: @usual},
    {mod: @Generator, name: @filterAll},
    {mod: @Generator, name: @filterPump},
    {mod: @Generator, name: @makeRepeatGenerator},
    {mod: @Generator, name: @makeFilterGenerator},
    {mod: @Peg,       name: @any},
    {mod: @Peg,       name: @empty},
    {mod: @Peg,       name: @makeChoice},
    {mod: @Peg,       name: @makeCode},
    {mod: @Peg,       name: @makeLookaheadFailure},
    {mod: @Peg,       name: @makeLookaheadSuccess},
    {mod: @Peg,       name: @makeMainSequence},
    {mod: @Peg,       name: @makeParserThunk},
    {mod: @Peg,       name: @makeRepeat},
    {mod: @Peg,       name: @makeResult},
    {mod: @Peg,       name: @makeSequence},
    {mod: @Peg,       name: @makeString},
    {mod: @Peg,       name: @makeToken},
    {mod: @Peg,       name: @makeTokenSet},
    {mod: @Peg,       name: @makeTokenSetComplement},
    {mod: @Range,     name: @ClosedRange},
    {mod: @Range,     name: @OpenRange},
    {mod: @Sequence,  name: @reverseNth},
    {mod: @Sequence,  name: @sliceGeneral}
];


##
## Exported Definitions
##

## Documented in spec.
export def REFS = {}.cat(
    (filterAll(NAMES) { name ->
        {(name): makeVarFetch(name)}
    })*,

    (filterAll(MOD_NAMES) { modName ->
        def mod = modName::mod;
        def name = modName::name;
        def modVar = makeVarFetch(cast(Symbol, "$".cat(mod)));
        def refKey = cast(Symbol, "".cat(mod, "_", name));
        {(refKey): makeGet(modVar, makeLiteral(name))}
    })*
);
