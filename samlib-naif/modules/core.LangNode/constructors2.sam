## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#= language core.Lang0

import core.Collection :: del, keyList;
import core.Generator :: filterAll, filterPump;
import core.Sequence :: nthFromEnd, sliceExclusive;

import ./constructors1 :: *;
import ./getters :: *;
import ./misc :: canYieldVoid, isExpression;
import ./refs :: REFS;


##
## Private Definitions
##

## Expands the `yield` binding of `map` if it is `nonlocalExit`, including
## eliding the actual nonlocal exit when the `map` defines the matching
## yield definition name. Just returns the `yield` directly in
## non-`nonlocalExit` cases.
fn expandYield(map) {
    def yieldNode = ifValueOr { map::yield } { return };

    ifNot { hasType(yieldNode, @@nonlocalExit) } { return yieldNode };

    def function = get_function(yieldNode);
    def value = get_nodeValue(yieldNode);

    ## If the exit's `function` is a variable fetch of the same variable as
    ## this node's yield name, then skip the expansion and just return the
    ## exit's `value` directly.
    ifValues(
        [
            { -> hasType(function, @@fetch) },
            { . -> hasType(get_target(function), @@varRef) },
            { ., . -> map::yieldDef },
            { ., target, yieldDef -> eq(get_name(target), yieldDef) }
        ],
        { ., ., ., . -> return value });

    def exitCall = ifValueOr
        { ifIs { hasType(value, @@void) } { makeCall(function) } }
        {
            ifIs { hasType(value, @@maybe) }
                {
                    makeCallOrApply(function,
                        makeInterpolate(makeMaybeValue(get_nodeValue(value))))
                }
        }
        { makeCall(function, value) };

    return makeNoYield(exitCall)
};


##
## Exported Definitions
##

## Documented in spec.
export fn makeAssignmentIfPossible(target, value) {
    return? ifValue { get_lvalue(target) }
        { lvalue -> lvalue(value) }
};

## Documented in spec.
export fn makeCallOrApply(function, values*) {
    ifIs { perEq(values, []) }
        {
            ## No values. Easy out.
            return makeApply(function)
        };

    ## Convert the values as if interpolation needs to be handled. If in the
    ## end it doesn't, then the original values are used as-is. This converts
    ## runs of non-interpolated values to `makeList(ac, ac, ...)`, which
    ## converts cleanly at runtime as part of the ultimate call to `cat`.

    var pending = [];       ## Non-interpolated values, to be `makeList`ed.
    var cookedValues = [];  ## Fully-processed values (of either type).

    fn addToCooked(actual) {
        cookedValues := [cookedValues*, actual];
    };

    fn addPendingToCooked() {
        ifIs { perNe(pending, []) }
            {
                addToCooked(makeCall(REFS::makeList, pending*));
                pending := [];
            }
    };

    filterPump(values) { actual ->
        ifValue { get_interpolate(actual) }
            { node ->
                addPendingToCooked();
                addToCooked(makeCall(REFS::collect, node))
            }
            { pending := [pending*, actual] }
    };

    ifIs { perEq(cookedValues, []) }
        {
            ## There were no interpolated arguments.
            return makeCall(function, values*)
        };

    ## There is at least one interpolated argument.

    addPendingToCooked();

    return ifIs { nth(cookedValues, 1) }
        {
            ## More than one actual. Use `cat`.
            makeApply(function,
                makeCall(REFS::cat, cookedValues*))
        }
        {
            ## Only one. Use it directly as the values for the `apply` node.
            makeApply(function, cookedValues*)
        }
};

## Documented in spec.
export fn makeCallThunks(function, values*) {
    def thunks = filterAll(values) { one -> makeThunk(one) };
    return makeCall(function, thunks*)
};

## Documented in spec.
export fn makeDynamicImport(node) {
    return ifSwitch(
        { get_type(node) },
        {
            @@importModule: { . ->
                ## The translation is approximately
                ## `def name = loadModule(source)`.

                def name = get_name(node);
                def source = get_source(node);

                [makeVarDef(name,
                    makeCall(REFS::loadModule, makeLiteral(source)))]
            },

            @@importModuleSelection: { . ->
                ## The translation is along the same lines as for
                ## `importModule` translations, except as a list of
                ## statements, one per binding being imported, each one
                ## wrapped in a `get` call, e.g.
                ## `def name = get(load(source), "name")`.

                def source = get_source(node);
                def names = get_definedNames(node);
                def select = get_select(node);
                def loadCall = makeCall(REFS::loadModule, makeLiteral(source));

                filterAll(names, select) { name, sel ->
                    makeVarDef(name,
                        makeCall(REFS::get, loadCall, makeLiteral(sel)))
                }
            },

            @@importResource: { . ->
                ## The translation is approximately
                ## `def name = loadResource(source, format)`.

                def name = get_name(node);
                def format = get_format(node);
                def source = get_source(node);

                [makeVarDef(name,
                    makeCall(REFS::loadResource,
                        makeLiteral(source), makeLiteral(format)))]
            }
        })
};

## Documented in spec.
export fn makeFullClosure(nodeOrMap) {
    def map = ifValueOr { hasType(nodeOrMap, Map) } { dataOf(nodeOrMap) };
    def formals = ifValueOr { map::formals } { [] };
    var statements = ifValueOr { map::statements } { [] };
    def statSz = get_size(statements);

    def yieldNode = ifValueOr
        { expandYield(map) }
        { ifIs { map::yieldDef } { @void } }
        { ifIs { eq(statSz, 0) } { @void } }
        {
            def lastStat = nthFromEnd(statements, 0);
            ifIs { isExpression(lastStat) }
                {
                    statements := sliceExclusive(statements, 0);
                    ifIs { canYieldVoid(lastStat) }
                        { makeMaybe(lastStat) }
                        { lastStat }
                }
        }
        { @void };

    return @closure{
        map*,
        formals:    formals,
        statements: statements,
        yield:      yieldNode
    }
};

## Documented in spec.
export fn makeGet(collArg, keyArg) {
    return makeCall(REFS::get, collArg, keyArg)
};

## Documented in spec.
export fn makeImport(baseData) {
    var data = baseData;  ## Modified in some cases below.

    ifValue { data::select }
        { select ->
            ## It's a module binding selection.

            ifIs { data::name }
                { die("Import selection name must be a prefix.") };
            ifIs { data::format }
                { die("Cannot import selection of resource.") };

            ifNot { data::prefix }
            {
                ## Default to empty string for `prefix`.
                data := {data*, prefix: ""}
            };

            ifIs { hasType(select, @@"*") }
                {
                    ## It's a wildcard import.
                    data := del(data, "select");
                };

            return @importModuleSelection(data)
        };

    ifNot { data::name }
        {
            ## No `name` provided, so figure out a default one.
            data := {data*, name: cat("$", get_baseName(data::source))}
        };

    ifIs { data::format }
        {
            ## It's a resource.
            ifIs { hasType(data::source, @@external) }
                { die("Cannot import external resource.") };
            return @importResource(data)
        };

    ## It's a whole-module import.
    return @importModule(data)
};

## Documented in spec.
export fn makeInfoMap(node) {
    ifValue { get_info(node) }
        { info -> return info };

    def statements = get_statements(node);
    var exports = {};
    var imports = {};
    var resources = {};

    ## Adds all the names (a list of strings) to the `exports` map.
    fn addToExports(names) {
        exports := {exports*, names*: Value};
    };

    ## Adds or revises an element in the `imports` map.
    fn addToImports(source, names) {
        def orig = ifValueOr { get(imports, source) } { {} };
        def revised = {orig*, names*: Value};
        imports := {imports*, (source): revised};
    };

    ## Adds or revises an element in the `resources` map.
    fn addToResources(source, format) {
        ## This bounces through a map to uniquify the formats list.
        def orig = ifValueOr { get(resources, source) } { [] };
        def revised = keyList({orig*: null, (format): null});
        resources := {resources*, (source): revised};
    };

    ## Handles any `import*` node type. Ignores other types.
    fn handleImport(s) {
        ifIs { hasType(s, @@importModule) }
            { addToImports(get_source(s), [@module]) };
        ifIs { hasType(s, @@importModuleSelection) }
            {
                def names = ifValueOr { get_select(s) }
                    { die("Cannot call `makeInfoMap` on unresolved import.") };
                addToImports(get_source(s), names)
            };
        ifIs { hasType(s, @@importResource) }
            { addToResources(get_source(s), get_format(s)) };
    };

    ## The filter is just being used as a for-each loop. The direct
    ## result is ignored.
    filterAll(statements) { s ->
        ifIs { hasType(s, @@exportSelection) }
            { addToExports(get_select(s)) };
        ifIs { hasType(s, @@export) }
            {
                addToExports(get_definedNames(s));
                handleImport(get_nodeValue(s))
            };
        handleImport(s)
    };

    return {exports, imports, resources}
};

## Documented in spec.
export fn makeInterpolate(node) {
    return @fetch{
        target:      node,
        interpolate: node,
        lvalue:      { value -> @store{target: node, value} }
    }
};

## Documented in spec.
export fn makeMaybeValue(node) {
    return makeCall(REFS::maybeValue, makeThunk(node))
};

## Documented in spec.
export fn makeThunk(expression) {
    def yieldNode = ifIs { isExpression(expression) }
        { makeMaybe(expression) }
        { expression };
    return makeFullClosure({yield: yieldNode})
};

## Documented in spec.
export fn withDynamicImports(node) {
    def rawStatements = get_statements(node);

    ifIs { eq(rawStatements, []) }
        {
            ## Nothing to convert. Easy out!
            return node
        };

    def converted = filterAll(rawStatements) { s /out ->
        ifValueOr
            { hasType(s, @@importModule) }
            { hasType(s, @@importModuleSelection) }
            { hasType(s, @@importResource) }
            {
                ## Not an `import*`.
                yield /out [s]
            };

        yield /out makeDynamicImport(s)
    };

    def statements = cat(converted*);
    return @(get_type(node)){dataOf(node)*, statements}
};

## Documented in spec.
export fn withModuleDefs(node) {
    ifNot { eq(get_yieldNode(node), @void) }
        { die("Invalid node for `withModuleDefs` (has non-void `yield`).") };

    ## This is the metainformation of the module. In addition to being
    ## represented directly in the final `yield`, the (informational)
    ## `exports` in this is what's used to produce the top-level `exports`
    ## map.
    def info = makeInfoMap(node);

    def rawStatements = get_statements(node);

    ## This is a one-for-one list of replacements for the original
    ## `statements`.
    def statements = filterAll(rawStatements) { s /out ->
        ifIs { hasType(s, @@exportSelection) }
            { yield /out };

        yield ifIs { hasType(s, @@export) }
            { get_nodeValue(s) }
            { s }
    };

    ## This is a list of lists of mappings which, when combined, is a map
    ## of all exports.
    def exportValues = filterAll(info::exports) { mapping ->
        def name = get_key(mapping);
        makeCall(REFS::makeValueMap, makeLiteral(name), makeVarFetch(name))
    };

    def yieldExports = ifIs { eq(exportValues, []) }
        { makeLiteral({}) }
        { makeCall(REFS::cat, exportValues*) };
    def yieldInfo = makeLiteral(info);
    def yieldNode = makeCall(REFS::makeData,
        makeLiteral(@@module),
        makeCall(REFS::cat,
            makeCall(REFS::makeValueMap, makeLiteral("exports"), yieldExports),
            makeCall(REFS::makeValueMap, makeLiteral("info"), yieldInfo)));

    return @(get_type(node)){
        dataOf(node)*,
        info,
        yield: yieldNode,
        statements
    }
};

## Documented in spec.
export fn withoutTops(node) {
    def rawStatements = get_statements(node);

    ## This is a collation of all the forward declarations.
    def tops = filterAll(rawStatements) { s ->
        def defNode = ifIs { hasType(s, @@export) }
            { get_nodeValue(s) }
            { s };

        ifIs { defNode::top }
            { makeVarDef(get_name(defNode)) }
    };

    ## These are the one-for-one replacements for the original `statements`.
    def mains = filterAll(rawStatements) { s ->
        def defNode = ifIs { hasType(s, @@export) }
            { get_nodeValue(s) }
            { s };

        ifIs { defNode::top }
            { makeVarStore(get_name(defNode), get_nodeValue(defNode)) }
            { s }
    };

    ## This lists all the exported variables that were transformed above.
    def exports = filterAll(rawStatements) { s /out ->
        ifNot { hasType(s, @@export) }
            { yield /out };

        def defNode = get_nodeValue(s);
        ifNot { defNode::top }
            { yield /out };

        yield get_name(defNode)
    };

    def optSelection = ifIs { eq(exports, []) }
        { [] }
        { [makeExportSelection(exports*)] };

    return @(get_type(node)){
        dataOf(node)*,
        statements: [tops*, mains*, optSelection*]
    }
};

## Documented in spec.
export fn withTop(node) {
    return @(get_type(node)){dataOf(node)*, top: true}
};
