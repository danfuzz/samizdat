## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 Conversion / Simplification
##
## This includes code to strip out intermediate bindings in expression nodes.
## It's a bit of a layering violation to remove them here, admittedly, but the
## unsavory alternative is to do an entire separate tree walk to just do this
## (at the end of parsing).
##

#= language core.Lang0

import core.Generator :: filterAll;
import core.LangNode :: *;
import core.Range :: OpenRange;


##
## Private Definitions
##

## Does parser conversion of an expression or statement list.
fn convertPexInList(nodes) {
    return filterAll(nodes) { node -> convertPexIn(node) }
};

## Converts a pex to a function call on its converted inner pex.
fn makeFunCallPex(function, node, formals, moreArgs*) {
    return makeFunCall(function, convertPex(node::pex, formals), moreArgs*)
};

## Makes a node with additional / replacement bindings from the original.
fn withBindings(orig, more) {
    return @(orig.get_name()){orig*, more*}
};

## Makes a node with additional / replacement bindings from the original,
## but *without* intermediate bindings.
fn withFinalBindings(orig, more) {
    return withBindings(withoutIntermediates(orig), more)
};

## Expands the given pex node into an expression node.
fn convertPex(node, formals) {
    return ifSwitch(
        { node.get_name() },
        {
            @any: { . ->
                REFS::Peg_any
            },

            @choice: { . ->
                def convertedPexes = filterAll(node::pexes)
                    { pex -> convertPex(pex, formals) };
                makeFunCall(REFS::Peg_makeChoice, convertedPexes*)
            },

            @code: { . ->
                ## Use the lexical `formals` context to make a regular closure
                ## node, and just convert that. As a special case, notice if
                ## the closure is just a yield of a literal, and convert that
                ## with `makeResult`.
                def closurePayload = @{node*, formals};
                def fullClosure = makeFullClosure(closurePayload);

                ifValueAndElse
                    { eq(fullClosure::statements, []) }
                    { . -> fullClosure::yield.hasName(@literal) }
                    { ., yNode -> makeFunCall(REFS::Peg_makeResult, yNode) }
                    {
                        makeFunCall(REFS::Peg_makeCode, convertPexIn(fullClosure))
                    };
            },

            @empty: { . ->
                REFS::Peg_empty
            },

            @lookaheadFailure: { . ->
                makeFunCallPex(REFS::Peg_makeLookaheadFailure, node, formals)
            },

            @lookaheadSuccess: { . ->
                makeFunCallPex(REFS::Peg_makeLookaheadSuccess, node, formals)
            },

            @opt: { . ->
                makeFunCallPex(REFS::Peg_makeRepeat,
                    node, formals, LITS::INT_0, LITS::INT_1)
            },

            @plus: { . ->
                makeFunCallPex(REFS::Peg_makeRepeat,
                    node, formals, LITS::INT_1)
            },

            @sequence: { . ->
                ## Extract the formals out of any `varDef` nodes.
                def newFormals = filterAll(node::pexes) { pex ->
                    ifIs { pex.hasName(@varDef) }
                        { {name: pex::name} }
                        { {} }
                };

                ## Convert all the pexes, passing in appropriately-extended
                ## formals lists to each conversion.
                def convertedPexes =
                    filterAll(OpenRange.new(0), node::pexes)
                        { n, pex ->
                            def subPex = ifIs { pex.hasName(@varDef) }
                                { pex::value }
                                { pex };
                            convertPex(subPex,
                                [formals*, newFormals.sliceExclusive(0, n)*])
                        };

                makeFunCall(REFS::Peg_makeSequence, convertedPexes*)
            },

            @star: { . ->
                makeFunCallPex(REFS::Peg_makeRepeat, node, formals)
            },

            @string: { . ->
                makeFunCallLiterals(REFS::Peg_makeString, node::value)
            },

            @thunk: { . ->
                ## Use the lexical `formals` context to make a regular closure
                ## node, and just convert that.
                def closure = makeFullClosure(@{
                    formals,
                    yield: makeMaybe(node::value)
                });
                def convertedClosure = convertPexIn(closure);

                makeFunCall(REFS::Peg_makeParserThunk, convertedClosure)
            },

            @token: { . ->
                makeFunCallLiterals(REFS::Peg_makeToken, node::value)
            },

            @tokenSet: { . ->
                makeFunCallLiterals(REFS::Peg_makeTokenSet, node::values*)
            },

            @tokenSetComplement: { . ->
                makeFunCallLiterals(REFS::Peg_makeTokenSetComplement,
                    node::values*)
            },

            @varRef: { . ->
                ## `varRef` in the context of a pex just translates to a
                ## variable fetch of the same name in the context of an
                ## expression / statement.
                makeVarFetch(node::name)
            }
        })
};

## Converts a layer 1 expression or statement node into an equivalent layer
## 0 node.
fn convertPexIn(node) {
    return ifSwitch(
        { node.get_name() },
        {
            @apply: { . ->
                def target = convertPexIn(node::target);
                def name = convertPexIn(node::name);
                def values = convertPexIn(node::values);

                withFinalBindings(node, @{target, name, values});
            },

            @call: { . ->
                def target = convertPexIn(node::target);
                def name = convertPexIn(node::name);
                def values = convertPexInList(node::values);

                withFinalBindings(node, @{target, name, values});
            },

            @closure: { . ->
                def statements = convertPexInList(node::statements);
                def yieldNode = convertPexIn(node::yield);

                withBindings(node, @{statements, yield: yieldNode})
            },

            @fetch: { . ->
                def target = convertPexIn(node::target);
                withFinalBindings(node, @{target})
            },

            @parser: { . ->
                ## This is where the juicy stuff happens!
                makeFunCallPex(REFS::Peg_makeMainSequence, node, [])
            },

            @store: { . ->
                def target = convertPexIn(node::target);
                def value = convertPexIn(node::value);
                withFinalBindings(node, @{target, value})
            },

            @varDef:
            @varDefMutable: { . ->
                ifValue { node::value }
                    { value ->
                        withBindings(node, @{value: convertPexIn(value)})
                    }
                    { node }
            },

            @export:
            @maybe:
            @noYield: { . ->
                def value = convertPexIn(node::value);
                withBindings(node, @{value})
            },

            @exportSelection:
            @importModule:
            @importModuleSelection:
            @importResource:
            @literal:
            @varRef:
            @void: { . ->
                node
            }
        })
};


##
## Exported Definitions
##

## Documented in spec.
export fn simplify(expressionNode, resolveFn) {
    def converted = convertPexIn(expressionNode);

    return ifIs { converted.hasName(@closure) }
        { withModuleDefs(withResolvedImports(converted, resolveFn)) }
        { converted }
};
