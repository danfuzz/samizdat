## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 Conversion / Simplification
##
## This includes code to strip out intermediate bindings in expression nodes.
## It's a bit of a layering violation to remove them here, admittedly, but the
## unsavory alternative is to do an entire separate tree walk to just do this
## (at the end of parsing).
##

#= language core.Lang0

import core.Generator :: filterAll;
import core.Lang0Node :: *;
import core.Range :: makeOpenRange;
import core.Sequence :: sliceExclusive;


##
## Private Definitions
##

## `node.convertPex(formals)`, used to expand pex nodes into expression
## nodes.
fn .convertPex(formals);

## `node.convertPexIn()`, used to convert a layer 1 expression or statement
## node into an equivalent layer 0 node.
fn .convertPexIn();

## Does parser conversion of an expression or statement list.
fn convertPexInList(nodes) {
    return filterAll(nodes) { node -> convertPexIn(node) }
};

## Converts a pex to a function call on its converted inner pex.
fn makeCallPex(function, node, formals, moreArgs*) {
    return makeCall(function, convertPex(get_pex(node), formals), moreArgs*)
};

## Makes a node with additional / replacement bindings from the original.
fn withBindings(orig, more) {
    return @(get_type(orig))({dataOf(orig)*, more*})
};

## Makes a node with additional / replacement bindings from the original,
## but *without* intermediate bindings.
fn withFinalBindings(orig, more) {
    return withBindings(withoutIntermediates(orig), more)
};


##
## `convertPex` bindings
##

## Converts an `any` pex node.
fn @@any.convertPex(formals) {
    return REFS::Peg_any
};

## Converts a `choice` pex node.
fn @@choice.convertPex(formals) {
    def pexes = get_pexes(this);
    def convertedPexes = filterAll(pexes)
        { pex -> convertPex(pex, formals) };
    return makeCall(REFS::Peg_makeChoice, convertedPexes*)
};

## Converts a `code` pex node.
fn @@code.convertPex(formals) {
    ## Use the lexical `formals` context to make a regular closure node,
    ## and just convert that.

    def closurePayload = {(dataOf(this))*, formals};
    def convertedClosure = convertPexIn(makeFullClosure(closurePayload));

    return makeCall(REFS::Peg_makeCode, convertedClosure)
};

## Converts an `empty` pex node.
fn @@empty.convertPex(formals) {
    return REFS::Peg_empty
};

## Converts a `lookaheadFailure` pex node.
fn @@lookaheadFailure.convertPex(formals) {
    return makeCallPex(REFS::Peg_makeLookaheadFailure, this, formals)
};

## Converts a `lookaheadSuccess` pex node.
fn @@lookaheadSuccess.convertPex(formals) {
    return makeCallPex(REFS::Peg_makeLookaheadSuccess, this, formals)
};

## Converts an `opt` pex node.
fn @@opt.convertPex(formals) {
    return makeCallPex(REFS::Peg_makeRepeat, this, formals,
        makeLiteral(0), makeLiteral(1))
};

## Converts a `plus` pex node.
fn @@plus.convertPex(formals) {
    return makeCallPex(REFS::Peg_makeRepeat, this, formals, makeLiteral(1))
};

## Converts a `sequence` pex node.
fn @@sequence.convertPex(formals) {
    def pexes = get_pexes(this);

    ## Extract the formals out of any `varDef` nodes.
    def newFormals = filterAll(pexes) { pex ->
        ifIs { hasType(pex, @@varDef) }
            { {name: pex::name} }
            { {} }
    };

    ## Convert all the pexes, passing in appropriately-extended formals
    ## lists to each conversion.
    def convertedPexes =
        filterAll(makeOpenRange(0), pexes)
            { n, pex ->
                def subPex = ifIs { hasType(pex, @@varDef) }
                    { pex::value }
                    { pex };
                convertPex(subPex,
                    [formals*, sliceExclusive(newFormals, 0, n)*])
            };

    return makeCall(REFS::Peg_makeSequence, convertedPexes*)
};

## Converts a `star` pex node.
fn @@star.convertPex(formals) {
    return makeCallPex(REFS::Peg_makeRepeat, this, formals)
};

## Converts a `string` pex node.
fn @@string.convertPex(formals) {
    return makeCallLiterals(REFS::Peg_makeString, get_nodeValue(this))
};

## Converts a `thunk` pex node.
fn @@thunk.convertPex(formals) {
    ## Use the lexical `formals` context to make a regular closure node,
    ## and just convert that.

    def closure = makeFullClosure({
        formals,
        yield: makeMaybe(get_nodeValue(this))
    });
    def convertedClosure = convertPexIn(closure);

    return makeCall(REFS::Peg_makeParserThunk, convertedClosure)
};

## Converts a `token` pex node.
fn @@token.convertPex(formals) {
    return makeCallLiterals(REFS::Peg_makeToken, get_nodeValue(this))
};

## Converts a `tokenSet` pex node.
fn @@tokenSet.convertPex(formals) {
    def types = dataOf(this);
    return makeCallLiterals(REFS::Peg_makeTokenSet, types*)
};

## Converts a `tokenSetComplement` pex node.
fn @@tokenSetComplement.convertPex(formals) {
    def types = dataOf(this);
    return makeCallLiterals(REFS::Peg_makeTokenSetComplement, types*);
};

## Converts a `varRef` pex node.
fn @@varRef.convertPex(formals) {
    ## `varRef` in the context of a pex just translates to the same `varRef`
    ## in the context of an expression / statement.
    return convertPexIn(this)
};


##
## `convertPexIn` bindings
##

## Does parser conversion of a node whose payload is a map with an optional
## `value` binding to an arbitrary expression. Does not perform lvalue removal.
fn convertValuePayload(node) {
    return ifValue { get_nodeValue(node) }
        { value -> withBindings(node, {value: convertPexIn(value)}) }
        { node };
};

## Does parser conversion of an `apply` node.
fn @@apply.convertPexIn() {
    def function = convertPexIn(get_function(this));
    def values = convertPexIn(get_values(this));

    return withFinalBindings(this, {values, function});
};

## Does parser conversion of a `call` node.
fn @@call.convertPexIn() {
    def function = convertPexIn(get_function(this));
    def values = convertPexInList(get_values(this));

    return withFinalBindings(this, {function, values});
};

## Does parser conversion of a `closure` node.
fn @@closure.convertPexIn() {
    def statements = convertPexInList(get_statements(this));
    def yieldNode = convertPexIn(get_yieldNode(this));

    return withBindings(this, {statements, yield: yieldNode})
};

## Does parser conversion of an `export` node.
fn @@export.convertPexIn() {
    def value = convertPexIn(get_nodeValue(this));
    return withBindings(this, {value})
};

## Does parser conversion of an `exportSelection` node.
fn @@exportSelection.convertPexIn() {
    return this
};

## Does parser conversion of an `importModule` node.
fn @@importModule.convertPexIn() {
    return this
};

## Does parser conversion of an `importModuleSelection` node.
fn @@importModuleSelection.convertPexIn() {
    return this
};

## Does parser conversion of an `importResource` node.
fn @@importResource.convertPexIn() {
    return this
};

## Does parser conversion of a `literal` node.
fn @@literal.convertPexIn() {
    return this
};

## Does parser conversion of a `maybe` node.
fn @@maybe.convertPexIn() {
    def value = convertPexIn(get_nodeValue(this));
    return withBindings(this, {value})
};

## Does parser conversion of a `noYield` node.
fn @@noYield.convertPexIn() {
    def value = convertPexIn(get_nodeValue(this));
    return withBindings(this, {value})
};

## Does parser conversion of a `parser` node. This is where the juicy stuff
## happens!
fn @@parser.convertPexIn() {
    ## `@x(...)` is done here to convert this node from an expression node
    ## form (with map payload) into a parser node form (with pex payload).
    return makeCallPex(REFS::Peg_makeMainSequence, this, [])
};

## Does parser conversion of a `varBind` node.
fn @@varBind.convertPexIn() {
    return convertValuePayload(this)
};

## Does parser conversion of a `varDef` node.
fn @@varDef.convertPexIn() {
    return convertValuePayload(this)
};

## Does parser conversion of a `varDefMutable` node.
fn @@varDefMutable.convertPexIn() {
    return convertValuePayload(this)
};

## Does parser conversion of a `varRef` node.
fn @@varRef.convertPexIn() {
    return withoutIntermediates(this)
};

## Does parser conversion of a `void` node.
fn @@void.convertPexIn() {
    return this
};


##
## Exported Definitions
##

## Documented in spec.
export fn simplify(expressionNode, resolveFn) {
    def converted = convertPexIn(expressionNode);

    return ifIs { hasType(converted, @@closure) }
        { withModuleDefs(withResolvedImports(converted, resolveFn)) }
        { converted }
};
