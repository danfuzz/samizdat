## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 Conversion / Simplification
##
## This includes code to strip out intermediate bindings in expression nodes.
## It's a bit of a layering violation to remove them here, admittedly, but the
## unsavory alternative is to do an entire separate tree walk to just do this
## (at the end of parsing).
##

#= language core.Lang0

import core.Generator :: filterAll;
import core.LangNode :: *;
import core.Range :: makeOpenRange;
import core.Sequence :: sliceExclusive;


##
## Private Definitions
##

## Does parser conversion of an expression or statement list.
fn convertPexInList(nodes) {
    return filterAll(nodes) { node -> convertPexIn(node) }
};

## Converts a pex to a function call on its converted inner pex.
fn makeCallPex(function, node, formals, moreArgs*) {
    return makeCall(function, convertPex(get_pex(node), formals), moreArgs*)
};

## Makes a node with additional / replacement bindings from the original.
fn withBindings(orig, more) {
    return @(get_type(orig))({dataOf(orig)*, more*})
};

## Makes a node with additional / replacement bindings from the original,
## but *without* intermediate bindings.
fn withFinalBindings(orig, more) {
    return withBindings(withoutIntermediates(orig), more)
};

## Expands the given pex node into an expression node.
fn convertPex(node, formals) {
    return ifSwitch(
        { get_type(node) },
        {
            @@any: { . ->
                REFS::Peg_any
            },

            @@choice: { . ->
                def pexes = get_pexes(node);
                def convertedPexes = filterAll(pexes)
                    { pex -> convertPex(pex, formals) };
                makeCall(REFS::Peg_makeChoice, convertedPexes*)
            },

            @@code: { . ->
                ## Use the lexical `formals` context to make a regular closure
                ## node, and just convert that. As a special case, notice if
                ## the closure is just a yield of a literal, and convert that
                ## with `makeResult`.
                def closurePayload = {(dataOf(node))*, formals};
                def fullClosure = makeFullClosure(closurePayload);

                ifValues(
                    [
                        { eq(get_statements(fullClosure), []) },
                        { . -> hasClass(get_yieldNode(fullClosure), @@literal) }
                    ],
                    { ., yNode -> makeCall(REFS::Peg_makeResult, yNode) },
                    { makeCall(REFS::Peg_makeCode, convertPexIn(fullClosure)) }
                )
            },

            @@empty: { . ->
                REFS::Peg_empty
            },

            @@lookaheadFailure: { . ->
                makeCallPex(REFS::Peg_makeLookaheadFailure, node, formals)
            },

            @@lookaheadSuccess: { . ->
                makeCallPex(REFS::Peg_makeLookaheadSuccess, node, formals)
            },

            @@opt: { . ->
                makeCallPex(REFS::Peg_makeRepeat,
                    node, formals, makeLiteral(0), makeLiteral(1))
            },

            @@plus: { . ->
                makeCallPex(REFS::Peg_makeRepeat,
                    node, formals, makeLiteral(1))
            },

            @@sequence: { . ->
                def pexes = get_pexes(node);

                ## Extract the formals out of any `varDef` nodes.
                def newFormals = filterAll(pexes) { pex ->
                    ifIs { hasClass(pex, @@varDef) }
                        { {name: pex::name} }
                        { {} }
                };

                ## Convert all the pexes, passing in appropriately-extended
                ## formals lists to each conversion.
                def convertedPexes =
                    filterAll(makeOpenRange(0), pexes)
                        { n, pex ->
                            def subPex = ifIs { hasClass(pex, @@varDef) }
                                { pex::value }
                                { pex };
                            convertPex(subPex,
                                [formals*, sliceExclusive(newFormals, 0, n)*])
                        };

                makeCall(REFS::Peg_makeSequence, convertedPexes*)
            },

            @@star: { . ->
                makeCallPex(REFS::Peg_makeRepeat, node, formals)
            },

            @@string: { . ->
                makeCallLiterals(REFS::Peg_makeString, get_nodeValue(node))
            },

            @@thunk: { . ->
                ## Use the lexical `formals` context to make a regular closure
                ## node, and just convert that.
                def closure = makeFullClosure({
                    formals,
                    yield: makeMaybe(get_nodeValue(node))
                });
                def convertedClosure = convertPexIn(closure);

                makeCall(REFS::Peg_makeParserThunk, convertedClosure)
            },

            @@token: { . ->
                makeCallLiterals(REFS::Peg_makeToken, get_nodeValue(node))
            },

            @@tokenSet: { . ->
                def types = get_values(node);
                makeCallLiterals(REFS::Peg_makeTokenSet, types*)
            },

            @@tokenSetComplement: { . ->
                def types = get_values(node);
                makeCallLiterals(REFS::Peg_makeTokenSetComplement, types*)
            },

            @@varRef: { . ->
                ## `varRef` in the context of a pex just translates to a
                ## variable fetch of the same name in the context of an
                ## expression / statement.
                makeVarFetch(get_name(node))
            }
        })
};

## Converts a layer 1 expression or statement node into an equivalent layer
## 0 node.
fn convertPexIn(node) {
    return ifSwitch(
        { get_type(node) },
        {
            @@apply: { . ->
                def function = convertPexIn(get_function(node));
                def values = convertPexIn(get_values(node));

                withFinalBindings(node, {function, values});
            },

            @@call: { . ->
                def function = convertPexIn(get_function(node));
                def values = convertPexInList(get_values(node));

                withFinalBindings(node, {function, values});
            },

            @@closure: { . ->
                def statements = convertPexInList(get_statements(node));
                def yieldNode = convertPexIn(get_yieldNode(node));

                withBindings(node, {statements, yield: yieldNode})
            },

            @@fetch: { . ->
                def target = convertPexIn(get_target(node));
                withFinalBindings(node, {target})
            },

            @@parser: { . ->
                ## This is where the juicy stuff happens!
                makeCallPex(REFS::Peg_makeMainSequence, node, [])
            },

            @@store: { . ->
                def target = convertPexIn(get_target(node));
                def value = convertPexIn(get_nodeValue(node));
                withFinalBindings(node, {target, value})
            },

            @@varDef:
            @@varDefMutable: { . ->
                ifValue { get_nodeValue(node) }
                    { value ->
                        withBindings(node, {value: convertPexIn(value)})
                    }
                    { node }
            },

            @@export:
            @@maybe:
            @@noYield: { . ->
                def value = convertPexIn(get_nodeValue(node));
                withBindings(node, {value})
            },

            @@exportSelection:
            @@importModule:
            @@importModuleSelection:
            @@importResource:
            @@literal:
            @@varRef:
            @@void: { . ->
                node
            }
        })
};


##
## Exported Definitions
##

## Documented in spec.
export fn simplify(expressionNode, resolveFn) {
    def converted = convertPexIn(expressionNode);

    return ifIs { hasClass(converted, @@closure) }
        { withModuleDefs(withResolvedImports(converted, resolveFn)) }
        { converted }
};
