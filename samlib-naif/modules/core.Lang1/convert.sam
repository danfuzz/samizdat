## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 Conversion / Simplification
##
## This includes code to strip out intermediate bindings in expression nodes.
## It's a bit of a layering violation to remove them here, admittedly, but the
## unsavory alternative is to do an entire separate tree walk to just do this
## (at the end of parsing).
##

def Generator = moduleLoad(["core", "Generator"]);
def Range     = moduleLoad(["core", "Range"]);
def Sequence  = moduleLoad(["core", "Sequence"]);

def Lang0Node = moduleLoad(["core", "Lang0Node"]);
def REFS                 = Lang0Node::REFS;
def get_actuals          = Lang0Node::get_actuals;
def get_function         = Lang0Node::get_function;
def get_statements       = Lang0Node::get_statements;
def get_value            = Lang0Node::get_value;
def get_yield            = Lang0Node::get_yield;
def makeCall             = Lang0Node::makeCall;
def makeCallLiterals     = Lang0Node::makeCallLiterals;
def makeGet              = Lang0Node::makeGet;
def makeLiteral          = Lang0Node::makeLiteral;
def makeVarRef           = Lang0Node::makeVarRef;
def withoutIntermediates = Lang0Node::withoutIntermediates;


##
## Private Definitions
##

## `convertPex(node, formals)`, used to expand pex nodes into expression
## nodes.
def convertPex = makeRegularGeneric("convertPex", 2, 2);

## `convertPexIn(node)`, used to convert a layer 1 expression or statement
## node into an equivalent layer 0 node.
def convertPexIn = makeRegularGeneric("convertPexIn", 1, 1);

## Does parser conversion of an expression or statement list.
fn convertPexInList(nodes) {
    <> Generator::filterAll(nodes) { node <> convertPexIn(node) }
};

## Converts a pex to a function call on its converted inner pex.
fn makeCallPex(function, node, formals) {
    <> makeCall(function, convertPex(dataOf(node), formals))
};

## Makes a node with additional / replacement bindings from the original.
fn withBindings(orig, more) {
    <> @(typeNameOf(orig))({dataOf(orig)*, more*})
};

## Makes a node with additional / replacement bindings from the original,
## but *without* intermediate bindings.
fn withFinalBindings(orig, more) {
    <> withBindings(withoutIntermediates(orig), more)
};


##
## `convertPex` bindings
##

## Converts an `any` pex node.
fn any_convertPex(node, formals) {
    <> REFS::Peg_any
};
genericBind(convertPex, @@any, any_convertPex);

## Converts a `choice` pex node.
fn choice_convertPex(node, formals) {
    def pexes = dataOf(node);
    def convertedPexes = Generator::filterAll(pexes)
        { pex <> convertPex(pex, formals) };
    <> makeCall(REFS::Peg_makeChoice, convertedPexes*)
};
genericBind(convertPex, @@choice, choice_convertPex);

## Converts a `code` pex node.
fn code_convertPex(node, formals) {
    ## Use the lexical `formals` context to make a regular closure node,
    ## and just convert that.

    def closurePayload = {(dataOf(node))*, formals};
    def convertedClosure = convertPexIn(@closure(closurePayload));

    <> makeCall(REFS::Peg_makeCode, convertedClosure)
};
genericBind(convertPex, @@code, code_convertPex);

## Converts an `empty` pex node.
fn empty_convertPex(node, formals) {
    <> REFS::Peg_empty
};
genericBind(convertPex, @@empty, empty_convertPex);

## Converts a `lookaheadFailure` pex node.
fn lookaheadFailure_convertPex(node, formals) {
    <> makeCallPex(REFS::Peg_makeLookaheadFailure, node, formals)
};
genericBind(convertPex, @@lookaheadFailure, lookaheadFailure_convertPex);

## Converts a `lookaheadSuccess` pex node.
fn lookaheadSuccess_convertPex(node, formals) {
    <> makeCallPex(REFS::Peg_makeLookaheadSuccess, node, formals)
};
genericBind(convertPex, @@lookaheadSuccess, lookaheadSuccess_convertPex);

## Converts an `opt` pex node.
fn opt_convertPex(node, formals) {
    <> makeCallPex(REFS::Peg_makeOpt, node, formals)
};
genericBind(convertPex, @@opt, opt_convertPex);

## Converts a `plus` pex node.
fn plus_convertPex(node, formals) {
    <> makeCallPex(REFS::Peg_makePlus, node, formals)
};
genericBind(convertPex, @@plus, plus_convertPex);

## Converts a `sequence` pex node.
fn sequence_convertPex(node, formals) {
    def pexes = dataOf(node);

    ## Extract the formals out of any `varDef` nodes.
    def newFormals = Generator::filterAll(pexes) { pex ->
        <> ifIs { <> hasType(pex, @@varDef) }
            { <> {name: dataOf(pex)::name} }
            { <> {} }
    };

    ## Convert all the pexes, passing in appropriately-extended formals
    ## lists to each conversion.
    def convertedPexes =
        Generator::filterAll(Range::makeOpenRange(0), pexes)
            { n, pex ->
                def subPex = ifIs { <> hasType(pex, @@varDef) }
                    { <> dataOf(pex)::value }
                    { <> pex };
                <> convertPex(subPex,
                    [formals*, Sequence::sliceExclusive(newFormals, 0, n)*])
            };

    <> makeCall(REFS::Peg_makeSequence, convertedPexes*)
};
genericBind(convertPex, @@sequence, sequence_convertPex);

## Converts a `star` pex node.
fn star_convertPex(node, formals) {
    <> makeCallPex(REFS::Peg_makeStar, node, formals)
};
genericBind(convertPex, @@star, star_convertPex);

## Converts a `string` pex node.
fn string_convertPex(node, formals) {
    <> makeCallLiterals(REFS::Peg_makeString, dataOf(node))
};
genericBind(convertPex, @@string, string_convertPex);

## Converts a `thunk` pex node.
fn thunk_convertPex(node, formals) {
    ## Use the lexical `formals` context to make a regular closure node,
    ## and just convert that.

    def closure = @closure{
        formals,
        statements: [],
        yield: dataOf(node)
    };
    def convertedClosure = convertPexIn(closure);

    <> makeCall(REFS::Peg_makeThunk, convertedClosure)
};
genericBind(convertPex, @@thunk, thunk_convertPex);

## Converts a `token` pex node.
fn token_convertPex(node, formals) {
    <> makeCallLiterals(REFS::Peg_makeToken, dataOf(node))
};
genericBind(convertPex, @@token, token_convertPex);

## Converts a `tokenSet` pex node.
fn tokenSet_convertPex(node, formals) {
    def types = dataOf(node);
    <> makeCallLiterals(REFS::Peg_makeTokenSet, types*)
};
genericBind(convertPex, @@tokenSet, tokenSet_convertPex);

## Converts a `tokenSetComplement` pex node.
fn tokenSetComplement_convertPex(node, formals) {
    def types = dataOf(node);
    <> makeCallLiterals(REFS::Peg_makeTokenSetComplement, types*);
};
genericBind(convertPex, @@tokenSetComplement, tokenSetComplement_convertPex);

## Converts a `varRef` pex node.
fn varRef_convertPex(node, formals) {
    ## `varRef` in the context of a pex just translates to the same `varRef`
    ## in the context of an expression / statement.
    <> convertPexIn(node)
};
genericBind(convertPex, @@varRef, varRef_convertPex);


##
## `convertPexIn` bindings
##

## Does parser conversion of a node whose payload is a map with an optional
## `value` binding to an arbitrary expression. Does not perform lvalue removal.
fn convertValuePayload(node) {
    <> ifValue { <> get_value(node) }
        { value <> withBindings(node, {value: convertPexIn(value)}) }
        { <> node };
};

## Does parser conversion of an `apply` node.
fn apply_convertPexIn(node) {
    def function = convertPexIn(get_function(node));
    def actuals = convertPexIn(get_actuals(node));

    <> withFinalBindings(node, {function, actuals});
};
genericBind(convertPexIn, @@apply, apply_convertPexIn);

## Does parser conversion of a `call` node.
fn call_convertPexIn(node) {
    def function = convertPexIn(get_function(node));
    def actuals = convertPexInList(get_actuals(node));

    <> withFinalBindings(node, {function, actuals});
};
genericBind(convertPexIn, @@call, call_convertPexIn);

## Does parser conversion of a `closure` node.
fn closure_convertPexIn(node) {
    def statements = convertPexInList(get_statements(node));
    def yield = ifValue { <> get_yield(node) }
        { yield <> {yield: convertPexIn(yield)} }
        { <> {} };

    <> withBindings(node, {statements, yield*})
};
genericBind(convertPexIn, @@closure, closure_convertPexIn);

## Does parser conversion of a `jump` node.
fn jump_convertPexIn(node) {
    def function = convertPexIn(get_function(node));
    def optValue = ifValue { <> get_value(node) }
        { value <> {value: convertPexIn(value)} }
        { <> {} };

    <> withFinalBindings(node, {function, optValue*});
};
genericBind(convertPexIn, @@jump, jump_convertPexIn);

## Does parser conversion of a `literal` node.
fn literal_convertPexIn(node) {
    <> node
};
genericBind(convertPexIn, @@literal, literal_convertPexIn);

## Does parser conversion of a `parser` node. This is where the juicy stuff
## happens!
fn parser_convertPexIn(node) {
    ## `@x(...)` is done here to convert this node from an expression node
    ## form (with map payload) into a parser node form (with pex payload).
    <> makeCallPex(REFS::Peg_makeMainSequence, @x(get_value(node)), [])
};
genericBind(convertPexIn, @@parser, parser_convertPexIn);

## Does parser conversion of a `varBind` node.
fn varBind_convertPexIn(node) {
    <> convertValuePayload(node)
};
genericBind(convertPexIn, @@varBind, varBind_convertPexIn);

## Does parser conversion of a `varDef` node.
fn varDef_convertPexIn(node) {
    <> convertValuePayload(node)
};
genericBind(convertPexIn, @@varDef, varDef_convertPexIn);

## Does parser conversion of a `varDefMutable` node.
fn varDefMutable_convertPexIn(node) {
    <> convertValuePayload(node)
};
genericBind(convertPexIn, @@varDefMutable, varDefMutable_convertPexIn);

## Does parser conversion of a `varRef` node.
fn varRef_convertPexIn(node) {
    <> withoutIntermediates(node)
};
genericBind(convertPexIn, @@varRef, varRef_convertPexIn);


##
## Exported Definitions
##

## Documented in spec.
fn convertToLang0(expressionNode) {
    <> convertPexIn(expressionNode);
};

<> {
    convertToLang0
}
