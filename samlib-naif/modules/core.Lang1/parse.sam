## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 tree parser
##

def $Format    = moduleLoad(["core", "Format"]);
def $Generator = moduleLoad(["core", "Generator"]);
def $Number    = moduleLoad(["proto", "Number"]);
def $Peg       = moduleLoad(["core", "Peg"]);
def $Range     = moduleLoad(["core", "Range"]);

def $Lang0Node = moduleLoad(["core", "Lang0Node"]);
def REFS               = $Lang0Node::REFS;
def get_bind           = $Lang0Node::get_bind;
def get_formals        = $Lang0Node::get_formals;
def get_interpolate    = $Lang0Node::get_interpolate;
def get_lvalue         = $Lang0Node::get_lvalue;
def get_name           = $Lang0Node::get_name;
def get_nodeValue      = $Lang0Node::get_nodeValue;
def get_statements     = $Lang0Node::get_statements;
def get_yieldDef       = $Lang0Node::get_yieldDef;
def makeApply          = $Lang0Node::makeApply;
def makeCall           = $Lang0Node::makeCall;
def makeCallOrApply    = $Lang0Node::makeCallOrApply;
def makeCallThunks     = $Lang0Node::makeCallThunks;
def makeGet            = $Lang0Node::makeGet;
def makeInterpolate    = $Lang0Node::makeInterpolate;
def makeJump           = $Lang0Node::makeJump;
def makeLiteral        = $Lang0Node::makeLiteral;
def makeOptValue       = $Lang0Node::makeOptValue;
def makeThunk          = $Lang0Node::makeThunk;
def makeVarBind        = $Lang0Node::makeVarBind;
def makeVarDef         = $Lang0Node::makeVarDef;
def makeVarDefMutable  = $Lang0Node::makeVarDefMutable;
def makeVarRef         = $Lang0Node::makeVarRef;
def makeVarRefLvalue   = $Lang0Node::makeVarRefLvalue;
def withFormals        = $Lang0Node::withFormals;
def withoutInterpolate = $Lang0Node::withoutInterpolate;

def tokenize = intraLoad("tokenize")::tokenize;


##
## Private Definitions
##

## Reports the given list of pending tokens as part of error processing.
fn reportError(pending) {
    note("Pending tokens:");

    $Generator::filterPump(pending, $Range::makeInclusiveRange(1, 50))
        { token, . -> note(cat("    ", $Format::source(token))) };

    die("\nExtra tokens at end of program.")
};

## Set-like map of all lowercase identifier characters. Used to figure
## out if we're looking at a keyword in the `identifierString` rule.
def LOWER_ALPHA = {
    ($Range::makeInclusiveRange("a", "z"))*: true
};


##
## Grammar rules
##
## The following is a near-transliteration of the tree grammar in
## the Samizdat Layer 0 and Samizdat Layer 1 specifications.
##

##
## Samizdat Layer 0 definitions
##

## Forward declaration required for integrating layer 1 definitions.
def parParser;

## Forward declarations.
def parAssignExpression;
def parProgramBody;
def parUnaryExpression;

## Forward declaration for the "top" rule which parses operator expressions.
## This gets bound to `parUnaryExpression` in the Layer 0 and 1 grammars, but
## it's different in Layer 2.
def parOpExpression;

## Documented in spec.
def parExpression = $Peg::makeMainChoice(
    $Peg::makeThunk { <> parAssignExpression });

## Documented in spec.
def parParenExpression = $Peg::makeMainSequence(
    $Peg::makeToken(@@"("),
    parExpression,
    $Peg::makeToken(@@")"),
    $Peg::makeCode { ., ex, . <> withoutInterpolate(ex) });

## Documented in spec.
def parInt = $Peg::makeMainChoice(
    $Peg::makeSequence(
        $Peg::makeToken(@@"-"),
        $Peg::makeToken(@@int),
        $Peg::makeCode { ., i <> makeLiteral($Number::neg(dataOf(i))) }),
    $Peg::makeSequence(
        $Peg::makeToken(@@int),
        $Peg::makeCode { i <> makeLiteral(dataOf(i)) }));

## Documented in spec.
def parString = $Peg::makeMainSequence(
    $Peg::makeToken(@@string),
    $Peg::makeCode { s <> makeLiteral(dataOf(s)) });

## Documented in spec.
def parIdentifierString = $Peg::makeMainChoice(
    parString,
    $Peg::makeSequence(
        $Peg::makeToken(@@identifier),
        $Peg::makeCode { ident <> makeLiteral(dataOf(ident)) }),
    $Peg::makeSequence(
        $Peg::any,
        $Peg::makeCode { token ->
            <> ifNot { <> dataOf(token) }
                {
                    def type = get_typeName(token);
                    def firstCh = nth(type, 0);
                    <> ifIs { <> get(LOWER_ALPHA, firstCh) }
                        { <> makeLiteral(type) }
                }
            }));

## Documented in spec.
def parKey = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parIdentifierString,
        $Peg::makeToken(@@":"),
        $Peg::makeCode { key, . <> key }),
    $Peg::makeSequence(
        parExpression,
        $Peg::makeToken(@@":"),
        $Peg::makeCode { key, . <> key }));

## Documented in spec.
def parMapping = $Peg::makeMainSequence(
    $Peg::makeStar(parKey),
    parExpression,
    $Peg::makeCode { keys, value ->
        <> ifIs { <> eq(keys, []) }
            { <out> ->
                ## No keys were specified, so the value must be either a
                ## whole-map interpolation or a variable-name-to-its-value
                ## binding.
                ifValue { <> get_interpolate(value) }
                    { interp -> <out> interp };
                ifIs { <> hasType(value, @@varRef) }
                    {
                        <out> makeCall(REFS::makeValueMap,
                            makeLiteral(get_name(value)), value)
                    }
            }
            {
                ## One or more keys.
                <> makeCallOrApply(REFS::makeValueMap,
                    keys*, withoutInterpolate(value))
            }
    });

## Documented in spec.
def parMap = $Peg::makeMainSequence(
    $Peg::makeToken(@@"{"),
    $Peg::makeChoice(
        $Peg::makeSequence(
            parMapping,
            $Peg::makeStar(
                $Peg::makeSequence($Peg::makeToken(@@","), parMapping)),
            $Peg::makeCode { ., one, rest ->
                <> ifIs { <> eq(rest, []) }
                    { <> one }
                    { <> makeCall(REFS::cat, one, rest*) }
            }),
        $Peg::makeCode { . <> makeLiteral({}) }),
    $Peg::makeToken(@@"}"),
    $Peg::makeCode { ., result, . <> result });

## Documented in spec.
def parListItem = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parIdentifierString,
        $Peg::makeToken(@@":"),
        $Peg::makeCode { ., . ->
            die(
                "Mapping syntax not valid as a list item or call argument.")
        }),
    parExpression);

## Documented in spec.
def parUnadornedList = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parListItem,
        $Peg::makeStar(
            $Peg::makeSequence($Peg::makeToken(@@","), parListItem)),
        $Peg::makeCode { one, rest <> [one, rest*] }),
    $Peg::makeResult([]));

## Documented in spec.
def parList = $Peg::makeMainSequence(
    $Peg::makeToken(@@"["),
    parUnadornedList,
    $Peg::makeToken(@@"]"),
    $Peg::makeCode { ., expressions, . ->
        <> ifIs { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> makeCallOrApply(REFS::makeList, expressions*) }
    });

## Documented in spec.
def parTypeName = $Peg::makeMainSequence(
    $Peg::makeChoice(parIdentifierString, parParenExpression),
    $Peg::makeCode { name ->
        <> ifIs { <> hasType(name, @@literal) }
            { <> makeLiteral(@@(get_nodeValue(name))) }
            { <> makeCall(REFS::makeDerivedDataType, name) }
    });

## Documented in spec.
def parType = $Peg::makeMainSequence(
    $Peg::makeToken(@@"@@"),
    parTypeName);

## Documented in spec.
def parDeriv = $Peg::makeMainSequence(
    $Peg::makeToken(@@"@"),
    parTypeName,
    $Peg::makeOpt($Peg::makeChoice(parParenExpression, parMap, parList)),
    $Peg::makeCode { ., type, value ->
        <> makeCall(REFS::makeValue, type, value*)
    });

## Documented in spec.
def parVarRef = $Peg::makeMainSequence(
    $Peg::makeToken(@@identifier),
    $Peg::makeCode { name <> makeVarRefLvalue(dataOf(name)) });

## Documented in spec.
def parVarDef = $Peg::makeMainSequence(
    $Peg::makeTokenSet(@@def, @@var),
    $Peg::makeToken(@@identifier),
    $Peg::makeOpt($Peg::makeSequence($Peg::makeToken(@@"="), parExpression)),
    $Peg::makeCode { style, name, optExpr ->
        def nameString = dataOf(name);
        <> ifIs { <> hasType(style, @@def) }
            { <> makeVarDef(nameString, optExpr*) }
            { <> makeVarDefMutable(nameString, optExpr*) }
    });

## Documented in spec.
def parYieldDef = $Peg::makeMainSequence(
    $Peg::makeToken(@@"<"),
    $Peg::makeToken(@@identifier),
    $Peg::makeToken(@@">"),
    $Peg::makeCode { ., name, . <> dataOf(name) });

## Documented in spec.
def parOptYieldDef = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parYieldDef,
        $Peg::makeCode { y <> {yieldDef: y} }),
    $Peg::makeResult({}));

## Documented in spec.
def parFormal = $Peg::makeMainSequence(
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeToken(@@identifier),
            $Peg::makeCode { n <> {name: dataOf(n)} }),
        $Peg::makeSequence(
            $Peg::makeToken(@@"."),
            $Peg::makeResult({}))),
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeTokenSet(@@"?", @@"*", @@"+"),
            $Peg::makeCode { ., r <> {repeat: get_typeName(r)} }),
        $Peg::makeResult({})),
    $Peg::makeCode { name, repeat <> {name*, repeat*} });

## Documented in spec.
def parFormalsList = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parFormal,
        $Peg::makeStar($Peg::makeSequence($Peg::makeToken(@@","), parFormal)),
        $Peg::makeCode { one, rest <> [one, rest*] }),
    $Peg::makeResult([]));

## Documented in spec.
def parProgramDeclarations = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parOptYieldDef,
        $Peg::makeChoice(
            $Peg::makeSequence(
                $Peg::makeChoice(
                    $Peg::makeSequence(
                        $Peg::makeToken(@@identifier),
                        $Peg::makeCode { ., n <> {name: dataOf(n)} }),
                    $Peg::makeResult({})),
                $Peg::makeToken(@@"("),
                parFormalsList,
                $Peg::makeToken(@@")"),
                $Peg::makeCode { ., name, ., formals, . <> {name*, formals} }),
            $Peg::makeSequence(
                parFormalsList,
                $Peg::makeCode { ., formals <> {formals} })),
        $Peg::makeChoice(
            $Peg::makeToken(@@"->"),
            $Peg::makeLookaheadSuccess($Peg::makeToken(@@"<>"))),
        $Peg::makeCode { yieldDef, rest, . ->
            <> {yieldDef*, rest*}
        }),
    $Peg::makeResult({formals: []}));

## Documented in spec.
def parProgram = $Peg::makeMainSequence(
    parProgramDeclarations,
    $Peg::makeThunk { . <> parProgramBody },
    $Peg::makeCode { decls, body <> @closure{decls*, body*} });

## Documented in spec.
def parClosure = $Peg::makeMainSequence(
    $Peg::makeToken(@@"{"),
    parProgram,
    $Peg::makeToken(@@"}"),
    $Peg::makeCode { ., prog, . <> prog });

## Documented in spec.
def parNullaryClosure = $Peg::makeMainSequence(
    parClosure,
    $Peg::makeCode { c ->
        def formals = get_formals(c);
        ifIs { <> ne(formals, []) }
            { die("Invalid formal argument in code block.") };
        <> c
    });

## Documented in spec.
def parFnDef = $Peg::makeMainSequence(
    $Peg::makeToken(@@fn),
    $Peg::makeOpt(
        $Peg::makeSequence(
            $Peg::makeChoice(parVarRef, parType),
            $Peg::makeToken(@@"."),
            $Peg::makeCode { ., b, . <> b })),
    $Peg::makeToken(@@identifier),
    $Peg::makeToken(@@"("),
    parFormalsList,
    $Peg::makeToken(@@")"),
    parNullaryClosure,
    $Peg::makeCode { ., optBind, nameIdent, ., formals, ., code ->
        def returnDef = ifValue { <> code::yieldDef }
            { name ->
                ## The closure has a yield def, but we need to also bind
                ## it as `return`, so we add an extra local variable binding
                ## here.
                <> [makeVarDef(name, REFS::return)]
            }
            { <> [] };

        def name = dataOf(nameIdent);
        def closureMap = {
            dataOf(code)*,
            name,
            yieldDef: "return",
            statements: [returnDef*, get_statements(code)*]
        };

        <> ifValue { <> optBind* }
            { bind ->
                ## It's a generic function binding.
                def fullFormals = [{name: "this"}, formals*];
                def closure = @closure{
                    closureMap*,
                    formals: [{name: "this"}, formals*]
                };
                <> makeCall(REFS::genericBind, makeVarRef(name), bind, closure)
            }
            {
                ## It's a regular function definition. The resulting
                ## `@topDeclaration` is split apart in the `programBody` rule.
                def closure = @closure{closureMap*, formals};
                <> @topDeclaration{
                    top:  makeVarDef(name),
                    main: makeVarBind(name, closure)
                }
            }
    });

## Documented in spec.
def parTerm = $Peg::makeMainChoice(
    parVarRef, parInt, parString, parMap, parList,
    parDeriv, parType, parClosure, parParenExpression,
    ## Defined by Samizdat Layer 1. The lookahead is just to make
    ## it clear what is required to "jump into" Layer 1 parsing.
    $Peg::makeSequence(
        $Peg::makeLookaheadSuccess($Peg::makeToken(@@"{:")),
        $Peg::makeThunk { . <> parParser }));

## Documented in spec.
def parActualsList = $Peg::makeMainChoice(
    $Peg::makeSequence(
        $Peg::makeToken(@@"("),
        parUnadornedList,
        $Peg::makeToken(@@")"),
        $Peg::makeStar(parClosure),
        $Peg::makeCode { ., normalActuals, ., closureActuals ->
            <> [closureActuals*, normalActuals*]
        }),
    $Peg::makePlus(parClosure));

## Documented in spec.
def parPostfixOperator = $Peg::makeMainChoice(
    $Peg::makeSequence(
        parActualsList,
        $Peg::makeCode { actuals ->
            <> { node <> makeCallOrApply(node, actuals*) }
        }),
    $Peg::makeSequence(
        $Peg::makeToken(@@"::"),
        parIdentifierString,
        $Peg::makeCode { ., key <> { node <> makeGet(node, key) } }),
    $Peg::makeSequence(
        $Peg::makeToken(@@"*"),
        $Peg::makeCode { . <> { node <> makeInterpolate(node) } }),
    $Peg::makeSequence(
        $Peg::makeToken(@@"?"),
        $Peg::makeCode { . <> { node <> makeOptValue(node) } }));

## Documented in spec.
parUnaryExpression := $Peg::makeMainSequence(
    $Peg::makeChoice(
        $Peg::makeSequence(
            parTerm,
            $Peg::makeCode { base <> {base, prefixes: []} }),
        ## This is a stub representing the layer 2 part of the rule.
        $Peg::fail),
    $Peg::makeStar(parPostfixOperator),
    $Peg::makeCode { basePrefixes, postfixes ->
        def prefixes = basePrefixes::prefixes;
        var result = basePrefixes::base;

        $Generator::filterPump(postfixes) { op -> result := op(result) };
        $Generator::filterPump(prefixes) { op -> result := op(result) };
        <> result
    });

## Documented in spec.
parAssignExpression := $Peg::makeMainSequence(
    $Peg::makeThunk { <> parOpExpression },
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeToken(@@":="),
            $Peg::makeCode { base, . <> get_lvalue(base) },
            parExpression,
            $Peg::makeCode { base, ., lvalue, ex <> lvalue(ex) }),
        $Peg::makeCode { base <> base }));

## Documented in spec.
def parStatement = $Peg::makeChoice(
    parVarDef,
    parFnDef,
    parExpression);

## Documented in spec.
def parNonlocalExit = $Peg::makeMainSequence(
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeToken(@@"<"),
            parVarRef,
            $Peg::makeToken(@@">"),
            $Peg::makeCode { ., n, . <> n }),
        $Peg::makeSequence(
            $Peg::makeTokenSet(@@break, @@continue, @@return),
            $Peg::makeCode { op <> makeVarRef(get_typeName(op)) })),
    $Peg::makeOpt(parExpression),
    $Peg::makeCode { name, optValue <> makeJump(name, optValue*) });

## Documented in spec.
def parYield = $Peg::makeMainSequence(
    $Peg::makeToken(@@"<>"),
    $Peg::makeChoice(
        $Peg::makeSequence(
            parExpression,
            $Peg::makeCode { ., ex <> {yield: ex} }),
        $Peg::makeResult({})));

## Documented in spec.
parProgramBody := $Peg::makeMainSequence(
    $Peg::makeStar($Peg::makeToken(@@";")),
    $Peg::makeStar(
        $Peg::makeMainSequence(
            parStatement,
            $Peg::makePlus($Peg::makeToken(@@";")),
            $Peg::makeCode { s, . <> s })),
    $Peg::makeChoice(
        $Peg::makeMainSequence(
            $Peg::makeChoice(parStatement, parNonlocalExit),
            $Peg::makeCode { s <> {statements: [s]} }),
        $Peg::makeMainSequence(
            parYield,
            $Peg::makeCode { y <> {statements: [], y*} }),
        $Peg::makeResult({statements: []})),
    $Peg::makeStar($Peg::makeToken(@@";")),
    $Peg::makeCode { ., most, last, . ->
        def rawStatements = [most*, last::statements*];
        def tops = $Generator::filterAll(rawStatements)
            { s ->
                <> ifIs { <> hasType(s, @@topDeclaration) }
                    { <> s::top }
            };
        def mains = $Generator::filterAll(rawStatements)
            { s ->
                <> ifIs { <> hasType(s, @@topDeclaration) }
                    { <> s::main }
                    { <> s }
            };
        <> {last*, statements: [tops*, mains*]}
    });

## Documented in spec.
def parExpressionOrError = $Peg::makeMainSequence(
    parExpression,
    $Peg::makeOpt(
        $Peg::makeMainSequence(
            $Peg::makePlus($Peg::any),
            $Peg::makeCode { pending -> reportError(pending) })),
    $Peg::makeCode { ex, . <> ex });

## Documented in spec.
def parProgramOrError = $Peg::makeMainSequence(
    parProgram,
    $Peg::makeOpt(
        $Peg::makeMainSequence(
            $Peg::makePlus($Peg::any),
            $Peg::makeCode { pending -> reportError(pending) })),
    $Peg::makeCode { prog, . <> prog });


##
## Samizdat Layer 1 definitions
##

## `choicePex` is the top-level parsing expression node type.
def parChoicePex;

## Map from parser token types to derived value types for pexes.
def PEX_TYPES = {
    @@"&": "lookaheadSuccess",
    @@"!": "lookaheadFailure",
    @@"?": "opt",
    @@"*": "star",
    @@"+": "plus"
};

## Documented in spec.
parParser := $Peg::makeMainSequence(
    $Peg::makeToken(@@"{:"),
    $Peg::makeThunk { . <> parChoicePex },
    $Peg::makeToken(@@":}"),
    $Peg::makeCode { ., pex, . <> @parser{value: pex} });

## Documented in spec.
def parParenPex = $Peg::makeMainSequence(
    $Peg::makeToken(@@"("),
    $Peg::makeThunk { . <> parChoicePex },
    $Peg::makeToken(@@")"),
    $Peg::makeCode { ., pex, . <> pex });

## Documented in spec.
def parParserString = $Peg::makeMainSequence(
    $Peg::makeToken(@@string));

## Documented in spec.
def parParserToken = $Peg::makeMainSequence(
    $Peg::makeToken(@@"@"),
    parIdentifierString,
    $Peg::makeCode { ., type <> @token(@@(get_nodeValue(type))) });

## Documented in spec.
def parParserSetString = $Peg::makeMainSequence(
    $Peg::makeToken(@@string),
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeToken(@@".."),
            $Peg::makeToken(@@string),
            $Peg::makeCode { <out> s, ., end ->
                def startChar = dataOf(s);
                def endChar = dataOf(end);

                ## Reject non-single-character strings.
                ifIs { <> ne(1, get_size(startChar)) } { <out> };
                ifIs { <> ne(1, get_size(endChar)) } { <out> };

                <> cat($Range::makeInclusiveRange(startChar, endChar)*)
            }),
        $Peg::makeCode { s <> dataOf(s) }));

## Documented in spec.
def parParserSet = $Peg::makeMainSequence(
    $Peg::makeToken(@@"["),
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeToken(@@"!"),
            $Peg::makeResult("tokenSetComplement")),
        $Peg::makeResult("tokenSet")),
    $Peg::makeChoice(
        $Peg::makeMainSequence(
            $Peg::makePlus(parParserSetString),
            $Peg::makeCode { strings ->
                <> collect(cat(strings*), { ch <> @@(ch) })
            }),
        $Peg::makeMainSequence(
            $Peg::makePlus(parParserToken),
            $Peg::makeCode { tokens <> collect(tokens, dataOf) }),
        $Peg::makeResult([])),
    $Peg::makeToken(@@"]"),
    $Peg::makeCode { ., type, terminals, . <> @(type)(terminals) });

## Documented in spec.
def parParserCode = $Peg::makeMainSequence(
    parNullaryClosure,
    $Peg::makeCode { closure <> @code(dataOf(closure)) });


## Documented in spec.
def parParserThunk = $Peg::makeMainSequence(
    $Peg::makeToken(@@"%"),
    parTerm,
    $Peg::makeCode { ., term <> @thunk(term) });

## Documented in spec.
def parParserTerm = $Peg::makeMainChoice(
    $Peg::makeSequence(
        $Peg::makeToken(@@"."),
        $Peg::makeResult(@any)),
    $Peg::makeSequence(
        $Peg::makeToken(@@"("),
        $Peg::makeToken(@@")"),
        $Peg::makeResult(@empty)),
    parVarRef,
    parParserString,
    parParserToken,
    parParserSet,
    parParserCode,
    parParserThunk,
    parParenPex);

## Documented in spec.
def parRepeatPex = $Peg::makeMainSequence(
    parParserTerm,
    $Peg::makeChoice(
        $Peg::makeSequence(
            $Peg::makeTokenSet(@@"?", @@"*", @@"+"),
            $Peg::makeCode { term, repeat ->
                <> @(get(PEX_TYPES, get_type(repeat)))(term)
            }),
        $Peg::makeCode { term <> term }));

## Documented in spec.
def parLookaheadPex = $Peg::makeMainChoice(
    $Peg::makeSequence(
        $Peg::makeTokenSet(@@"&", @@"!"),
        parRepeatPex,
        $Peg::makeCode { lookahead, pex ->
            <> @(get(PEX_TYPES, get_type(lookahead)))(pex)
        }),
    parRepeatPex);

## Documented in spec.
def parNamePex = $Peg::makeMainChoice(
    $Peg::makeSequence(
        $Peg::makeToken(@@identifier),
        $Peg::makeToken(@@"="),
        parLookaheadPex,
        $Peg::makeCode { name, ., pex ->
            <> @varDef{name: dataOf(name), value: pex}
        }),
    parLookaheadPex);

## Documented in spec.
def parSequencePex = $Peg::makeMainSequence(
    $Peg::makePlus(parNamePex),
    $Peg::makeCode { items <> @sequence(items) });

## Documented in spec.
parChoicePex := $Peg::makeMainSequence(
    parSequencePex,
    $Peg::makeStar(
        $Peg::makeSequence(
            $Peg::makeToken(@@"|"),
            parSequencePex)),
    $Peg::makeCode { one, rest <> @choice[one, rest*] });


##
## Layer 2 Rule Stubs
##

## Documented in spec.
parOpExpression := parUnaryExpression;


##
## Exported Definitions
##

## Documented in spec.
fn parseExpression(expression) {
    def tokens = ifIs { <> hasType(expression, String) }
        { <> tokenize(expression) }
        { <> expression };

    <> $Peg::apply(parExpressionOrError, tokens)
};

## Documented in spec.
fn parseProgram(program) {
    def tokens = ifIs { <> hasType(program, String) }
        { <> tokenize(program) }
        { <> program };

    <> $Peg::apply(parProgramOrError, tokens)
};

<> {
    parseExpression,
    parseProgram
}
