## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Samizdat Layer 1 tree parser
##

#= language core.Lang0

import core.Format;
import core.Generator :: filterPump;
import core.LangNode :: *;
import core.Peg :: *;
import core.Range :: makeInclusiveRange;

import ./tokenize :: tokenize;


##
## Private Definitions
##

## Reports the given list of pending tokens as part of error processing.
fn reportError(pending) {
    note("Pending tokens:");

    filterPump(pending, makeInclusiveRange(1, 50))
        { token, . -> note("    ", $Format::source(token)) };

    die("\nExtra tokens at end of program.")
};

## Set-like map of all lowercase identifier characters. Used to figure
## out if we're looking at a keyword in the `identifierString` rule.
def LOWER_ALPHA = {
    makeInclusiveRange("a", "z")*: true
};


##
## Grammar rules
##
## The following is a near-transliteration of the tree grammar in
## the Samizdat Layer 0 and Samizdat Layer 1 specifications.
##

##
## Samizdat Layer 0 definitions
##

## Forward declaration required for integrating layer 1 definitions.
def parPexBlock;

## Forward declarations.
def parAssignExpression;
def parRawClosure;

## Forward declaration for the "top" rule which parses operator expressions.
## This gets bound to `parUnaryExpression` in the Layer 0 and 1 grammars, but
## it's different in Layer 2.
def parOpExpression;

## Documented in spec.
def parExpression = makeMainChoice(
    makeParserThunk { parAssignExpression });

## Documented in spec.
def parParenExpression = makeMainSequence(
    makeToken(@@"("),
    parExpression,
    makeToken(@@")"),
    makeCode { ., ex, . -> withoutInterpolate(ex) });

## Documented in spec.
def parName =  makeMainSequence(
    makeToken(@@identifier),
    makeCode { nameIdent -> nameIdent::value });

## Documented in spec.
def parNameList = makeMainSequence(
    parName,
    makeRepeat(makeSequence(makeToken(@@","), parName)),
    makeCode { first, rest -> [first, rest*] });

## Documented in spec.
def parVarLvalue = makeMainSequence(
    parName,
    makeCode { name -> makeVarFetchLvalue(name) });

## Documented in spec.
def parVarRef = makeMainSequence(
    makeToken(@@var),
    parName,
    makeCode { ., name -> makeVarRef(name) });

## Documented in spec.
def parIdentifierString = makeMainChoice(
    makeSequence(
        makeToken(@@string),
        makeCode { s -> makeLiteral(s::value) }),
    makeSequence(
        parName,
        makeCode { name -> makeLiteral(name) }),
    makeSequence(
        any,
        makeCode { token ->
            ifNot { token.dataOf() }
                {
                    def name = get_classNameString(token);
                    def firstCh = name.nth(0);
                    ifIs { LOWER_ALPHA.get(firstCh) }
                        { makeLiteral(name) }
                }
            }));

## Documented in spec.
def parLiteral = makeMainChoice(
    makeSequence(
        makeToken(@@"-"),
        makeToken(@@int),
        makeCode { ., i -> makeLiteral(i::value.neg()) }),
    makeSequence(
        makeToken(@@int),
        makeCode { i -> makeLiteral(i::value) }),
    makeSequence(
        makeToken(@@string),
        makeCode { s -> makeLiteral(s::value) }),
    makeSequence(
        makeToken(@@false),
        makeResult(makeLiteral(false))),
    makeSequence(
        makeToken(@@true),
        makeResult(makeLiteral(true))),
    makeSequence(
        makeToken(@@null),
        makeResult(makeLiteral(null))),
    makeSequence(
        makeToken(@@"@"),
        makeToken(@@"."),
        parIdentifierString,
        makeCode { ., ., name -> makeSelector(name::value) }));

## Documented in spec.
def parKey = makeMainChoice(
    makeSequence(
        parIdentifierString,
        makeToken(@@":"),
        makeCode { key, . -> key }),
    makeSequence(
        parExpression,
        makeToken(@@":"),
        makeCode { key, . -> key }));

## Documented in spec.
def parMapping = makeMainChoice(
    makeSequence(
        makeRepeat(parKey, 1),
        parExpression,
        makeCode { keys, value ->
            makeCallOrApply(REFS::makeValueMap,
                keys*, withoutInterpolate(value))
        }),
    makeSequence(
        parExpression,
        makeCode { value -> value::interpolate }),
    makeSequence(
        parName,
        makeCode { name ->
            makeCall(REFS::makeValueMap, makeLiteral(name), makeVarFetch(name))
        }));

## Documented in spec.
def parMap = makeMainSequence(
    makeToken(@@"{"),
    makeChoice(
        makeSequence(
            parMapping,
            makeRepeat(
                makeSequence(makeToken(@@","), parMapping)),
            makeCode { ., one, rest ->
                ifIs { eq(rest, []) }
                    { one }
                    { makeCall(REFS::SEL_cat, one, rest*) }
            }),
        makeCode { . -> makeLiteral({}) }),
    makeToken(@@"}"),
    makeCode { ., result, . -> result });

## Documented in spec.
def parListItem = makeMainChoice(
    makeSequence(
        parIdentifierString,
        makeToken(@@":"),
        makeCode { ., . ->
            die("Mapping syntax not valid as a list item or call argument.")
        }),
    parExpression);

## Documented in spec.
def parUnadornedList = makeMainChoice(
    makeSequence(
        parListItem,
        makeRepeat(
            makeSequence(makeToken(@@","), parListItem)),
        makeCode { one, rest -> [one, rest*] }),
    makeResult([]));

## Documented in spec.
def parList = makeMainSequence(
    makeToken(@@"["),
    parUnadornedList,
    makeToken(@@"]"),
    makeCode { ., expressions, . ->
        ifIs { eq(expressions, []) }
            { makeLiteral([]) }
            { makeCallOrApply(REFS::makeList, expressions*) }
    });

## Documented in spec.
def parType = makeMainSequence(
    makeToken(@@"@@"),
    makeChoice(
        makeSequence(
            parIdentifierString,
            makeCode { ., name ->
                makeLiteral(@@(makeInternedSelector(name::value)))
            }),
        makeSequence(
            parParenExpression,
            makeCode { ., name ->
                makeCall(REFS::makeDerivedDataClass, name)
            })));

## Documented in spec.
def parDeriv = makeMainSequence(
    makeToken(@@"@"),
    makeChoice(
        makeSequence(
            parIdentifierString,
            makeCode { ., name ->
                makeLiteral(@@(makeInternedSelector(name::value)))
            }),
        parParenExpression),
    makeRepeat(makeChoice(parParenExpression, parMap, parList), 0, 1),
    makeCode { ., cls, value ->
        makeCall(REFS::makeData, cls, value*)
    });

## Documented in spec.
def parFullClosure = makeMainSequence(
    makeLookaheadSuccess(makeToken(@@"{")),
    makeParserThunk { . -> parRawClosure },
    makeCode { ., raw ->
        def closure = makeFullClosure(raw);
        withoutTops(closure)
    });

## Documented in spec.
def parBasicClosure = makeMainSequence(
    makeLookaheadSuccess(makeToken(@@"{")),
    makeParserThunk { . -> parRawClosure },
    makeCode { ., raw ->
        def closure = makeBasicClosure(raw);
        withoutTops(closure)
    });

## Documented in spec.
def parNullaryClosure = makeMainSequence(
    parFullClosure,
    makeCode { c ->
        ifIs { ne(c::formals, []) }
            { die("Invalid formal argument in code block.") };
        c
    });

## Documented in spec.
def parBasicNullaryClosure = makeMainSequence(
    parBasicClosure,
    makeCode { c ->
        ifIs { ne(c::formals, []) }
            { die("Invalid formal argument in code block.") };
        c
    });

## Documented in spec.
def parTerm = makeMainChoice(
    parVarLvalue, parVarRef, parLiteral, parMap, parList,
    parDeriv, parType, parFullClosure, parParenExpression,
    ## Defined by Samizdat Layer 1. The lookahead is just to make
    ## it clear what is required to "jump into" Layer 1 parsing.
    makeSequence(
        makeLookaheadSuccess(makeToken(@@"{:")),
        makeParserThunk { . -> parPexBlock }));

## Documented in spec.
def parActualsList = makeMainChoice(
    makeSequence(
        makeToken(@@"("),
        parUnadornedList,
        makeToken(@@")"),
        makeRepeat(parFullClosure),
        makeCode { ., normalActuals, ., closureActuals ->
            [closureActuals*, normalActuals*]
        }),
    makeRepeat(parFullClosure, 1));

## Documented in spec.
def parPostfixOperator = makeMainChoice(
    makeSequence(
        parActualsList,
        makeCode { actuals ->
            { node -> makeCallOrApply(node, actuals*) }
        }),
    makeSequence(
        makeToken(@@"::"),
        parIdentifierString,
        makeCode { ., key -> { node -> makeGet(node, key) } }),
    makeSequence(
        makeToken(@@"*"),
        makeCode { . -> { node -> makeInterpolate(node) } }),
    makeSequence(
        makeToken(@@"?"),
        makeCode { . -> { node -> makeMaybeValue(node) } }),
    makeSequence(
        makeToken(@@"."),
        parName,
        makeChoice(
            makeSequence(
                parActualsList,
                makeCode { ., name, actuals ->
                    { node ->
                        makeCallOrApply(makeSelector(name), node, actuals*)
                    }
                }),
            makeCode { ., name ->
                def getterRef = makeSelector("get_".cat(name));
                { node ->
                    def getterCall = makeCall(getterRef, node);
                    @(get_class(getterCall)){
                        getterCall.dataOf()*,
                        lvalue: { expr ->
                            def setterRef = makeSelector("set_".cat(name));
                            makeCall(setterRef, node, expr)
                        }
                    }
                }
            })));

## Documented in spec.
def parUnaryExpression = makeMainSequence(
    makeChoice(
        makeSequence(
            parTerm,
            makeCode { base -> {base, prefixes: []} }),
        ## This is a stub representing the layer 2 part of the rule.
        fail),
    makeRepeat(parPostfixOperator),
    makeCode { basePrefixes, postfixes ->
        def prefixes = basePrefixes::prefixes;
        var result = basePrefixes::base;

        filterPump(postfixes) { op -> result := op(result) };
        filterPump(prefixes) { op -> result := op(result) };
        result
    });

## Documented in spec.
parAssignExpression := makeMainSequence(
    makeParserThunk { parOpExpression },
    makeChoice(
        makeSequence(
            makeToken(@@":="),
            parExpression,
            makeCode { target, ., value ->
                makeAssignmentIfPossible(target, value)
            }),
        makeCode { target -> target }));

## Documented in spec.
def parYieldOrNonlocal = makeMainSequence(
    makeTokenSet(@@break, @@continue, @@return, @@yield),
    makeRepeat(makeToken(@@"?"), 0, 1),
    makeChoice(
        makeSequence(
            makeCode { op, . -> hasClass(op, @@yield) },
            makeChoice(
                makeSequence(makeToken(@@"/"), parVarLvalue),
                makeResult(@yield))),
        makeCode { op, . -> makeVarFetch(get_classNameString(op)) }),
    makeChoice(
        makeSequence(
            parExpression,
            makeCode { ., optQuest, ., v ->
                ifIs { optQuest* } { makeMaybe(v) } { v }
            }),
        makeCode { ., optQuest, . ->
            ifNot { optQuest* } { @void }
        }),
    makeCode { ., ., name, value ->
        ifIs { eq(name, @yield) }
            { value }
            { makeNonlocalExit(name, value) }
    });

## Documented in spec.
def parVarDef = makeMainSequence(
    makeToken(@@def),
    parName,
    makeRepeat(makeSequence(makeToken(@@"="), parExpression), 0, 1),
    makeCode { ., name, optExpr ->
        makeVarDef(name, optExpr*)
    });

## Documented in spec.
def parVarDefMutable = makeMainSequence(
    makeToken(@@var),
    parName,
    makeRepeat(makeSequence(makeToken(@@"="), parExpression), 0, 1),
    makeCode { ., name, optExpr ->
        makeVarDefMutable(name, optExpr*)
    });

## Documented in spec.
def parYieldDef = makeMainSequence(
    makeToken(@@"/"),
    parName,
    makeCode { ., name -> name });

## Documented in spec.
def parOptYieldDef = makeMainChoice(
    makeSequence(
        parYieldDef,
        makeCode { y -> {yieldDef: y} }),
    makeResult({}));

## Documented in spec.
def parFormal = makeMainSequence(
    makeChoice(
        makeSequence(
            parName,
            makeCode { n -> {name: n} }),
        makeSequence(
            makeToken(@@"."),
            makeResult({}))),
    makeChoice(
        makeSequence(
            makeTokenSet(@@"?", @@"*", @@"+"),
            makeCode { ., r -> {repeat: get_classNameString(r)} }),
        makeResult({})),
    makeCode { name, repeat -> {name*, repeat*} });

## Documented in spec.
def parFormalsList = makeMainChoice(
    makeSequence(
        parFormal,
        makeRepeat(makeSequence(makeToken(@@","), parFormal)),
        makeCode { one, rest -> [one, rest*] }),
    makeResult([]));

## Documented in spec.
def parClosureDeclarations = makeMainChoice(
    makeSequence(
        makeChoice(
            makeSequence(
                makeChoice(
                    makeSequence(
                        parName,
                        makeCode { n -> {name: n} }),
                    makeResult({})),
                makeToken(@@"("),
                parFormalsList,
                makeToken(@@")"),
                makeCode { name, ., formals, . -> {name*, formals} }),
            makeSequence(
                parFormalsList,
                makeCode { formals -> {formals} })),
        parOptYieldDef,
        makeToken(@@"->"),
        makeCode { most, yieldDef, . -> {most*, yieldDef*} }),
    makeResult({formals: []}));

## Documented in spec.
def parFunctionCommon = makeMainSequence(
    parName,
    makeToken(@@"("),
    parFormalsList,
    makeToken(@@")"),
    parBasicNullaryClosure,
    makeCode { name, ., formals, ., code ->
        def basic = withName(
            withFormals(
                withYieldDef(code, "return"),
                formals),
            name);

        makeFullClosure(basic)
    });

## Documented in spec.
def parFunctionDef = makeMainSequence(
    makeToken(@@fn),
    parFunctionCommon,
    makeCode { ., closure ->
        withTop(makeVarDef(closure::name, closure))
    });

## Documented in spec.
def parMethodBind = makeMainSequence(
    makeToken(@@fn),
    parVarLvalue,
    makeToken(@@"."),
    parFunctionCommon,
    makeCode { ., bind, ., closure ->
        def formals = closure::formals;
        def name = closure::name;
        def fullClosure = withFormals(closure, [{name: "this"}, formals*]);
        makeCall(REFS::classAddMethod, bind, makeSelector(name), fullClosure)
    });

## Documented in spec.
def parImportName = makeMainChoice(
    makeSequence(
        parName,
        makeChoice(
            makeSequence(
                makeToken(@@"*"),
                makeResult("prefix")),
            makeResult("name")),
        makeToken(@@"="),
        makeCode { name, key, . -> {(key): name} }),
    makeResult({}));

## Documented in spec.
def parImportFormat = makeMainChoice(
    makeSequence(
        makeToken(@@"@"),
        parIdentifierString,
        makeCode { ., f -> {format: f::value} }),
    makeResult({}));

## Documented in spec.
def parImportSource = makeMainChoice(
    makeSequence(
        makeToken(@@"."),
        makeToken(@@"/"),
        parName,
        makeRepeat(
            makeSequence(
                makeToken(@@"/"),
                parName,
                makeCode { ., ., ., ., n -> "/".cat(n) })),
        makeRepeat(
            makeSequence(
                makeToken(@@"."),
                parName,
                makeCode { ., ., ., ., ., n -> ".".cat(n) }),
            0, 1),
        makeCode { ., ., first, rest, optSuffix ->
            def name = first.cat(rest*, optSuffix*);
            @internal{name}
        }),
    makeSequence(
        parName,
        makeRepeat(
            makeSequence(
                makeToken(@@"."),
                parName,
                makeCode { ., ., n -> ".".cat(n) })),
        makeCode { first, rest ->
            def name = first.cat(rest*);
            @external{name}
        }));

## Documented in spec.
def parImportSelect = makeMainChoice(
    makeSequence(
        makeToken(@@"::"),
        makeChoice(
            makeSequence(
                makeToken(@@"*"),
                makeResult({select: @"*"})),
            makeSequence(
                parNameList,
                makeCode { ., select -> {select} }))),
    makeResult({}));

## Documented in spec.
def parImportStatement = makeMainSequence(
    makeRepeat(makeToken(@@export), 0, 1),
    makeToken(@@import),
    parImportName,
    parImportFormat,
    parImportSource,
    parImportSelect,
    makeCode { optExport, ., nameOrPrefix, format, source, select ->
        def data = {nameOrPrefix*, format*, select*, source};
        ifIs { optExport* }
            { makeExport(makeImport(data)) }
            { makeImport(data) }
    });

## Documented in spec.
def parExportableStatement = makeMainChoice(
    parFunctionDef, parVarDef);

## Documented in spec.
def parStatement = makeMainChoice(
    parExportableStatement, parMethodBind, parVarDefMutable, parExpression);

## Documented in spec.
def parProgramStatement = makeMainChoice(
    parStatement,
    makeSequence(
        makeToken(@@export),
        makeChoice(
            makeSequence(
                parNameList,
                makeCode { ., select -> makeExportSelection(select*) }),
            makeSequence(
                parExportableStatement,
                makeCode { ., stat -> makeExport(stat) }))));

## Documented in spec.
def parClosureBody = makeMainSequence(
    makeRepeat(makeToken(@@";")),
    makeRepeat(
        makeMainSequence(
            parStatement,
            makeRepeat(makeToken(@@";"), 1),
            makeCode { s, . -> s })),
    makeChoice(
        makeMainSequence(
            parStatement,
            makeCode { s -> {statements: [s]} }),
        makeMainSequence(
            parYieldOrNonlocal,
            makeCode { y -> {statements: [], yield: y} }),
        makeResult({statements: []})),
    makeRepeat(makeToken(@@";")),
    makeCode { ., most, last, . ->
        {last*, statements: [most*, last::statements*]}
    });

## Documented in spec.
parRawClosure := makeMainSequence(
    makeToken(@@"{"),
    parClosureDeclarations,
    parClosureBody,
    makeToken(@@"}"),
    makeCode { ., decls, body, . -> {decls*, body*} });

## Documented in spec.
def parProgram = makeMainSequence(
    makeChoice(
        makeSequence(
            makeRepeat(makeToken(@@";")),
            parImportStatement,
            makeRepeat(
                makeSequence(
                    makeRepeat(makeToken(@@";"), 1),
                    parImportStatement)),
            makeCode { ., first, rest -> [first, rest*] }),
        makeResult([])),
    makeChoice(
        makeSequence(
            makeChoice(
                makeSequence(
                    makeCode { imports -> ne(imports, []) },
                    makeRepeat(makeToken(@@";"), 1)),
                makeRepeat(makeToken(@@";"))),
            parProgramStatement,
            makeRepeat(
                makeSequence(
                    makeRepeat(makeToken(@@";"), 1),
                    parProgramStatement)),
            makeCode { ., ., first, rest -> [first, rest*] }),
        makeResult([])),
    makeRepeat(makeToken(@@";")),
    makeCode { imports, body, . ->
        def closure = makeFullClosure({
            statements: [imports*, body*],
            yield:      @void
        });
        withoutTops(closure)
    });

## Documented in spec.
def parExpressionOrError = makeMainSequence(
    parExpression,
    makeRepeat(
        makeMainSequence(
            makeRepeat(any, 1),
            makeCode { pending -> reportError(pending) }),
        0, 1),
    makeCode { ex, . -> ex });

## Documented in spec.
def parProgramOrError = makeMainSequence(
    parProgram,
    makeRepeat(
        makeMainSequence(
            makeRepeat(any, 1),
            makeCode { pending -> reportError(pending) }),
        0, 1),
    makeCode { prog, . -> prog });


##
## Samizdat Layer 1 definitions
##

## `choicePex` is the top-level parsing expression node type.
def parPexChoice;

## Map from parser token types to derived value types for pexes.
def PEX_TYPES = {
    @@"&": @@lookaheadSuccess,
    @@"!": @@lookaheadFailure,
    @@"?": @@opt,
    @@"*": @@star,
    @@"+": @@plus
};

## Documented in spec.
parPexBlock := makeMainSequence(
    makeToken(@@"{:"),
    makeParserThunk { . -> parPexChoice },
    makeToken(@@":}"),
    makeCode { ., pex, . -> @parser{pex} });

## Documented in spec.
def parPexParenExpression = makeMainSequence(
    makeToken(@@"("),
    makeParserThunk { . -> parPexChoice },
    makeToken(@@")"),
    makeCode { ., pex, . -> pex });

## Parses a variable reference parsing expression.
def parPexVarRef = makeMainSequence(
    parName,
    makeCode { name -> makeVarRef(name) });

## Documented in spec.
def parPexString = makeMainSequence(makeToken(@@string));

## Documented in spec.
def parPexToken = makeMainSequence(
    makeToken(@@"@"),
    parIdentifierString,
    makeCode { ., type -> @token{value: @@(type::value)} });

## Documented in spec.
def parPexSetString = makeMainSequence(
    makeToken(@@string),
    makeChoice(
        makeSequence(
            makeToken(@@".."),
            makeToken(@@string),
            makeCode { s, ., end /out ->
                def startChar = s::value;
                def endChar = end::value;

                ## Reject non-single-character strings.
                ifIs { ne(1, startChar.get_size()) } { yield /out };
                ifIs { ne(1, endChar.get_size()) } { yield /out };

                yield "".cat(makeInclusiveRange(startChar, endChar)*)
            }),
        makeCode { s -> s::value }));

## Documented in spec.
def parPexSet = makeMainSequence(
    makeToken(@@"["),
    makeChoice(
        makeSequence(
            makeToken(@@"!"),
            makeResult(@@tokenSetComplement)),
        makeResult(@@tokenSet)),
    makeChoice(
        makeMainSequence(
            makeRepeat(parPexSetString, 1),
            makeCode { strings ->
                "".cat(strings*).collect({ ch -> @@(ch) })
            }),
        makeMainSequence(
            makeRepeat(parPexToken, 1),
            makeCode { tokens -> tokens.collect({ n -> n::value }) }),
        makeResult([])),
    makeToken(@@"]"),
    makeCode { ., type, terminals, . -> @(type){values: terminals} });

## Documented in spec.
def parPexCode = makeMainSequence(
    parNullaryClosure,
    makeCode { closure -> @code(closure.dataOf()) });


## Documented in spec.
def parPexThunk = makeMainSequence(
    makeToken(@@"%"),
    parTerm,
    makeCode { ., value -> @thunk{value} });

## Documented in spec.
def parPexTerm = makeMainChoice(
    makeSequence(
        makeToken(@@"."),
        makeResult(@any)),
    makeSequence(
        makeToken(@@"("),
        makeToken(@@")"),
        makeResult(@empty)),
    parPexVarRef,
    parPexString,
    parPexToken,
    parPexSet,
    parPexCode,
    parPexThunk,
    parPexParenExpression);

## Documented in spec.
def parPexRepeat = makeMainSequence(
    parPexTerm,
    makeChoice(
        makeSequence(
            makeTokenSet(@@"?", @@"*", @@"+"),
            makeCode { pex, repeat ->
                @(PEX_TYPES.get(get_class(repeat))){pex}
            }),
        makeCode { pex -> pex }));

## Documented in spec.
def parPexLookahead = makeMainChoice(
    makeSequence(
        makeTokenSet(@@"&", @@"!"),
        parPexRepeat,
        makeCode { lookahead, pex ->
            @(PEX_TYPES.get(get_class(lookahead))){pex}
        }),
    parPexRepeat);

## Documented in spec.
def parPexName = makeMainChoice(
    makeSequence(
        parName,
        makeToken(@@"="),
        parPexLookahead,
        makeCode { name, ., pex ->
            @varDef{name, value: pex}
        }),
    parPexLookahead);

## Documented in spec.
def parPexSequence = makeMainSequence(
    makeRepeat(parPexName, 1),
    makeCode { pexes -> @sequence{pexes} });

## Documented in spec.
parPexChoice := makeMainSequence(
    parPexSequence,
    makeRepeat(
        makeSequence(
            makeToken(@@"|"),
            parPexSequence)),
    makeCode { one, rest -> @choice{pexes: [one, rest*]} });


##
## Layer 2 Rule Stubs
##

## Documented in spec.
parOpExpression := parUnaryExpression;


##
## Exported Definitions
##

## Documented in spec.
export fn parseExpression(expression) {
    def tokens = ifIs { hasClass(expression, String) }
        { tokenize(expression) }
        { expression };

    return apply(parExpressionOrError, tokens)
};

## Documented in spec.
export fn parseProgram(program) {
    def tokens = ifIs { hasClass(program, String) }
        { tokenize(program) }
        { program };

    return apply(parProgramOrError, tokens)
};
