## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Module functions
##


##
## Private Definitions
##

## Box containing a map from fully-qualified names to modules. Each name is a
## list-of-strings denoting a "path" to the module.
def theModulesBox = Box_makeCell({});

## Box containing a map from full directory paths to corresponding modules.
## If a module is in the middle of loading, then its path maps to "loading."
def thePathsBox = Box_makeCell({});

## Flattens an absolute path to a simple name.
##
## **Note:** This function is a (low rent) duplicate of functionality in
## `Io*` modules, because this function needs to be called before the `Io*`
## modules are loaded.
fn flattenPath(name) {
    ## Prefix each component with `/`, and concatenate them all together.

    def withSlashes = collect(name, { elem <> cat("/", elem) });
    <> cat(withSlashes*);
};

## Makes a module-load global context, based on the given `baseCtx` and which
## adds submodule read and load functions that use the given `directory` (a
## structured path).
fn makeModuleContext(baseCtx, directory) {
    def flatDir = flattenPath(directory);

    ## A box for the final load context, to enable the necessary
    ## self-reference.
    def ctxBox = Box_makePromise();

    ## A box for all the loaded submodule files.
    def subsBox = Box_makeCell({});

    fn submoduleFileName(name, extension?) {
        <> ifIs { <> extension* }
            { <> cat(flatDir, "/", name, ".", extension*) }
            { <> cat(flatDir, "/", name) }
    };

    fn submoduleReadIfExists(name, extension?) {
        def path = submoduleFileName(name, extension*);
        <> ifIs { <> Io0_flatFileExists(path) }
            { <> Io0_flatReadFileUtf8(path) }
    };

    fn submoduleRead(name, extension?) {
        <> ifValueOr { <> submoduleReadIfExists(name, extension*) }
            {
                Io0_die(cat("No such module file: ",
                    submoduleFileName(name, extension*)))
            }
    };

    fn submoduleLoad(name) {
        Io0_note(cat("        ", name));
        def ctx = Box_fetch(ctxBox);

        def binName = submoduleFileName(name, "samb");
        ifIs { <> Io0_flatFileExists(binName) }
            {
                def func = Lang0_evalBinary(ctx, binName);
                return func()
            };

        def regularName = submoduleFileName(name, "sam");
        ifIs { <> Io0_flatFileExists(regularName) }
            {
                def text = Io0_flatReadFileUtf8(regularName);
                def tree = ctx::submoduleParse(text);
                def func = ctx::submoduleEval(ctx, tree);
                return func()
            };

        Io0_die(cat("Missing module file: ", regularName));
    };

    fn submoduleUse(name) {
        ifValue { <> get(Box_fetch(subsBox), name) }
            { value -> return value };

        def result = ifValueOr { <> submoduleLoad(name) }
            { <> {} };

        Box_store(subsBox, {(Box_fetch(subsBox))*, (name): result});
        <> result
    };

    ## If the `module` file exists, it must evaluate to a map. If not,
    ## create a minimal "anonymous" module definition. In either case, add
    ## an extra binding for the path to the module.
    def moduleInfo = {
        (
            ifValue { <> submoduleReadIfExists("module", "sam") }
                { moduleText ->
                    <> Lang0_eval(baseCtx, Lang0_parseExpression(moduleText))
                }
                { <> {name: [], version: "0"} }
        )*,
        path: directory
    };

    def languageName = ifValueOr { <> moduleInfo::language } { <> "Lang2" };
    def languageModule = ifIs { <> ne(languageName, "none") }
        { <> baseCtx::moduleUse({name: ["core", languageName]}) }
        {
            ## Fall-back used when loading modules before `Lang0` is defined.
            <> {
                eval:         Lang0_eval,
                parseProgram: Lang0_parseProgram
            }
        };

    def fullCtx = {
        baseCtx*,
        moduleInfo,
        submoduleEval:  languageModule::eval,
        submoduleUse,
        submoduleParse: languageModule::parseProgram,
        submoduleRead
    };

    Box_store(ctxBox, fullCtx);
    <> fullCtx
};


##
## Type Definition
##
## `Module` payload is `{info: map, exports: map}`. `info` includes at least
## `{name: [string, ...], version: string}`.

## Gets the `exports` of a module.
fn getExports(modu) {
    <> dataOf(modu)::exports
};

## Gets the `info` of a module.
fn getInfo(modu) {
    <> dataOf(modu)::info
};

## Returns a new module like the given one, except with `exports` as
## given.
fn withExports(modu, newExports) {
    <> @Module{(dataOf(modu))*, exports: newExports}
};

## Documented in spec.
fn Module_cat(modu, more*) {
    def data = dataOf(modu);

    def allExports = collect([modu, more*], getExports);
    def combinedExports = cat({}, allExports*);

    <> withExports(modu, combinedExports)
};
genericBind(cat, @@Module, Module_cat);

## Documented in spec.
fn Module_del(modu, key) {
    <> withExports(modu, Collection_del(getExports(modu), key))
};
genericBind(Collection_del, @@Module, Module_del);

## Documented in spec.
fn Module_get(modu, key) {
    <> get(getExports(modu), key)
};
genericBind(get, @@Module, Module_get);

## Documented in spec.
fn Module_keyList(modu) {
    <> Collection_keyList(getExports(modu))
};
genericBind(Collection_keyList, @@Module, Module_keyList);

## Documented in spec.
fn Module_nameOf(modu) {
    <> getInfo(modu)::name
};
genericBind(nameOf, @@Module, Module_nameOf);

## Documented in spec.
fn Module_nthMapping(modu, n) {
    <> Collection_nthMapping(getExports(modu), n)
};
genericBind(Collection_nthMapping, @@Module, Module_nthMapping);

## Documented in spec.
fn Module_put(modu, key, value) {
    <> withExports(modu, Collection_put(getExports(modu), key, value))
};
genericBind(Collection_put, @@Module, Module_put);

## Documented in spec.
fn Module_sizeOf(modu) {
    <> Collection_sizeOf(getExports(modu))
};
genericBind(Collection_sizeOf, @@Module, Module_sizeOf);


##
## Exported Definitions
##

## Documented in spec.
fn getAllModules() {
    def mods = Box_fetch(theModulesBox);
    <> collect(mods, { mod <> valueOf(mod) })
};

## Documented in spec.
fn getGlobals(modu) {
    def info = getInfo(modu);
    def bindings = ifValue { <> info::globalExports }
        { globals ->
            <> ifIs { <> eq(globals, "all") }
                {
                    ## Export all bindings.
                    <> getExports(modu)
                }
                {
                    ## Selective global export.
                    def bindings = collect(
                        globals,
                        { g <> {(g): get(modu, g)} });
                    <> cat(bindings*)
                }
        }
        { <> {} };
    def moduleBinding = ifValue { <> info::globalModuleName }
        { name <> {(name): modu} }
        { <> {} };

    <> { bindings*, moduleBinding* }
};

## Documented in spec.
fn load(baseCtx, fqPath) {
    def paths = Box_fetch(thePathsBox);
    ifValue { <> get(paths, fqPath) }
        { already ->
            ## Either the module is already loaded, or it's currently in
            ## the middle of being loaded. Figure out which, and respond
            ## accordingly.
            ifIs { <> eq(already, "loading") }
                {
                    Io0_die(cat("Module load loop detected: ",
                        flattenPath(fqPath)))
                };
            return already;
        };

    Box_store(thePathsBox, Collection_put(paths, fqPath, "loading"));

    def ctx = makeModuleContext(baseCtx, fqPath);

    ## This is supposed to evaluate to a map.
    def exports = ctx::submoduleUse("main");

    ## Combine `moduleInfo` and `exports` to form the final module value.
    def result = @Module{info: ctx::moduleInfo, exports};

    ## Update the loaded module map. Note that we re-fetch the value, since
    ## it may have been altered by other loads while this load was in progress.
    Box_store(thePathsBox,
        Collection_put(Box_fetch(thePathsBox), fqPath, result));

    <> result
};

## Documented in spec.
fn moduleDef(modu) {
    def mods = Box_fetch(theModulesBox);
    def name = nameOf(modu);
    ifIs { <> get(mods, name) }
        {
            Io0_die(cat("Cannot redefine module by name: ",
                stringFromModuleName(name)))
        };

    Box_store(theModulesBox, Collection_put(mods, name, modu));
};

## Documented in spec.
fn moduleGet(searchInfo) {
    ## TODO: Currently ignores everything about `searchInfo` other than the
    ## name and path.

    ifValue { <> searchInfo::path }
        { path -> return get(Box_fetch(thePathsBox), path) };

    ifValue { <> searchInfo::name }
        { name -> return get(Box_fetch(theModulesBox), name) };
};

## Documented in spec.
##
## **Note:** This is the early-bootstrap version of this function, which
## requires modules to be pre-defined (that is, `modulePaths` is not
## consulted).
fn moduleUse(searchInfo, modulePaths?) {
    <> ifValueOr { <> moduleGet(searchInfo) }
        {
            Io0_die(cat("Module not found: ",
                stringFromModuleName(searchInfo::name)))
        }
};

## Documented in spec.
fn stringFromModuleName(fqName) {
    ## Prefix each component with `::`, combine them all, and then drop the
    ## first two characters.
    def parts = collect(fqName, { n <> cat("::", n) });
    def result = cat(parts*);

    <> Sequence_sliceInclusive(result, 2)
};

## Documented in spec. This is a manual definition of the `Module0` module.
def Module0 = @Module{
    info: {
        name: ["core", "Module0"],
        path: [],
        version: "0.0.1"
    },
    exports: {
        getAllModules,
        getExports,
        getGlobals,
        getInfo,
        load,
        moduleDef,
        moduleGet,
        moduleUse,
        stringFromModuleName
    }
};
moduleDef(Module0);

<> {
    moduleDef,
    moduleGet,
    moduleUse
}
