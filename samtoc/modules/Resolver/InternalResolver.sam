## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Class definition: InternalResolver
##
## Payload:
## * cache -- cache of resolved results
## * nextResolver -- resolver to defer to when this one fails to resolve.
## * path -- filesystem path to a directory of internal-access files.
##

import core.Io0;
import core.LangNode;

import Reader;

import ./cache;


##
## Class Definition
##

## Secret used to control access to this class.
def SECRET = @secret.makeAnonymous();

## Class being defined here.
def InternalResolver = makeObjectClass(@InternalResolver, SECRET);

## Does direct resolution on the given `source`. Only ever called when
## `source` is known to be `internal` and so *might* be found directly
## in or under this resolver's directory.
fn directResolve(self, source) {
    def data = SECRET(self);
    def subPath = source::name;
    def basePath = "\(data::path)/\(subPath)";
    def infoPath = "\(basePath).saminfo";
    def sourcePath = "\(basePath).sam";

    return? if ($Io0::fileType(infoPath) == @file) {
        ## We found a prefab info file. Read it!
        def info = $Reader::readEvalExpression0(infoPath);
        @module{info}
    } else if ($Io0::fileType(sourcePath) == @file) {
        ## We found a source file. Read it and resolve!
        fn resolveFn(source) { return self.resolve(source) };
        def tree = $Reader::readProgram(sourcePath, resolveFn);
        def info = $LangNode::makeInfoTable(tree);
        @module{info}
    }
};

fn InternalResolver.resolve(source) {
    def data = SECRET(this);

    if (def found = $cache::cacheGet(data::cache, source)) {
        ## `found` is always a list. See comment below.
        return? found*
    };

    ## The result is always a list, so that we can cache a not-found result
    ## as the empty list.
    def result = (
        source.hasName(@internal)
            & directResolve(this, source)
            | (data::nextResolver).resolve(source)
    )?;

    ## Cache the result, so we don't bother with a search the next time.
    $cache::cachePut(data::cache, source, result);

    return? result*
};


##
## Exported Definitions
##

export fn makeInternalResolver(path, nextResolver) {
    return makeObject(InternalResolver, SECRET,
        @{
            cache: $cache::makeCache(),
            nextResolver,
            path
        })
};
