## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Type definition: ExternalResolver
##
## Payload:
## * cache -- cache of resolved results
## * nextResolver -- resolver to defer to when this one fails to resolve.
## * path -- filesystem path to a directory of modules
##

import core.Io0;

import ./cache;
import ./protocol :: resolve;


##
## Exported definitions
##

fn @@ExternalResolver.resolve(source) {
    if (!hasType(source, @@external)) {
        ## Not external, so just punt to the next one.
        return (this::nextResolver).resolve(source)
    } else if (def found = $cache::cacheGet(this::cache, source)) {
        return found
    };

    def name = dataOf(source);
    def dirPath = "\(this::path)/\(name)";
    def infoPath = "\(dirPath).saminfo";

    if (($Io0::fileType(infoPath) | "notFound") == "file") {
        ## TODO: What is says.
        note("=== would read info file: \%q(infoPath)");
    } else if (($Io0::fileType(dirPath) | "notFound") == "directory") {
        ## TODO: What is says.
        note("=== would resolve main in: \%q(dirPath)");
    };

    <> (this::nextResolver).resolve(source)
};

export fn makeExternalResolver(path, nextResolver) {
    <> @ExternalResolver{
        cache: $cache::makeCache(),
        nextResolver,
        path
    }
};
