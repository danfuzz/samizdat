## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

import core.LangNode :: *;

import CodeGen :: *;
import VarCalc :: get_varRefs;

import ./vars :: localVarDecl, localVarName;


##
## Private Definitions
##

## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = varsBox*;

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    varsBox* := {vars*, (name): binding};
    return genComment("\%q(name)", genAssign(decl, value));
};

## Wrap the given expression in a "non-void" guarantee call.
fn nonVoid(value) {
    return genCall("datNonVoid", value)
};


##
## Exported Definitions
##

## Translates a node, using and updating `varsBox` as appropriate.
export fn translate(node, varsBox) {
    return switch (def cls = get_class(node)) {
        @@apply: {
            def function = translate(node::function, varsBox);
            def values = node::values;

            if (hasClass(values, @@maybe)) {
                def vTrans = translate(values::value, varsBox);
                genCall("funApply", function, vTrans)
            } else if (hasClass(values, @@void)) {
                ## A void `values` binding just devolves into a no-argument
                ## (but otherwise regular) function call.
                genCall("FUN_CALL", function)
            } else {
                ## If it's not wrapped in a `@maybe`, we need to guarantee
                ## non-void.
                def vTrans = nonVoid(translate(values, varsBox));
                genCall("funApply", function, vTrans)
            }
        };

        @@call: {
            def values = ( a in node::values ->
                nonVoid(translate(a, varsBox))
            );
            genCall("FUN_CALL", translate(node::function, varsBox), values*)
        };

        @@closureRef: {
            ## This passes each of the `varRefs` as an argument to the
            ## closure maker.
            def vars = varsBox*;
            genCall("makeClosure_\(node::id)",
                ( name in get_varRefs(node) ->
                    vars[name]::name
                        | die("Capture of undefined variable: \%q(name)");
                )*)
        };

        @@fetch: {
            def target = nonVoid(translate(node::target, varsBox));
            genCall("METH_CALL", "fetch", target)
        };

        @@literalRef: {
            genCodeString("LIT_\(node::id)")
        };

        @@noYield: {
            def value = translate(node::value, varsBox);
            genCall("mustNotYield", value)
        };

        @@store: {
            def target = translate(node::target, varsBox);
            def value = node::value;

            if (hasClass(value, @@maybe)) {
                def vTrans = translate(value::value, varsBox);
                genCall("boxStoreNullOk", target, vTrans)
            } else if (hasClass(value, @@void)) {
                genCall("METH_CALL", "store", target)
            } else {
                ## If it's not wrapped in a `@maybe`, we need to guarantee
                ## non-void.
                def vTrans = nonVoid(translate(value, varsBox));
                genCall("METH_CALL", "store", target, vTrans)
            }
        };

        @@varDef: {
            def value = (def v = node::value)
                & genCall("makeResult", nonVoid(translate(v, varsBox)))
                | genCall("makePromise");

            varDefCommon(node::name, value, varsBox)
        };

        @@varDefMutable: {
            def value = (def v = node::value)
                & translate(v, varsBox)
                | "NULL";

            varDefCommon(
                node::name, nonVoid(genCall("makeCell", value)), varsBox)
        };

        @@varRef: {
            def name = node::name;
            def vars = varsBox*;
            def binding = vars[name]
                | die("Reference of undefined variable: \%q(node::name)");
            binding::name
        };

        ## Various untranslatable nodes. Details:
        ## * `@closure` --  Should have been replaced by a `closureRef`.
        ## * `@export*`, `@import*` -- Only needed once we move to a
        ##   non-dynamic translation of imports.
        ## * `@maybe`, `@void` -- Should have been handled as special cases
        ##   within the node types where they're explicitly valid.
        @@closure:
        @@export:
        @@exportSelection:
        @@importModule:
        @@importModuleSelection:
        @@importResource:
        @@maybe:
        @@void: {
            die("Cannot translate \(@(cls)).")
        }
    }
};


## Translates the given node as a statement. This differs from plain
## `translate` in that nodes that can't possibly have a side effect are
## dropped (returning void).
export fn translateStatement(node, varsBox) {
    return? switch (get_class(node)) {
        @@closureRef:
        @@literalRef: {
            ## Return void.
        };

        default: {
            translate(node, varsBox)
        }
    }
};
