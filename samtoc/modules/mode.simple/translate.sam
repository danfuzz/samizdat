## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

def $VarCalc = moduleLoad(["VarCalc"]);
def get_varRefs = $VarCalc::get_varRefs;

def $CodeGen = moduleLoad(["CodeGen"]);
def flatten = $CodeGen::flatten;
def indent = $CodeGen::indent;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def $Lang0Node = moduleLoad(["core", "Lang0Node"]);
def get_actuals    = $Lang0Node::get_actuals;
def get_formals    = $Lang0Node::get_formals;
def get_function   = $Lang0Node::get_function;
def get_id         = $Lang0Node::get_id;
def get_maxArgs    = $Lang0Node::get_maxArgs;
def get_minArgs    = $Lang0Node::get_minArgs;
def get_name       = $Lang0Node::get_name;
def get_statements = $Lang0Node::get_statements;
def get_nodeValue  = $Lang0Node::get_nodeValue;
def get_yield      = $Lang0Node::get_yield;
def get_yieldDef   = $Lang0Node::get_yieldDef;

def $vars = intraLoad("vars");
def localVarDecl = $vars::localVarDecl;
def localVarName = $vars::localVarName;

## `node.translate(varsBox)`: Generic function to perform the translation.
def translate = makeRegularGeneric("translate", 2, 2);


## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = fetch(varsBox);

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    store(varsBox, {vars*, (name): binding});
    <> $CodeGen::makeComment("\%q(name)", $CodeGen::makeAssign(decl, value));
};

genericBind(
    translate,
    @@apply,
    fn apply_translate(this, varsBox) {
        <> $CodeGen::makeCall("funApply",
            translate(this.function, varsBox),
            translate(this.actuals, varsBox))
    });

genericBind(
    translate,
    @@call,
    fn call_translate(this, varsBox) {
        def actuals = (a in this.actuals <> translate(a, varsBox));
        <> $CodeGen::makeCall("FUN_CALL",
            translate(this.function, varsBox), actuals*)
    });

genericBind(
    translate,
    @@closure,
    fn closure_translate(this, varsBox) {
        die("Cannot translate raw `closure` node.")
    });

genericBind(
    translate,
    @@closureRef,
    fn closureRef_translate(this, varsBox) {
        ## This passes each of the `varRefs` as an argument to the
        ## closure maker.
        def vars = fetch(varsBox);
        <> $CodeGen::makeCall("makeClosure_\(this.id)",
            ( name in this.varRefs ->
                <> vars[name]::name
                    | die("Capture of undefined variable: \%q(name)");
            )*)
    });

genericBind(
    translate,
    @@jump,
    fn call_translate(this, varsBox) {
        def value = (def v = this.nodeValue)
            & translate(v, varsBox)
            | "NULL";
        <> $CodeGen::makeCall("funJump",
            translate(this.function, varsBox), value)
    });

genericBind(
    translate,
    @@literalRef,
    fn literalRef_translate(this, varsBox) {
        <> "LIT_\(this.id)"
    });

genericBind(
    translate,
    @@varBind,
    fn varBind_translate(this, varsBox) {
        def name = this.name;
        def value = translate(this.nodeValue, varsBox);
        def vars = fetch(varsBox);
        def binding = vars[name]
            | die("Bind of undefined variable: \%q(this.name)");

        <> $CodeGen::makeCall("boxStore", binding::name, value)
    });

genericBind(
    translate,
    @@varDef,
    fn varDef_translate(this, varsBox) {
        def value = (def v = this.nodeValue)
            & $CodeGen::makeCall("makeResult", translate(v, varsBox))
            | $CodeGen::makeCall("makePromise");

        <> varDefCommon(this.name, value, varsBox)
    });

genericBind(
    translate,
    @@varDefMutable,
    fn varDefMutable_translate(this, varsBox) {
        def value = (def v = this.nodeValue)
            & translate(v, varsBox)
            | "NULL";

        <> varDefCommon(
            this.name, $CodeGen::makeCall("makeCell", value), varsBox)
    });

genericBind(
    translate,
    @@varRef,
    fn varRef_translate(this, varsBox) {
        def name = this.name;
        def vars = fetch(varsBox);
        def binding = vars[name]
            | die("Reference of undefined variable: \%q(this.name)");
        <> $CodeGen::makeCall("boxFetch", binding::name)
    });

<> {translate}
