## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

import core.LangNode :: *;

import CodeGen :: *;
import VarCalc :: get_varRefs;

import ./vars :: localVarDecl, localVarName;


##
## Private Definitions
##

## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = varsBox*;

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    varsBox* := {vars*, (name): binding};
    return genComment("\%q(name)", genAssign(decl, value));
};

## Wrap the given expression in a "non-void" guarantee call.
fn nonVoid(value) {
    return genCall("datNonVoid", value)
};


##
## Exported Definitions
##

## Translates a node, using and updating `varsBox` as appropriate.
export fn translate(node, varsBox) {
    return switch (get_type(node)) {
        @@apply: {
            def function = translate(node.function, varsBox);
            def values = node.values;

            if (hasType(values, @@maybe)) {
                def vTrans = translate(values.nodeValue, varsBox);
                genCall("funApply", function, vTrans)
            } else if (hasType(values, @@void)) {
                ## A void `values` binding just devolves into a no-argument
                ## (but otherwise regular) function call.
                genCall("FUN_CALL", function)
            } else {
                ## If it's not wrapped in a `@maybe`, we need to guarantee
                ## non-void.
                def vTrans = nonVoid(translate(values, varsBox));
                genCall("funApply", function, vTrans)
            }
        };

        @@call: {
            def values = ( a in node.values ->
                nonVoid(translate(a, varsBox))
            );
            genCall("FUN_CALL", translate(node.function, varsBox), values*)
        };

        @@closure: {
            die("Cannot translate raw `closure` node.")
        };

        @@closureRef: {
            ## This passes each of the `varRefs` as an argument to the
            ## closure maker.
            def vars = varsBox*;
            genCall("makeClosure_\(node.id)",
                ( name in node.varRefs ->
                    vars[name]::name
                        | die("Capture of undefined variable: \%q(name)");
                )*)
        };

        @@export: {
            ## This is only needed once we move to a non-dynamic translation of
            ## imports.
            die("Cannot translate `@export`.")
        };

        @@exportSelection: {
            ## This is only needed once we move to a non-dynamic translation of
            ## imports.
            die("Cannot translate `@exportSelection`.")
        };

        @@fetch: {
            def target = nonVoid(translate(node.target, varsBox));
            genCall("GFN_CALL", "fetch", target)
        };

        @@importModule: {
            ## This is only needed once we move to a non-dynamic translation of
            ## imports.
            die("Cannot translate `@importModule`.")
        };

        @@importModuleSelection: {
            ## This is only needed once we move to a non-dynamic translation of
            ## imports.
            die("Cannot translate `@importModuleSelection`.")
        };

        @@importResource: {
            ## This is only needed once we move to a non-dynamic translation of
            ## imports.
            die("Cannot translate `@importResource`.")
        };

        @@literalRef: {
            "LIT_\(node.id)"
        };

        @@maybe: {
            ## We should never encounter one of these. They should all end up
            ## getting handled as special cases on the node types where a
            ## `@maybe` is valid.
            die("Invalid use of `@maybe`.")
        };

        @@noYield: {
            def value = translate(node.nodeValue, varsBox);
            genCall("mustNotYield", value)
        };

        @@store: {
            def target = translate(node.target, varsBox);
            def value = node.nodeValue;

            if (hasType(value, @@maybe)) {
                def vTrans = translate(value.nodeValue, varsBox);
                genCall("boxStoreNullOk", target, vTrans)
            } else if (hasType(value, @@void)) {
                genCall("GFN_CALL", "store", target)
            } else {
                ## If it's not wrapped in a `@maybe`, we need to guarantee
                ## non-void.
                def vTrans = nonVoid(translate(value, varsBox));
                genCall("GFN_CALL", "store", target, vTrans)
            }
        };

        @@varDef: {
            def value = (def v = node.nodeValue)
                & genCall("makeResult", nonVoid(translate(v, varsBox)))
                | genCall("makePromise");

            varDefCommon(node.name, value, varsBox)
        };

        @@varDefMutable: {
            def value = (def v = node.nodeValue)
                & translate(v, varsBox)
                | "NULL";

            varDefCommon(
                node.name, nonVoid(genCall("makeCell", value)), varsBox)
        };

        @@varRef: {
            def name = node.name;
            def vars = varsBox*;
            def binding = vars[name]
                | die("Reference of undefined variable: \%q(node.name)");
            binding::name
        };

        @@void: {
            ## We should never encounter one of these. See `@maybe`, above.
            die("Invalid use of `@void`.")
        }
    }
};


## Translates the given node as a statement. This differs from plain
## `translate` in that nodes that can't possibly have a side effect are
## dropped (returning void).
export fn translateStatement(node, varsBox) {
    return? switch (get_type(node)) {
        @@closureRef:
        @@literalRef: {
            ## Return void.
        };

        default: {
            node.translate(varsBox)
        }
    }
};
