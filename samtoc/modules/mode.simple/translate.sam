## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

def $VarCalc = moduleLoad("VarCalc");
def get_varRefs = $VarCalc::get_varRefs;

def $CodeGen = moduleLoad("CodeGen");
def flatten = $CodeGen::flatten;
def indent = $CodeGen::indent;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def $Lang0Node = moduleLoad("core.Lang0Node");
def get_actuals    = $Lang0Node::get_actuals;
def get_formals    = $Lang0Node::get_formals;
def get_function   = $Lang0Node::get_function;
def get_id         = $Lang0Node::get_id;
def get_maxArgs    = $Lang0Node::get_maxArgs;
def get_minArgs    = $Lang0Node::get_minArgs;
def get_name       = $Lang0Node::get_name;
def get_statements = $Lang0Node::get_statements;
def get_nodeValue  = $Lang0Node::get_nodeValue;
def get_yield      = $Lang0Node::get_yield;
def get_yieldDef   = $Lang0Node::get_yieldDef;

def $vars = intraLoad("vars");
def localVarDecl = $vars::localVarDecl;
def localVarName = $vars::localVarName;

## `node.translate(varsBox)`: Generic function to perform the translation.
export fn .translate(varsBox);


## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = fetch(varsBox);

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    store(varsBox, {vars*, (name): binding});
    <> $CodeGen::makeComment("\%q(name)", $CodeGen::makeAssign(decl, value));
};

fn @@apply.translate(varsBox) {
    <> $CodeGen::makeCall("funApply",
        translate(this.function, varsBox),
        translate(this.actuals, varsBox))
};

fn @@call.translate(varsBox) {
    def actuals = (a in this.actuals <> translate(a, varsBox));
    <> $CodeGen::makeCall("FUN_CALL",
        translate(this.function, varsBox), actuals*)
};

fn @@closure.translate(varsBox) {
    die("Cannot translate raw `closure` node.")
};

fn @@closureRef.translate(varsBox) {
    ## This passes each of the `varRefs` as an argument to the
    ## closure maker.
    def vars = fetch(varsBox);
    <> $CodeGen::makeCall("makeClosure_\(this.id)",
        ( name in this.varRefs ->
            <> vars[name]::name
                | die("Capture of undefined variable: \%q(name)");
        )*)
};

fn @@importModule.translate(varsBox) {
    die("TODO: importModule.translate");
};

fn @@importModuleSelection.translate(varsBox) {
    die("TODO: importModuleSelection.translate");
};

fn @@importResource.translate(varsBox) {
    die("TODO: importResource.translate");
};

fn @@jump.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";
    <> $CodeGen::makeCall("funJump",
        translate(this.function, varsBox), value)
};

fn @@literalRef.translate(varsBox) {
    <> "LIT_\(this.id)"
};

fn @@varBind.translate(varsBox) {
    def name = this.name;
    def value = translate(this.nodeValue, varsBox);
    def vars = fetch(varsBox);
    def binding = vars[name]
        | die("Bind of undefined variable: \%q(this.name)");

    <> $CodeGen::makeCall("boxStore", binding::name, value)
};

fn @@varDef.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & $CodeGen::makeCall("makeResult", translate(v, varsBox))
        | $CodeGen::makeCall("makePromise");

    <> varDefCommon(this.name, value, varsBox)
};

fn @@varDefMutable.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";

    <> varDefCommon(
        this.name, $CodeGen::makeCall("makeCell", value), varsBox)
};

fn @@varRef.translate(varsBox) {
    def name = this.name;
    def vars = fetch(varsBox);
    def binding = vars[name]
        | die("Reference of undefined variable: \%q(this.name)");
    <> $CodeGen::makeCall("boxFetch", binding::name)
};
