## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

import core.LangNode :: *;

import CodeGen :: *;
import VarCalc :: get_varRefs;

import ./vars :: localVarDecl, localVarName;


##
## Private Definitions
##

## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = varsBox*;

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    varsBox* := {vars*, (name): binding};
    return genComment("\%q(name)", genAssign(decl, value));
};

## Wrap the given expression in a "non-void" guarantee call.
fn nonVoid(value) {
    return genCall("datNonVoid", value)
};


##
## Exported Definitions
##

## Translates a node, using and updating `varsBox` as appropriate.
export fn translate(node, varsBox) {
    return switch (node.name) {
        @apply: {
            def target = translate(node::target, varsBox);
            def name = translate(node::name, varsBox);
            def values = node::values;

            if (values.hasName(@maybe)) {
                def vTrans = translate(values::value, varsBox);
                genCall("methApply", target, name, vTrans)
            } else if (values.hasName(@void)) {
                ## A void `values` binding just devolves into a no-argument
                ## (but otherwise regular) function call.
                genMethCall(target, name)
            } else {
                ## If it's not wrapped in a `@maybe`, we need to guarantee
                ## non-void.
                def vTrans = nonVoid(translate(values, varsBox));
                genCall("methApply", target, name, vTrans)
            }
        };

        @call: {
            def target = translate(node::target, varsBox);
            def name = translate(node::name, varsBox);
            def values = ( a in node::values ->
                nonVoid(translate(a, varsBox))
            );
            genMethCall(target, name, values*)
        };

        @closureRef: {
            ## This passes each of the `varRefs` as an argument to the
            ## closure maker.
            def vars = varsBox*;
            genCall("makeClosure_\(node::id)",
                ( name in get_varRefs(node) ->
                    vars[name]::name
                        | die("Capture of undefined variable: \%q(name)");
                )*)
        };

        @fetch: {
            def target = nonVoid(translate(node::target, varsBox));
            genMethCall(target, "SYM(fetch)")
        };

        @literalRef: {
            genCodeString("LIT_\(node::id)")
        };

        @noYield: {
            def value = translate(node::value, varsBox);
            genCall("mustNotYield", value)
        };

        @store: {
            def target = translate(node::target, varsBox);
            def value = node::value;

            if (value.hasName(@maybe)) {
                def vTrans = translate(value::value, varsBox);
                genCall("cm_store", target, vTrans)
            } else if (value.hasName(@void)) {
                genMethCall(target, "SYM(store)")
            } else {
                ## If it's not wrapped in a `@maybe`, we need to guarantee
                ## non-void.
                def vTrans = nonVoid(translate(value, varsBox));
                genMethCall(target, "SYM(store)", vTrans)
            }
        };

        @varDef: {
            def value = (def v = node::value)
                & genMethCall("CLS_Result", "SYM(new)",
                    nonVoid(translate(v, varsBox)))
                | genMethCall("CLS_Promise", "SYM(new)");

            varDefCommon(node::name, value, varsBox)
        };

        @varDefMutable: {
            def optValue = ((def v = node::value) & translate(v, varsBox))?;
            varDefCommon(node::name,
                nonVoid(genMethCall("CLS_Cell", "SYM(new)", optValue*)),
                varsBox)
        };

        @varRef: {
            def name = node::name;
            def vars = varsBox*;
            def binding = vars[name]
                | die("Reference of undefined variable: \%q(node::name)");
            binding::name
        };

        ## Various untranslatable nodes. Details:
        ## * `@closure` --  Should have been replaced by a `closureRef`.
        ## * `@export*`, `@import*` -- Only needed once we move to a
        ##   non-dynamic translation of imports.
        ## * `@maybe`, `@void` -- Should have been handled as special cases
        ##   within the node types where they're explicitly valid.
        @closure:
        @export:
        @exportSelection:
        @importModule:
        @importModuleSelection:
        @importResource:
        @maybe:
        @void: {
            die("Cannot translate: \%q(node).")
        }
    }
};


## Translates the given node as a statement. This differs from plain
## `translate` in that nodes that can't possibly have a side effect are
## dropped (returning void).
export fn translateStatement(node, varsBox) {
    return? switch (node.name) {
        @closureRef:
        @literalRef: {
            ## Return void.
        };

        default: {
            translate(node, varsBox)
        }
    }
};
