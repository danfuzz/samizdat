## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

import core.Lang0Node :: *;

import CodeGen :: *;
import VarCalc :: get_varRefs;

import ./vars :: localVarDecl, localVarName;


##
## Exported Generics
##

## `node.translate(varsBox)`: Generic function to perform the translation.
export fn .translate(varsBox);


##
## Private Definitions
##

## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = fetch(varsBox);

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    store(varsBox, {vars*, (name): binding});
    <> genComment("\%q(name)", genAssign(decl, value));
};

fn @@apply.translate(varsBox) {
    def function = translate(this.function, varsBox);
    def actuals = this.actuals | @void;

    <> if (hasType(actuals, @@maybe)) {
        def acTrans = translate(actuals.nodeValue, varsBox);
        <> genCall("funApply", function, acTrans)
    } else if (hasType(actuals, @@void)) {
        ## A void `actuals` binding just devolves into a no-argument (but
        ## otherwise regular) function call.
        <> genCall("FUN_CALL", function)
    } else {
        ## If it's not wrapped in a `@maybe`, we need to guarantee
        ## non-void.
        def acTrans = translate(actuals, varsBox);
        <> genCall("funApply", function, genCall("datNonVoid", acTrans))
    }
};

fn @@call.translate(varsBox) {
    def actuals = (a in this.actuals <> translate(a, varsBox));
    <> genCall("FUN_CALL",
        translate(this.function, varsBox), actuals*)
};

fn @@closure.translate(varsBox) {
    die("Cannot translate raw `closure` node.")
};

fn @@closureRef.translate(varsBox) {
    ## This passes each of the `varRefs` as an argument to the
    ## closure maker.
    def vars = fetch(varsBox);
    <> genCall("makeClosure_\(this.id)",
        ( name in this.varRefs ->
            <> vars[name]::name
                | die("Capture of undefined variable: \%q(name)");
        )*)
};

fn @@export.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@export`.")
};

fn @@exportSelection.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@exportSelection`.")
};

fn @@importModule.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@importModule`.")
};

fn @@importModuleSelection.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@importModuleSelection`.")
};

fn @@importResource.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@importResource`.")
};

fn @@jump.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";
    <> genCall("funJump",
        translate(this.function, varsBox), value)
};

fn @@literalRef.translate(varsBox) {
    <> "LIT_\(this.id)"
};

fn @@maybe.translate(varsBox) {
    ## We should never encounter one of these. They should all end up
    ## getting handled as special cases on the node types where a `@maybe`
    ## is valid.
    die("Invalid use of `@maybe`.")
};

fn @@varBind.translate(varsBox) {
    def name = this.name;
    def value = translate(this.nodeValue, varsBox);
    def vars = fetch(varsBox);
    def binding = vars[name]
        | die("Bind of undefined variable: \%q(this.name)");

    <> genCall("boxStore", binding::name, value)
};

fn @@varDef.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & genCall("makeResult", translate(v, varsBox))
        | genCall("makePromise");

    <> varDefCommon(this.name, value, varsBox)
};

fn @@varDefMutable.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";

    <> varDefCommon(
        this.name, genCall("makeCell", value), varsBox)
};

fn @@varRef.translate(varsBox) {
    def name = this.name;
    def vars = fetch(varsBox);
    def binding = vars[name]
        | die("Reference of undefined variable: \%q(this.name)");
    <> genCall("boxFetch", binding::name)
};

fn @@void.translate(varsBox) {
    ## We should never encounter one of these. See `@maybe`, above.
    die("Invalid use of `@void`.")
};
