## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

import VarCalc :: get_varRefs;

import CodeGen;
def flatten = $CodeGen::flatten;
def indent = $CodeGen::indent;

## TODO: Replace with `import core.Lang0Node :: *`, once available.
import core.Lang0Node ::
    get_actuals,
    get_formals,
    get_function,
    get_id,
    get_maxArgs,
    get_minArgs,
    get_name,
    get_statements,
    get_nodeValue,
    get_yield,
    get_yieldDef;

import ./vars :: localVarDecl, localVarName;

## `node.translate(varsBox)`: Generic function to perform the translation.
export fn .translate(varsBox);


## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = fetch(varsBox);

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    store(varsBox, {vars*, (name): binding});
    <> $CodeGen::makeComment("\%q(name)", $CodeGen::makeAssign(decl, value));
};

fn @@apply.translate(varsBox) {
    <> $CodeGen::makeCall("funApply",
        translate(this.function, varsBox),
        translate(this.actuals, varsBox))
};

fn @@call.translate(varsBox) {
    def actuals = (a in this.actuals <> translate(a, varsBox));
    <> $CodeGen::makeCall("FUN_CALL",
        translate(this.function, varsBox), actuals*)
};

fn @@closure.translate(varsBox) {
    die("Cannot translate raw `closure` node.")
};

fn @@closureRef.translate(varsBox) {
    ## This passes each of the `varRefs` as an argument to the
    ## closure maker.
    def vars = fetch(varsBox);
    <> $CodeGen::makeCall("makeClosure_\(this.id)",
        ( name in this.varRefs ->
            <> vars[name]::name
                | die("Capture of undefined variable: \%q(name)");
        )*)
};

fn @@importModule.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("TODO: importModule.translate");
};

fn @@importModuleSelection.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("TODO: importModuleSelection.translate");
};

fn @@importResource.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("TODO: importResource.translate");
};

fn @@jump.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";
    <> $CodeGen::makeCall("funJump",
        translate(this.function, varsBox), value)
};

fn @@literalRef.translate(varsBox) {
    <> "LIT_\(this.id)"
};

fn @@varBind.translate(varsBox) {
    def name = this.name;
    def value = translate(this.nodeValue, varsBox);
    def vars = fetch(varsBox);
    def binding = vars[name]
        | die("Bind of undefined variable: \%q(this.name)");

    <> $CodeGen::makeCall("boxStore", binding::name, value)
};

fn @@varDef.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & $CodeGen::makeCall("makeResult", translate(v, varsBox))
        | $CodeGen::makeCall("makePromise");

    <> varDefCommon(this.name, value, varsBox)
};

fn @@varDefMutable.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";

    <> varDefCommon(
        this.name, $CodeGen::makeCall("makeCell", value), varsBox)
};

fn @@varRef.translate(varsBox) {
    def name = this.name;
    def vars = fetch(varsBox);
    def binding = vars[name]
        | die("Reference of undefined variable: \%q(this.name)");
    <> $CodeGen::makeCall("boxFetch", binding::name)
};
