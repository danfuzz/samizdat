## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Translate execution trees into corresponding C code.
##

import core.LangNode :: *;

import CodeGen :: *;
import VarCalc :: get_varRefs;

import ./vars :: localVarDecl, localVarName;


##
## Private Definitions
##

## Common translation code for variable definition.
fn varDefCommon(name, value, varsBox) {
    def vars = varsBox*;

    if ((def found = vars[name]) & (found::kind != "free")) {
        die("Cannot redefine local variable: \%q(name).")
    };

    def index = #vars;
    def decl = localVarDecl(name, index);
    def binding = {name: localVarName(name, index), kind: "local"};

    store(varsBox, {vars*, (name): binding});
    return genComment("\%q(name)", genAssign(decl, value));
};


##
## Exported Definitions: `translate`
##

## `node.translate(varsBox)`: Generic function to perform the translation.
export fn .translate(varsBox);

fn @@apply.translate(varsBox) {
    def function = translate(this.function, varsBox);
    def values = this.values;

    return if (hasType(values, @@maybe)) {
        def vTrans = translate(values.nodeValue, varsBox);
        genCall("funApply", function, vTrans)
    } else if (hasType(values, @@void)) {
        ## A void `values` binding just devolves into a no-argument (but
        ## otherwise regular) function call.
        genCall("FUN_CALL", function)
    } else {
        ## If it's not wrapped in a `@maybe`, we need to guarantee
        ## non-void.
        def vTrans = genCall("datNonVoid", translate(values, varsBox));
        genCall("funApply", function, vTrans)
    }
};

fn @@call.translate(varsBox) {
    def values = (a in this.values ->
        genCall("datNonVoid", translate(a, varsBox))
    );

    return genCall("FUN_CALL", translate(this.function, varsBox), values*)
};

fn @@closure.translate(varsBox) {
    die("Cannot translate raw `closure` node.")
};

fn @@closureRef.translate(varsBox) {
    ## This passes each of the `varRefs` as an argument to the
    ## closure maker.
    def vars = varsBox*;
    return genCall("makeClosure_\(this.id)",
        ( name in this.varRefs ->
            vars[name]::name
                | die("Capture of undefined variable: \%q(name)");
        )*)
};

fn @@export.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@export`.")
};

fn @@exportSelection.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@exportSelection`.")
};

fn @@fetch.translate(varsBox) {
    def target = translate(this.target, varsBox);
    return genCall("GFN_CALL", "fetch", target)
};

fn @@importModule.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@importModule`.")
};

fn @@importModuleSelection.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@importModuleSelection`.")
};

fn @@importResource.translate(varsBox) {
    ## This is only needed once we move to a non-dynamic translation of
    ## imports.
    die("Cannot translate `@importResource`.")
};

fn @@literalRef.translate(varsBox) {
    return "LIT_\(this.id)"
};

fn @@maybe.translate(varsBox) {
    ## We should never encounter one of these. They should all end up
    ## getting handled as special cases on the node types where a `@maybe`
    ## is valid.
    die("Invalid use of `@maybe`.")
};

fn @@noYield.translate(varsBox) {
    def value = translate(this.nodeValue, varsBox);
    return genCall("mustNotYield", value)
};

fn @@store.translate(varsBox) {
    def target = translate(this.target, varsBox);
    def value = this.nodeValue;

    return if (hasType(value, @@maybe)) {
        def vTrans = translate(rawValue.nodeValue, varsBox);
        genCall("boxStoreNullOk", target, vTrans)
    } else if (hasType(values, @@void)) {
        genCall("GFN_CALL", "store", target)
    } else {
        ## If it's not wrapped in a `@maybe`, we need to guarantee
        ## non-void.
        def vTrans = genCall("datNonVoid", translate(values, varsBox));
        genCall("GFN_CALL", "store", target, vTrans)
    }
};

fn @@varBox.translate(varsBox) {
    def name = this.name;
    def vars = varsBox*;
    def binding = vars[name]
        | die("Reference of undefined variable: \%q(this.name)");
    return binding::name
};

fn @@varDef.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & genCall("makeResult", translate(v, varsBox))
        | genCall("makePromise");

    return varDefCommon(this.name, value, varsBox)
};

fn @@varDefMutable.translate(varsBox) {
    def value = (def v = this.nodeValue)
        & translate(v, varsBox)
        | "NULL";

    return varDefCommon(
        this.name, genCall("makeCell", value), varsBox)
};

fn @@varFetch.translate(varsBox) {
    def name = this.name;
    def vars = varsBox*;
    def binding = vars[name]
        | die("Reference of undefined variable: \%q(this.name)");
    return genCall("GFN_CALL", "fetch", binding::name)
};

fn @@varStore.translate(varsBox) {
    def name = this.name;
    def value = translate(this.nodeValue, varsBox);
    def vars = varsBox*;
    def binding = vars[name]
        | die("Bind of undefined variable: \%q(this.name)");

    return genCall("GFN_CALL", "store", binding::name, value)
};

fn @@void.translate(varsBox) {
    ## We should never encounter one of these. See `@maybe`, above.
    die("Invalid use of `@void`.")
};


##
## Exported Definitions: `translateStatement`
##

## Translates the given node as a statement. This differs from plain
## `translate` in that nodes that can't possibly have a side effect are
## dropped (returning void).
export fn .translateStatement(varsBox);

fn @@closureRef.translateStatement(varsBox) {
    ## Return void.
};

fn @@literalRef.translateStatement(varsBox) {
    ## Return void.
};

fn @@varFetch.translateStatement(varsBox) {
    ## Return void.
};

fn Value.translateStatement(varsBox) {
    ## Use the regular `translate` for everything else.
    return this.translate(varsBox)
};
