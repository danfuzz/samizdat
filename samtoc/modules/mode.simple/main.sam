## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Compilation mode "simple" which does the simplest possible conversion of
## source into C code that *does not* rely on an interpreter when run.
##

def $CodeGen = moduleLoad(["CodeGen"]);
def flatten = $CodeGen::flatten;
def indent = $CodeGen::indent;

def $DataCode = moduleLoad(["DataCode"]);
def $Template = moduleLoad(["Template"]);

def $VarCalc = moduleLoad(["VarCalc"]);
def get_varRefs = $VarCalc::get_varRefs;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def $Lang0Node = moduleLoad(["core", "Lang0Node"]);
def get_actuals    = $Lang0Node::get_actuals;
def get_formals    = $Lang0Node::get_formals;
def get_function   = $Lang0Node::get_function;
def get_id         = $Lang0Node::get_id;
def get_maxArgs    = $Lang0Node::get_maxArgs;
def get_minArgs    = $Lang0Node::get_minArgs;
def get_name       = $Lang0Node::get_name;
def get_nodeValue  = $Lang0Node::get_nodeValue;
def get_statements = $Lang0Node::get_statements;
def get_yield      = $Lang0Node::get_yield;
def get_yieldDef   = $Lang0Node::get_yieldDef;

def $Io0   = moduleLoad(["core", "Io0"]);
def $Lang2 = moduleLoad(["core", "Lang2"]);

def collectClosures = intraLoad("collectClosures")::collectClosures;
def internLiterals  = intraLoad("internLiterals")::internLiterals;
def translate       = intraLoad("translate")::translate;
def $vars           = intraLoad("vars");

def $Interner = intraLoad("Interner");
def get_interns = $Interner::get_interns;
def intern      = $Interner::intern;

def templateText = intraReadUtf8("template.txt");


## Indent with the usual width column limit.
fn usualIndent(tree, depth) {
    <> indent(tree, depth, 78)
};

## Returns a `makeClosure_*` declaration, as a code tree.
fn closureDeclaration(cloIdx, clo, literals) {
    def varRefs = clo.varRefs;
    def decl = $CodeGen::makeCall(
        "static zvalue makeClosure_\(cloIdx)",
        ( idx in (0..), name in varRefs ->
            <> $CodeGen::makeComment(
                "\%q(name)",
                $vars::freeVarDecl(name, idx))
        )*);

    <> if (def ref = clo.name) {
        <> $CodeGen::makeComment("\%q(literals[ref.id])", decl)
    } else {
        <> decl
    }
};

## Returns a full `makeClosure_*` definition, as as string.
fn closureMaker(cloIdx, clo, literals) {
    def name = (def n = clo.name)
        & translate(n, $Box::nullBox).flatten()
        | "NULL";

    def varRefs = clo.varRefs;
    def decl = closureDeclaration(cloIdx, clo, literals);
    def stateAssigns = [ idx in (0..), name in varRefs ->
        def varName = $vars::freeVarName(name, idx);
        def stat = $CodeGen::makeStatement(
            $CodeGen::makeAssign("state[\(idx)]", varName));
        <> stat.usualIndent(1)
    ];
    def resultAssign = $CodeGen::makeAssign(
        "zvalue result",
        $CodeGen::makeCall(
            "makeBuiltin", "\(clo.minArgs)", "\(clo.maxArgs)",
            "FUN_IMPL_NAME(\(cloIdx))", "\(#varRefs)", name));

    <> "\
    \/\(decl.usualIndent(0)) {
    \/\(resultAssign.usualIndent(1));
    \/  zvalue *state = builtinGetState(result).arr;
    \/\(stateAssigns)
    \/  return result;
    \/}\n\n"
};

## Returns the statements needed to return the given `yield` value, first
## performing any given `cleanups`.
fn makeYieldStatements(yield, cleanups) {
    <> if (yield \== "NULL") {
        <> [cleanups*, $CodeGen::makeReturn(yield)]
    } else if (cleanups == []) {
        <> [$CodeGen::makeReturn(yield)]
    } else {
        <> [
            $CodeGen::makeAssign("zvalue result", yield),
            cleanups*,
            $CodeGen::makeReturn("result")
        ]
    }
};

## Returns a function definition for the code for a closure, as a string.
fn closureBody(cloIdx, clo, literals) {
    ## Set up the initial variable bindings.
    def varInfo = $vars::processVars(clo);
    def vars = varInfo::vars;
    def varNames = varInfo::names;

    ## Translate the statements and the yield. Note that the `statements`
    ## definition is a list constructor (not a generator), as its body has
    ## to run before `yield` is calculated (in order to have the correct
    ## set of vars defined in `varsBox`).

    def varsBox = $Box::makeCell(vars);
    def mainStats = [ s in clo.statements ->
        <> translate(s, varsBox)
    ];
    def yield = (def y = clo.yield)
        & translate(y, varsBox)
        | "NULL";
    def yieldStats = makeYieldStatements(yield, varInfo::cleanups);

    ## Process all the statements, producing source code.

    def allStats = [ s in [varInfo::inits*, mainStats*, yieldStats*] ->
        <> $CodeGen::makeStatement(s).usualIndent(1)
    ];

    def nameLine = (def ref = clo.name)
        & "/* \%q(literals[ref.id]) */\n"
        | "";

    <> "\
    \/\(nameLine)\
    \/static FUN_IMPL_DECL(\(cloIdx)) {
    \/  zvalue *state = builtinGetState(thisFunction).arr;
    \/\(allStats)}\n\n"
};

## Constructs the top-level closure. This is similar to translating a
## `@closureRef` node, except that the closure state is initialized from
## the global environment and not from local or captured variables.
fn mainClosureMaker(node, interner) {
    def varRefs = node.varRefs;
    def ids = [ name in varRefs <> interner.intern(name) ];

    def stat = $CodeGen::makeStatement(
        $CodeGen::makeReturn(
            $CodeGen::makeCall("makeClosure_\(node.id)",
                ( name in varRefs, id in ids ->
                    <> $CodeGen::makeComment("\%q(name)",
                        $CodeGen::makeCall("makeResult",
                            $CodeGen::makeCall("get",
                                "GLOBALS", "LIT_\(id)")))
                )*)));

    <> stat.usualIndent(1)
};

fn compile(sourcePath, targetPath) {
    def sourceText = $Io0::readFileUtf8(sourcePath);

    ## Note: The node resulting from a call to `parseProgram` is always of
    ## type `closure`.
    def mainNode = $Lang2::convertToLang0($Lang2::parseProgram(sourceText));

    def interner = $Interner::makeInterner();
    def litsNode = internLiterals(mainNode, interner);
    def partialLits = interner.interns; ## Needed for closure declarations.

    def closuresNode = collectClosures(litsNode);
    def closures = closuresNode::closures;
    def closureDeclarations = cat(
        ( idx in (0..), clo in closures ->
            def stat = $CodeGen::makeStatement(
                closureDeclaration(idx, clo, partialLits));
            <> "\(stat.usualIndent(0))\n"
        )*);
    def closureMakers = cat(
        ( idx in (0..), clo in closures ->
            <> closureMaker(idx, clo, partialLits)
        )*);
    def closureBodies = cat(
        ( idx in (0..), clo in closures ->
            <> closureBody(idx, clo, partialLits)
        )*);
    def mainClosure = mainClosureMaker(closuresNode::node, interner);

    def literals = interner.interns;
    def literalDeclarations = cat(
        ( index in (0..!#literals) ->
            <> "static zvalue LIT_\(index) = NULL;\n"
        )*);
    def literalInits = cat(
        ( index in (0..), lit in literals ->
            def init = $CodeGen::makeStatement(
                $CodeGen::makeCall("datImmortalize",
                    $CodeGen::makeAssign("LIT_\(index)",
                        $DataCode::convert(lit))));
            <> init.usualIndent(2)
        )*);

    def replacements = {
        closureBodies,
        closureDeclarations,
        closureMakers,
        literalDeclarations,
        literalInits,
        mainClosure
    };

    def outputText = $Template::apply(templateText, replacements);

    $Io0::writeFileUtf8(targetPath, outputText)
};

<> {compile}
