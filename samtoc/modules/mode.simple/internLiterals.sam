## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import VarCalc :: get_varRefs;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
import core.Lang0Node;
def get_actuals    = $Lang0Node::get_actuals;
def get_formals    = $Lang0Node::get_formals;
def get_format     = $Lang0Node::get_format;
def get_function   = $Lang0Node::get_function;
def get_id         = $Lang0Node::get_id;
def get_maxArgs    = $Lang0Node::get_maxArgs;
def get_minArgs    = $Lang0Node::get_minArgs;
def get_name       = $Lang0Node::get_name;
def get_nodeValue  = $Lang0Node::get_nodeValue;
def get_source     = $Lang0Node::get_source;
def get_statements = $Lang0Node::get_statements;
def get_yield      = $Lang0Node::get_yield;
def get_yieldDef   = $Lang0Node::get_yieldDef;

import ./Interner;
def intern = $Interner::intern;

## `node.lits(interner)`, implements one layer of literal interning.
fn .lits(interner);

fn @@apply.lits(interner) {
    <> @apply{
        function: lits(this.function, interner),
        actuals: lits(this.actuals, interner)
    }
};

fn @@call.lits(interner) {
    <> @call{
        function: lits(this.function, interner),
        actuals: [ a in this.actuals <> lits(a, interner) ]
    }
};

fn @@closure.lits(interner) {
    def name = (def value = this.name)
        & {name: lits(@literal{value}, interner)}
        | {};

    <> @closure{
        name*,
        formals: this.formals,
        statements: [ s in this.statements <> lits(s, interner) ],
        ((def y = this.yield) & {yield: lits(y, interner)} | {})*,
        ((def yieldDef = this.yieldDef) & {yieldDef} | {})*
    }
};

## Bound as the `source` in `import*` nodes.
fn @@external.lits(interner) {
    <> @external(interner.intern(dataOf(this)))
};

fn @@importModule.lits(interner) {
    def source = lits(this.source, interner);
    <> @importModule{dataOf(this)*, source}
};

fn @@importModuleSelection.lits(interner) {
    def source = lits(this.source, interner);
    <> @importModuleSelection{dataOf(this)*, source}
};

fn @@importResource.lits(interner) {
    def source = lits(this.source, interner);
    def format = interner.intern(this.format);
    <> @importResource{dataOf(this)*, source, format}
};

## Bound as the `source` in `import*` nodes.
fn @@internal.lits(interner) {
    <> @internal(interner.intern(dataOf(this)))
};

fn @@jump.lits(interner) {
    def function = lits(this.function, interner);
    def optValue = (def v = this.nodeValue)
        & {value: lits(v, interner)}
        | {};

    <> @jump{function, optValue*}
};

fn @@literal.lits(interner) {
    <> @literalRef{id: interner.intern(this.nodeValue)}
};

fn @@varBind.lits(interner) {
    <> @varBind{
        name: this.name,
        value: lits(this.nodeValue, interner)
    }
};

fn @@varDef.lits(interner) {
    def value = ifValue { <> this.nodeValue }
        { value <> {value: lits(value, interner)} }
        { <> {} };
    <> @varDef{name: this.name, value*}
};

fn @@varDefMutable.lits(interner) {
    def value = ifValue { <> this.nodeValue }
        { value <> {value: lits(value, interner)} }
        { <> {} };
    <> @varDefMutable{name: this.name, value*}
};

fn @@varRef.lits(interner) {
    <> this
};

## Interns all literal nodes at or under the given `node`, into the given
## `interner`. Returns a replacement for the original `node` argument, in
## which literals have been replaced by indexed references to same.
export fn internLiterals(node, interner) {
    <> lits(node, interner);
};
