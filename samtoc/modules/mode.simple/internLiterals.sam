## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def $VarCalc = moduleLoad(["VarCalc"]);
def get_varRefs = $VarCalc::get_varRefs;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def $Lang0Node = moduleLoad(["core", "Lang0Node"]);
def get_actuals    = $Lang0Node::get_actuals;
def get_formals    = $Lang0Node::get_formals;
def get_function   = $Lang0Node::get_function;
def get_id         = $Lang0Node::get_id;
def get_maxArgs    = $Lang0Node::get_maxArgs;
def get_minArgs    = $Lang0Node::get_minArgs;
def get_name       = $Lang0Node::get_name;
def get_nodeValue  = $Lang0Node::get_nodeValue;
def get_statements = $Lang0Node::get_statements;
def get_yield      = $Lang0Node::get_yield;
def get_yieldDef   = $Lang0Node::get_yieldDef;

def $Interner = intraLoad("Interner");
def intern = $Interner::intern;

## `node.lits(interner)`, implements one layer of literal interning.
def lits = makeRegularGeneric("lits", 2, 2);

genericBind(
    lits,
    @@apply,
    fn apply_lits(this, interner) {
        <> @apply{
            function: lits(this.function, interner),
            actuals: lits(this.actuals, interner)
        }
    });

genericBind(
    lits,
    @@call,
    fn call_lits(this, interner) {
        <> @call{
            function: lits(this.function, interner),
            actuals: [ a in this.actuals <> lits(a, interner) ]
        }
    });

genericBind(
    lits,
    @@closure,
    fn closure_lits(this, interner) {
        def name = (def value = this.name)
            & {name: lits(@literal{value}, interner)}
            | {};

        <> @closure{
            name*,
            formals: this.formals,
            statements: [ s in this.statements <> lits(s, interner) ],
            ((def y = this.yield) & {yield: lits(y, interner)} | {})*,
            ((def yieldDef = this.yieldDef) & {yieldDef} | {})*
        }
    });

genericBind(
    lits,
    @@jump,
    fn jump_lits(this, interner) {
        def function = lits(this.function, interner);
        def optValue = (def v = this.nodeValue)
            & {value: lits(v, interner)}
            | {};

        <> @jump{function, optValue*}
    });

genericBind(
    lits,
    @@literal,
    fn literal_lits(this, interner) {
        <> @literalRef{id: interner.intern(this.nodeValue)}
    });

genericBind(
    lits,
    @@varBind,
    fn varBind_lits(this, interner) {
        <> @varBind{
            name: this.name,
            value: lits(this.nodeValue, interner)
        }
    });

genericBind(
    lits,
    @@varDef,
    fn varDef_lits(this, interner) {
        def value = ifValue { <> this.nodeValue }
            { value <> {value: lits(value, interner)} }
            { <> {} };
        <> @varDef{name: this.name, value*}
    });

genericBind(
    lits,
    @@varDefMutable,
    fn varDefMutable_lits(this, interner) {
        def value = ifValue { <> this.nodeValue }
            { value <> {value: lits(value, interner)} }
            { <> {} };
        <> @varDefMutable{name: this.name, value*}
    });

genericBind(
    lits,
    @@varRef,
    fn varRef_lits(this, interner) {
        <> this
    });

## Interns all literal nodes at or under the given `node`, into the given
## `interner`. Returns a replacement for the original `node` argument, in
## which literals have been replaced by indexed references to same.
fn internLiterals(node, interner) {
    <> lits(node, interner);
};

<> {internLiterals}
