## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import core.LangNode :: *;

import VarCalc :: get_varRefs;



##
## Private Definitions
##

## Does one layer of body collection.
fn bodies(node, bodiesBox) {
    return switch (def cls = get_class(node)) {
        @@apply: {
            def function = bodies(node.function, bodiesBox);
            def values = bodies(node.values, bodiesBox);

            @apply{values, function}
        };

        @@call: {
            def function = bodies(node.function, bodiesBox);
            def values = [ a in node.values -> bodies(a, bodiesBox) ];
            @call{function, values}
        };

        @@closure: {
            def statements = [ s in node.statements -> bodies(s, bodiesBox) ];
            def yieldNode = bodies(node.yieldNode, bodiesBox);
            def varRefs = node.varRefs;

            def newNode = makeFullClosure({
                formals: node::formals,
                ((def name = node::name) & {name} | {})*,
                statements,
                varRefs,
                yield: yieldNode,
                ((def yieldDef = node.yieldDef) & {yieldDef} | {})*
            });

            def bodies = bodiesBox*;
            if (def already = bodies[newNode]) {
                return already
            };

            def result = @closureRef{id: #bodies, varRefs};
            bodiesBox* := {bodies*, (newNode): result};
            result
        };

        @@fetch: {
            def target = bodies(node.target, bodiesBox);
            @fetch{target}
        };

        @@store: {
            def target = bodies(node.target, bodiesBox);
            def value = bodies(node::value, bodiesBox);
            @store{target, value}
        };

        @@varDef:
        @@varDefMutable: {
            def value = ifValue { node::value }
                { value -> {value: bodies(value, bodiesBox)} }
                { {} };
            @(cls){name: node::name, value*}
        };

        @@export:
        @@maybe:
        @@noYield: {
            def value = bodies(node::value, bodiesBox);
            @(cls){value}
        };

        @@exportSelection:
        @@importModule:
        @@importModuleSelection:
        @@importResource:
        @@literalRef:
        @@varRef:
        @@void: {
            node
        }
    }
};


##
## Exported Definitions
##

## Collects all closure nodes at or under the given one into a list.
## Returns `{closures, node}`, where `closures` is a list of collected
## closures and `node` is a replacement for the original argument, in which
## `closure` nodes have been replaced by indexed closure references.
export fn collectClosures(node) {
    var bodiesMap = {};
    def newNode = bodies(node, var bodiesMap);

    def bodiesBoxList = [ for #bodiesMap -> def result; (var result) ];
    for (body in bodiesMap) {
        def index = get_value(body)::id;
        bodiesBoxList[index]* := get_key(body)
    };
    def closures = [ box in bodiesBoxList -> box* ];

    return { closures, node: newNode }
};
