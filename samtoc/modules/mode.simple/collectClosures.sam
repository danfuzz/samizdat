## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import core.LangNode :: *;

import VarCalc :: get_varRefs;



##
## Private Definitions
##

## `node.bodies(bodiesBox)`, implements one layer of body collection.
fn .bodies(bodiesBox);

fn @@apply.bodies(bodiesBox) {
    def function = bodies(this.function, bodiesBox);
    def values = bodies(this.values, bodiesBox);

    return @apply{values, function}
};

fn @@call.bodies(bodiesBox) {
    def function = bodies(this.function, bodiesBox);
    def values = [ a in this.values -> bodies(a, bodiesBox) ];
    return @call{function, values}
};

fn @@closure.bodies(bodiesBox) {
    def statements = [ s in this.statements -> bodies(s, bodiesBox) ];
    def yieldNode = bodies(this.yieldNode, bodiesBox);
    def varRefs = this.varRefs;

    def newNode = makeFullClosure({
        formals: this.formals,
        ((def name = this.name) & {name} | {})*,
        statements,
        varRefs,
        yield: yieldNode,
        ((def yieldDef = this.yieldDef) & {yieldDef} | {})*
    });

    def bodies = bodiesBox*;
    if (def already = bodies[newNode]) {
        return already
    };

    def result = @closureRef{id: #bodies, varRefs};
    store(bodiesBox, {bodies*, (newNode): result});
    return result
};

fn @@export.bodies(bodiesBox) {
    def value = bodies(this.nodeValue, bodiesBox);
    return @export{value}
};

fn @@exportSelection.bodies(bodiesBox) {
    return this
};

fn @@fetch.bodies(bodiesBox) {
    def value = bodies(this.nodeValue, bodiesBox);
    return @fetch{value}
};

fn @@importModule.bodies(bodiesBox) {
    return this
};

fn @@importModuleSelection.bodies(bodiesBox) {
    return this
};

fn @@importResource.bodies(bodiesBox) {
    return this
};

fn @@literalRef.bodies(bodiesBox) {
    return this
};

fn @@maybe.bodies(bodiesBox) {
    def value = bodies(this.nodeValue, bodiesBox);
    return @maybe{value}
};

fn @@noYield.bodies(bodiesBox) {
    def value = bodies(this.nodeValue, bodiesBox);
    return @noYield{value}
};

fn @@varBox.bodies(bodiesBox) {
    return this
};

fn @@varDef.bodies(bodiesBox) {
    def value = ifValue { this.nodeValue }
        { value -> {value: bodies(value, bodiesBox)} }
        { {} };
    return @varDef{name: this.name, value*}
};

fn @@varDefMutable.bodies(bodiesBox) {
    def value = ifValue { this.nodeValue }
        { value -> {value: bodies(value, bodiesBox)} }
        { {} };
    return @varDefMutable{name: this.name, value*}
};

fn @@varFetch.bodies(bodiesBox) {
    return @varFetch{name: this.name}
};

fn @@varStore.bodies(bodiesBox) {
    def value = bodies(this.nodeValue, bodiesBox);
    return @varStore{name: this.name, value}
};

fn @@void.bodies(bodiesBox) {
    return this
};


##
## Exported Definitions
##

## Collects all closure nodes at or under the given one into a list.
## Returns `{closures, node}`, where `closures` is a list of collected
## closures and `node` is a replacement for the original argument, in which
## `closure` nodes have been replaced by indexed closure references.
export fn collectClosures(node) {
    def bodiesBox = $Box::makeCell({});
    def newNode = bodies(node, bodiesBox);
    def bodiesMap = bodiesBox*;

    def bodiesBoxList = [ for #bodiesMap -> $Box::makePromise() ];
    for (body in bodiesMap) {
        def index = get_value(body)::id;
        store(bodiesBoxList[index], get_key(body))
    };
    def closures = [ box in bodiesBoxList -> box* ];

    return { closures, node: newNode }
};
