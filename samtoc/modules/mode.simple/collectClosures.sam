## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def VarCalc = moduleLoad(["VarCalc"]);
def get_varRefs = VarCalc::get_varRefs;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def Lang0Node = moduleLoad(["core", "Lang0Node"]);
def get_actuals    = Lang0Node::get_actuals;
def get_formals    = Lang0Node::get_formals;
def get_function   = Lang0Node::get_function;
def get_id         = Lang0Node::get_id;
def get_maxArgs    = Lang0Node::get_maxArgs;
def get_minArgs    = Lang0Node::get_minArgs;
def get_nodeName   = Lang0Node::get_nodeName;
def get_statements = Lang0Node::get_statements;
def get_value      = Lang0Node::get_value;
def get_yield      = Lang0Node::get_yield;
def get_yieldDef   = Lang0Node::get_yieldDef;

## `bodies(node, bodiesBox)`, implements one layer of body collection.
def bodies = makeRegularGeneric("bodies", 2, 2);

genericBind(
    bodies,
    @@apply,
    fn apply_bodies(node, bodiesBox) {
        def function = bodies(node.function, bodiesBox);
        def actuals = bodies(node.actuals, bodiesBox);
        <> @apply{function, actuals}
    });

genericBind(
    bodies,
    @@call,
    fn call_bodies(node, bodiesBox) {
        def function = bodies(node.function, bodiesBox);
        def actuals = [ a in node.actuals <> bodies(a, bodiesBox) ];
        <> @call{function, actuals}
    });

genericBind(
    bodies,
    @@closure,
    fn closure_bodies(node, bodiesBox) {
        def statements = [ s in node.statements <> bodies(s, bodiesBox) ];
        def optYield = ((def y = node.yield) & bodies(y, bodiesBox))?;
        def varRefs = node.varRefs;

        def newNode = @closure{
            formals: node.formals,
            ((def name = node.nodeName) & {name} | {})*,
            statements,
            varRefs,
            ((def yield = optYield*) & {yield} | {})*,
            ((def yieldDef = node.yieldDef) & {yieldDef} | {})*
        };

        def bodies = fetch(bodiesBox);
        if (def already = bodies[newNode]) {
            return already
        };

        def result = @closureRef{id: #bodies, varRefs};
        store(bodiesBox, {bodies*, (newNode): result});
        <> result
    });

genericBind(
    bodies,
    @@jump,
    fn jump_bodies(node, bodiesBox) {
        def function = bodies(node.function, bodiesBox);
        def optValue = (def v = node.value)
            & {value: bodies(v, bodiesBox)}
            | {};

        <> @jump{function, optValue*}
    });

genericBind(
    bodies,
    @@literalRef,
    fn literalRef_bodies(node, bodiesBox) {
        <> node
    });

genericBind(
    bodies,
    @@varBind,
    fn varBind_bodies(node, bodiesBox) {
        def value = bodies(node.value, bodiesBox);
        <> @varBind{name: node.nodeName, value}
    });

genericBind(
    bodies,
    @@varDef,
    fn varDef_bodies(node, bodiesBox) {
        def value = ifValue { <> node.value }
            { value <> {value: bodies(value, bodiesBox)} }
            { <> {} };
        <> @varDef{name: node.nodeName, value*}
    });

genericBind(
    bodies,
    @@varDefMutable,
    fn varDefMutable_bodies(node, bodiesBox) {
        def value = ifValue { <> node.value }
            { value <> {value: bodies(value, bodiesBox)} }
            { <> {} };
        <> @varDefMutable{name: node.nodeName, value*}
    });

genericBind(
    bodies,
    @@varRef,
    fn varRef_bodies(node, bodiesBox) {
        <> @varRef{name: node.nodeName}
    });

## Collects all closure nodes at or under the given one into a list.
## Returns `{closures, node}`, where `closures` is a list of collected
## closures and `node` is a replacement for the original argument, in which
## `closure` nodes have been replaced by indexed closure references.
fn collectClosures(node) {
    def bodiesBox = Box::makeCell({});
    def newNode = bodies(node, bodiesBox);
    def bodiesMap = fetch(bodiesBox);

    def bodiesBoxList = [ for #bodiesMap <> Box::makePromise() ];
    for (body in bodiesMap) {
        def index = valueOf(body)::id;
        store(bodiesBoxList[index], keyOf(body))
    };
    def closures = [ box in bodiesBoxList <> fetch(box) ];

    <> { closures, node: newNode }
};

<> collectClosures
