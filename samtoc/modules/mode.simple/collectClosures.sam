## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def $VarCalc = moduleLoad(["VarCalc"]);
def get_varRefs = $VarCalc::get_varRefs;

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def $Lang0Node = moduleLoad(["core", "Lang0Node"]);
def get_actuals    = $Lang0Node::get_actuals;
def get_formals    = $Lang0Node::get_formals;
def get_function   = $Lang0Node::get_function;
def get_id         = $Lang0Node::get_id;
def get_maxArgs    = $Lang0Node::get_maxArgs;
def get_minArgs    = $Lang0Node::get_minArgs;
def get_name       = $Lang0Node::get_name;
def get_nodeValue  = $Lang0Node::get_nodeValue;
def get_statements = $Lang0Node::get_statements;
def get_yield      = $Lang0Node::get_yield;
def get_yieldDef   = $Lang0Node::get_yieldDef;

## `node.bodies(bodiesBox)`, implements one layer of body collection.
fn .bodies(bodiesBox);

fn @@apply.bodies(bodiesBox) {
    def function = bodies(this.function, bodiesBox);
    def actuals = bodies(this.actuals, bodiesBox);
    <> @apply{function, actuals}
};

fn @@call.bodies(bodiesBox) {
    def function = bodies(this.function, bodiesBox);
    def actuals = [ a in this.actuals <> bodies(a, bodiesBox) ];
    <> @call{function, actuals}
};

fn @@closure.bodies(bodiesBox) {
    def statements = [ s in this.statements <> bodies(s, bodiesBox) ];
    def optYield = ((def y = this.yield) & bodies(y, bodiesBox))?;
    def varRefs = this.varRefs;

    def newNode = @closure{
        formals: this.formals,
        ((def name = this.name) & {name} | {})*,
        statements,
        varRefs,
        ((def yield = optYield*) & {yield} | {})*,
        ((def yieldDef = this.yieldDef) & {yieldDef} | {})*
    };

    def bodies = fetch(bodiesBox);
    if (def already = bodies[newNode]) {
        return already
    };

    def result = @closureRef{id: #bodies, varRefs};
    store(bodiesBox, {bodies*, (newNode): result});
    <> result
};

fn @@jump.bodies(bodiesBox) {
    def function = bodies(this.function, bodiesBox);
    def optValue = (def v = this.nodeValue)
        & {value: bodies(v, bodiesBox)}
        | {};

    <> @jump{function, optValue*}
};

fn @@literalRef.bodies(bodiesBox) {
    <> this
};

fn @@varBind.bodies(bodiesBox) {
    def value = bodies(this.nodeValue, bodiesBox);
    <> @varBind{name: this.name, value}
};

fn @@varDef.bodies(bodiesBox) {
    def value = ifValue { <> this.nodeValue }
        { value <> {value: bodies(value, bodiesBox)} }
        { <> {} };
    <> @varDef{name: this.name, value*}
};

fn @@varDefMutable.bodies(bodiesBox) {
    def value = ifValue { <> this.nodeValue }
        { value <> {value: bodies(value, bodiesBox)} }
        { <> {} };
    <> @varDefMutable{name: this.name, value*}
};

fn @@varRef.bodies(bodiesBox) {
    <> @varRef{name: this.name}
};

## Collects all closure nodes at or under the given one into a list.
## Returns `{closures, node}`, where `closures` is a list of collected
## closures and `node` is a replacement for the original argument, in which
## `closure` nodes have been replaced by indexed closure references.
fn collectClosures(node) {
    def bodiesBox = $Box::makeCell({});
    def newNode = bodies(node, bodiesBox);
    def bodiesMap = fetch(bodiesBox);

    def bodiesBoxList = [ for #bodiesMap <> $Box::makePromise() ];
    for (body in bodiesMap) {
        def index = get_value(body)::id;
        store(bodiesBoxList[index], get_key(body))
    };
    def closures = [ box in bodiesBoxList <> fetch(box) ];

    <> { closures, node: newNode }
};

<> {collectClosures}
