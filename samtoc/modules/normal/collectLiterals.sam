# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def Lang0Node = moduleUse({name: ["Lang0Node"]});

# TODO: Ought to be able to do something like:
#     use Lang0Node *;
def getActuals    = Lang0Node::getActuals;
def getExpression = Lang0Node::getExpression;
def getFormals    = Lang0Node::getFormals;
def getFunction   = Lang0Node::getFunction;
def getName       = Lang0Node::getName;
def getStatements = Lang0Node::getStatements;
def getValue      = Lang0Node::getValue;
def getYield      = Lang0Node::getYield;
def getYieldDef   = Lang0Node::getYieldDef;

# `lits(node, resultBox)`, implements one layer of literal collection.
def lits = makeRegularGeneric("lits", 2, 2);

fn call_lits(node, resultBox) {
    lits(getFunction(node), resultBox);
    for (n in getActuals(node)) { lits(n, resultBox) };
};
genericBind(lits, "call", call_lits);

fn closure_lits(node, resultBox) {
    for (n in getStatements(node)) { lits(n, resultBox) };
    lits(getYield(node), resultBox);
};
genericBind(lits, "closure", closure_lits);

fn expression_lits(node, resultBox) {
    lits(getExpression(node), resultBox);
};
genericBind(lits, "expression", expression_lits);

fn fnDef_lits(node, resultBox) {
    for (n in getStatements(node)) { lits(n, resultBox) };
    (y := getYield(node))
        & lits(y, resultBox);
};
genericBind(lits, "fnDef", fnDef_lits);

fn interpolate_lits(node, resultBox) {
    lits(getExpression(node), resultBox);
};
genericBind(lits, "interpolate", interpolate_lits);

fn literal_lits(node, resultBox) {
    def value = getValue(node);
    def result = Box::fetch(resultBox);

    if (!result[value]) {
        Box::store(resultBox, { result*, (value): Collection::sizeOf(result) });
    };
};
genericBind(lits, "literal", literal_lits);

fn varDef_lits(node, resultBox) {
    lits(getValue(node), resultBox);
};
genericBind(lits, "varDef", varDef_lits);

fn varRef_lits(node, resultBox) {
    # Nothing to do.
};
genericBind(lits, "varRef", varRef_lits);

fn voidable_lits(node, resultBox) {
    lits(getExpression(node), resultBox);
};
genericBind(lits, "voidable", voidable_lits);

# Collects all literal nodes at or under the given one into a map
# from literal value to index (zero-based).
fn collectLiterals(node) {
    def resultBox = Box::makeCell({});
    lits(node, resultBox);
    <> Box::fetch(resultBox)
};

<> collectLiterals
