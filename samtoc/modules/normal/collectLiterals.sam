## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def Lang0Node = moduleUse({name: ["Lang0Node"]});

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def get_actuals    = Lang0Node::get_actuals;
def get_formals    = Lang0Node::get_formals;
def get_function   = Lang0Node::get_function;
def get_name       = Lang0Node::get_name;
def get_repeat     = Lang0Node::get_repeat;
def get_statements = Lang0Node::get_statements;
def get_value      = Lang0Node::get_value;
def get_yield      = Lang0Node::get_yield;
def get_yieldDef   = Lang0Node::get_yieldDef;

## `lits(node, litsBox)`, implements one layer of literal collection.
def lits = makeRegularGeneric("lits", 2, 2);

genericBind(
    lits,
    "call",
    fn call_lits(node, litsBox) {
        <> @call{
            function: lits(node.function, litsBox),
            actuals: [ a in node.actuals <> lits(a, litsBox) ]
        }
    });

genericBind(
    lits,
    "closure",
    fn closure_lits(node, litsBox) {
        <> @closure{
            formals: node.formals,
            ((def name = node.name) & {name} | {})*,
            statements: [ s in node.statements <> lits(s, litsBox) ],
            ((def y = node.yield) & {yield: lits(y, litsBox)} | {})*,
            ((def yieldDef = node.yieldDef) & {yieldDef} | {})*
        }
    });

genericBind(
    lits,
    "expression",
    fn expression_lits(node, litsBox) {
        <> @expression{value: lits(node.value, litsBox)}
    });

genericBind(
    lits,
    "interpolate",
    fn interpolate_lits(node, litsBox) {
        <> @interpolate{value: lits(node.value, litsBox)}
    });

genericBind(
    lits,
    "literal",
    fn literal_lits(node, litsBox) {
        def value = node.value;
        def lits = Box::fetch(litsBox);

        if (def already = lits[value]) {
            return already;
        };

        def result = @literalRef{id: #lits};
        Box::store(litsBox, {lits*, (value): result});
        <> result
    });

genericBind(
    lits,
    "varBind",
    fn varBind_lits(node, litsBox) {
        <> @varBind{
            name: node.name,
            value: lits(node.value, litsBox)
        }
    });

genericBind(
    lits,
    "varDeclare",
    fn varDeclare_lits(node, litsBox) {
        <> node
    });

genericBind(
    lits,
    "varDef",
    fn varDef_lits(node, litsBox) {
        <> @varDef{
            name: node.name,
            value: lits(node.value, litsBox)
        }
    });

genericBind(
    lits,
    "varRef",
    fn varRef_lits(node, litsBox) {
        <> node
    });

genericBind(
    lits,
    "voidable",
    fn voidable_lits(node, litsBox) {
        <> @voidable{value: lits(node.value, litsBox)}
    });

## Collects all literal nodes at or under the given one into a list.
## Returns `{literals, node}`, where `literals` is a list of collected
## literals and `node` is a replacement for the original argument, in which
## literals have been replaced by indexed references to same.
fn collectLiterals(node) {
    def litsBox = Box::makeCell({});
    def newNode = lits(node, litsBox);
    def literalsMap = Box::fetch(litsBox);

    def litsBoxList = [ n in (0..#literalsMap) <> Box::makePromise() ];
    for (l in literalsMap) {
        def index = dataOf(valueOf(l))::id;
        Box::store(litsBoxList[index], keyOf(l))
    };
    def literals = [ box in litsBoxList <> Box::fetch(box) ];

    <> { literals, node: newNode }
};

<> collectLiterals
