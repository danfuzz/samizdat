# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def Lang0Node = moduleUse({name: ["Lang0Node"]});

# TODO: Ought to be able to do something like:
#     use Lang0Node *;
def get actuals    = Lang0Node::get actuals;
def get expression = Lang0Node::get expression;
def get formals    = Lang0Node::get formals;
def get function   = Lang0Node::get function;
def get name       = Lang0Node::get name;
def get statements = Lang0Node::get statements;
def get value      = Lang0Node::get value;
def get yield      = Lang0Node::get yield;
def get yieldDef   = Lang0Node::get yieldDef;

# `lits(node, resultBox)`, implements one layer of literal collection.
def lits = makeRegularGeneric("lits", 2, 2);

fn call_lits(node, resultBox) {
    lits(node.function, resultBox);
    for (n in node.actuals) { lits(n, resultBox) };
};
genericBind(lits, "call", call_lits);

fn closure_lits(node, resultBox) {
    for (n in node.statements) { lits(n, resultBox) };
    lits(node.yield, resultBox);
};
genericBind(lits, "closure", closure_lits);

fn expression_lits(node, resultBox) {
    lits(node.expression, resultBox);
};
genericBind(lits, "expression", expression_lits);

fn fnDef_lits(node, resultBox) {
    for (n in node.statements) { lits(n, resultBox) };
    (def y = node.yield)
        & lits(y, resultBox);
};
genericBind(lits, "fnDef", fnDef_lits);

fn interpolate_lits(node, resultBox) {
    lits(node.expression, resultBox);
};
genericBind(lits, "interpolate", interpolate_lits);

fn literal_lits(node, resultBox) {
    def value = node.value;
    def result = Box::fetch(resultBox);

    if (!result[value]) {
        Box::store(resultBox, { result*, (value): Collection::sizeOf(result) });
    };
};
genericBind(lits, "literal", literal_lits);

fn varDef_lits(node, resultBox) {
    lits(node.value, resultBox);
};
genericBind(lits, "varDef", varDef_lits);

fn varRef_lits(node, resultBox) {
    # Nothing to do.
};
genericBind(lits, "varRef", varRef_lits);

fn voidable_lits(node, resultBox) {
    lits(node.expression, resultBox);
};
genericBind(lits, "voidable", voidable_lits);

# Collects all literal nodes at or under the given one into a map
# from literal value to index (zero-based).
fn collectLiterals(node) {
    def resultBox = Box::makeCell({});
    lits(node, resultBox);
    <> Box::fetch(resultBox)
};

<> collectLiterals
