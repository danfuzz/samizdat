## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def Lang0Node = moduleUse({name: ["Lang0Node"]});

## TODO: Ought to be able to do something like:
##     use Lang0Node *;
def get actuals    = Lang0Node::get actuals;
def get expression = Lang0Node::get expression;
def get formals    = Lang0Node::get formals;
def get function   = Lang0Node::get function;
def get name       = Lang0Node::get name;
def get statements = Lang0Node::get statements;
def get value      = Lang0Node::get value;
def get yield      = Lang0Node::get yield;
def get yieldDef   = Lang0Node::get yieldDef;

## `lits(node, litsBox)`, implements one layer of literal collection.
def lits = makeRegularGeneric("lits", 2, 2);

## Common implementation for both `@closure` and `@fnDef`.
fn closureLikeLits(node, litsBox) {
    <> @(typeOf(node)){
        formals: node.formals,
        ((def name = node.name) & {name} | {})*,
        statements: [ s in node.statements <> lits(s, litsBox) ],
        ((def y = node.yield) & {yield: lits(y, litsBox)} | {})*,
        ((def yieldDef = node.yieldDef) & {yieldDef} | {})*
    }
};

fn call_lits(node, litsBox) {
    <> @call{
        function: lits(node.function, litsBox),
        actuals: [ a in node.actuals <> lits(a, litsBox) ]
    }
};
genericBind(lits, "call", call_lits);

fn closure_lits(node, litsBox) {
    <> closureLikeLits(node, litsBox)
};
genericBind(lits, "closure", closure_lits);

fn expression_lits(node, litsBox) {
    <> @expression(lits(node.expression, litsBox))
};
genericBind(lits, "expression", expression_lits);

fn fnDef_lits(node, litsBox) {
    <> closureLikeLits(node, litsBox)
};
genericBind(lits, "fnDef", fnDef_lits);

fn interpolate_lits(node, litsBox) {
    <> @interpolate(lits(node.expression, litsBox))
};
genericBind(lits, "interpolate", interpolate_lits);

fn literal_lits(node, litsBox) {
    def value = node.value;
    def lits = Box::fetch(litsBox);

    if (def already = lits[value]) {
        return already;
    };

    def result = @literalRef(#lits);
    Box::store(litsBox, {lits*, (value): result});
    <> result
};
genericBind(lits, "literal", literal_lits);

fn varDef_lits(node, litsBox) {
    <> @varDef{
        name: node.name,
        value: lits(node.value, litsBox)
    }
};
genericBind(lits, "varDef", varDef_lits);

fn varRef_lits(node, litsBox) {
    <> node
};
genericBind(lits, "varRef", varRef_lits);

fn voidable_lits(node, litsBox) {
    <> @voidable(lits(node.expression, litsBox))
};
genericBind(lits, "voidable", voidable_lits);

## Collects all literal nodes at or under the given one into a map
## from literal value to index (zero-based). Returns `{literals, node}`
## where `literals` is a map of collected literals and `node` is a
## replacement for the original argument, in which literals have been
## replaced by references to same.
fn collectLiterals(node) {
    def litsBox = Box::makeCell({});
    def newNode = lits(node, litsBox);
    <> { literals: Box::fetch(litsBox), node: newNode }
};

<> collectLiterals
