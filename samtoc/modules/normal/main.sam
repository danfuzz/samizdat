## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def templateText = submoduleRead("template.txt");
def collectClosures = submoduleUse("collectClosures");
def collectLiterals = submoduleUse("collectLiterals");

def DataCode = moduleUse({name: ["DataCode"]});
def Lang0Node = moduleUse({name: ["Lang0Node"]});
def Template = moduleUse({name: ["Template"]});

def Io1 = moduleUse({name: ["core", "Io1"]});
def Lang2 = moduleUse({name: ["core", "Lang2"]});

def get_formals = Lang0Node::get_formals;
def get_maxArgs = Lang0Node::get_maxArgs;
def get_minArgs = Lang0Node::get_minArgs;
def get_name = Lang0Node::get_name;
def get_statements = Lang0Node::get_statements;
def get_yield = Lang0Node::get_yield;
def get_yieldDef = Lang0Node::get_yieldDef;

fn compile(sourcePath, targetPath) {
    def sourceText = Io1::readFileUtf8(sourcePath);
    def tree = Lang2::parseProgram(sourceText);

    ## Note: The node resulting from parsing a program must be of
    ## type `closure`.

    ## Reject closures that define any `formals`.
    ## TODO: Remove this restriction.
    if (tree.formals != []) {
        Io1::die("Program must not define formals.");
    };

    ## Reject closures that have a `yieldDef`. TODO: Remove this restriction.
    if (tree.yieldDef) {
        Io1::die("Program must not have a yield definition.");
    };

    ## Reject closures that do not have a `yield`. TODO: Remove this
    ## restriction.
    if (!tree.yield) {
        Io1::die("Program must yield a value.");
    };

    def litsNode = collectLiterals(tree);
    def literals = litsNode::literals;

    def literalDeclarations = cat(
        ( index in (0..!#literals) ->
            <> "static zvalue LIT_\(index) = NULL;\n"
        )*);

    def literalInits = cat(
        ( index in (0..!#literals), lit in literals ->
            def initText = DataCode::indent(
                DataCode::convert(lit),
                2,
                78);
            <> "\
            \/  LIT_\(index) =
            \/\(initText);
            \/  datImmortalize(LIT_\(index));\n"
        )*);

    def closuresNode = collectClosures(litsNode::node);
    def closures = closuresNode::closures;

    def closureBodies = cat(
        ( index in (0..!#closures), clo in closures ->
            <> "\
            \/static FUN_IMPL_DECL(\(index)) {
            \/  return NULL; // TODO
            \/  /*
            \/  \%q(clo)
            \/  */
            \/}\n\n"
        )*);

    def closureMakers = cat(
        ( index in (0..!#closures), clo in closures ->
            def name = (def n = clo.name)
                & DataCode::indent(DataCode::convert(n), 0, 1000)
                | "NULL";
            <> "\
            \/static makeClosure\(index)(/*TODO: state*/) {
            \/    zint stateCount = 0; // TODO
            \/    zvalue result = makeBuiltin(
            \/      \(clo.minArgs), \(clo.maxArgs), FUN_IMPL_NAME(\(index)),
            \/      stateCount, \(name));
            \/    // Set up state.
            \/    return result;
            \/}\n\n"
        )*);

    ## TODO: Something real here.
    def treeText = DataCode::indent(
        DataCode::convert(closuresNode::node),
        2,
        78);

    def replacements = {
        closureBodies,
        closureMakers,
        literalDeclarations,
        literalInits,
        minArgs: tree.minArgs,
        maxArgs: tree.maxArgs,
        name:    sourcePath[^0],
        body:    "\(treeText)"
    };

    def outputText = Template::apply(templateText, replacements);

    Io1::writeFileUtf8(targetPath, outputText)
};

<> {compile}
