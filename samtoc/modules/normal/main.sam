## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def templateText = submoduleRead("template.txt");

def Interner = submoduleUse("Interner");
def collectClosures = submoduleUse("collectClosures");
def internLiterals = submoduleUse("internLiterals");
def translate = submoduleUse("translate");

def CodeGen = moduleUse({name: ["CodeGen"]});
def DataCode = moduleUse({name: ["DataCode"]});
def Lang0Node = moduleUse({name: ["Lang0Node"]});
def Template = moduleUse({name: ["Template"]});

def Io1 = moduleUse({name: ["core", "Io1"]});
def Lang2 = moduleUse({name: ["core", "Lang2"]});

def flatten = CodeGen::flatten;
def indent = CodeGen::indent;

def get_interns = Interner::get_interns;
def intern = Interner::intern;

def get_actuals    = Lang0Node::get_actuals;
def get_formals    = Lang0Node::get_formals;
def get_function   = Lang0Node::get_function;
def get_id         = Lang0Node::get_id;
def get_maxArgs    = Lang0Node::get_maxArgs;
def get_minArgs    = Lang0Node::get_minArgs;
def get_name       = Lang0Node::get_name;
def get_statements = Lang0Node::get_statements;
def get_value      = Lang0Node::get_value;
def get_varRefs    = Lang0Node::get_varRefs;
def get_yield      = Lang0Node::get_yield;
def get_yieldDef   = Lang0Node::get_yieldDef;

## Indent with the usual width column limit.
fn usualIndent(tree, depth) {
    <> indent(tree, depth, 78)
};

## Returns a `makeClosure_*` declaration, as a code tree.
fn closureDeclaration(cloIdx, clo) {
    def varRefs = clo.varRefs;
    <> CodeGen::makeCall(
        "static zvalue makeClosure_\(cloIdx)",
        ( idx in (0..), name in varRefs ->
            <> CodeGen::makeComment("\%q(name)", "zvalue free_\(idx)")
        )*);
};

## Returns a full `makeClosure_*` definition, as as string.
fn closureMaker(cloIdx, clo) {
    def name = (def n = clo.name)
        & translate::translate(n, Box::nullBox).flatten()
        | "NULL";

    def varRefs = clo.varRefs;
    def declaration = closureDeclaration(cloIdx, clo);
    def stateAssigns = [ idx in (0..!#varRefs) ->
        def stat = CodeGen::makeStatement(
            CodeGen::makeAssign("state[\(idx)]", "free_\(idx)"));
        <> stat.usualIndent(1)
    ];
    def resultAssign = CodeGen::makeAssign(
        "zvalue result",
        CodeGen::makeCall(
            "makeBuiltin", "\(clo.minArgs)", "\(clo.maxArgs)",
            "FUN_IMPL_NAME(\(cloIdx))", "\(#varRefs)", name));

    <> "\
    \/\(declaration.usualIndent(0)) {
    \/\(resultAssign.usualIndent(1));
    \/  zvalue *state = builtinGetState(result).arr;
    \/\(stateAssigns)
    \/  return result;
    \/}\n\n"
};

## Helper for `processFormals` which does the more complicated processing
## required for handling repeat specifiers.
fn processFormalsWithRepeat(clo) {
    ## TODO: Handle repetition modifiers.
    Io1::die("TODO")
};

## Returns `{names, vars, preInits}` for the formal arguments to the
## given closure, if any.
fn processFormals(clo) {
    def vars = (f in clo.formals, idx in (0..) ->
        if (f::repeat) {
            ## At least one argument has a repeat specifier. Do the requisite
            ## processing.
            return processFormalsWithRepeat(clo)
        };

        <> (def name = f::name) &
            {(name): {
                origName: name,
                kind: "arg",
                name: "arg_\(idx)",
                init: CodeGen::makeCall("makeResult", "args[\(idx)]")
            }}
    );

    def names = [ f in clo.formals <> f::name ];

    def preInits = [f in clo.formals, idx in (0..) ->
        <> (!f::name) & CodeGen::makeComment("Unnamed argument \(idx)")
    ];

    <> {names, preInits, vars: {}.cat(vars*)}
};

## Returns `{names, vars, preInits}` for the yield definition of the given
## closure, if any.
fn processYieldDef(clo) {
    <> if (def name = clo.yieldDef) {
        ## TODO: Something real.
        <> {
            names: [name],
            preInits: [],
            vars: {(name): {
                    origName: "<\(name)>",
                    kind: "yield",
                    name: "yield",
                    init: "NULL"
                }}
        }
    } else {
        <> {names: [], preInits: [], vars: {}}
    }
};

## Returns `{names, vars, preInits}` for the free variables of the given
## closure, if any.
fn processFreeVars(clo) {
    def names = clo.varRefs;
    def vars = ( name in names, idx in (0..) ->
        <> {(name): {
            origName: name,
            kind: "free",
            name: "free_\(idx)",
            init: "state[\(idx)]"
        }}
    );

    <> {names, preInits: [], vars: {}.cat(vars*)}
};

## Returns a function definition for the code for a closure, as a string.
fn closureBody(cloIdx, clo) {
    ## Set up the initial variable bindings.
    def formals = processFormals(clo);
    def freeVars = processFreeVars(clo);
    def yieldDef = processYieldDef(clo);
    def vars = {formals::vars*, freeVars::vars*, yieldDef::vars*};
    def varNames = [formals::names*, freeVars::names*, yieldDef::names*];

    ## Make C local variable defintions for all the variables.
    def varStats = [ name in varNames ->
        def binding = vars[name];
        <> CodeGen::makeComment(
            "\%q(binding::origName)",
            CodeGen::makeAssign("zvalue \(binding::name)",
                binding::init));
    ];

    ## Translate the statements and the yield. Note that the `statements`
    ## definition is a list constructor (not a generator), as its body has
    ## to run before `yield` is calculated (in order to have the correct
    ## set of vars defined in `varsBox`).

    def varsBox = Box::makeCell(vars);
    def mainStats = [ s in clo.statements ->
        <> translate::translate(s, varsBox)
    ];
    def yield = (def y = clo.yield)
        & translate::translate(y, varsBox)
        | "NULL";
    def yieldStat = CodeGen::makeReturn(yield);

    ## Process all the statements, producing source code.

    def allStats = [ s in [varStats*, mainStats*, yieldStat] ->
        <> CodeGen::makeStatement(s).usualIndent(1)
    ];

    <> "\
    \/static FUN_IMPL_DECL(\(cloIdx)) {
    \/  zvalue *state = builtinGetState(thisFunction).arr;
    \/\(allStats)}\n\n"
};

## Constructs the top-level closure. This is similar to translating a
## `@closureRef` node, except that the closure state is initialized from
## the global context and not from local or captured variables.
fn mainClosureMaker(node, interner) {
    def varRefs = node.varRefs;
    def ids = [ name in varRefs <> interner.intern(name) ];

    def stat = CodeGen::makeStatement(
        CodeGen::makeReturn(
            CodeGen::makeCall("makeClosure_\(node.id)",
                ( name in varRefs, id in ids ->
                    <> CodeGen::makeComment("\%q(name)",
                        CodeGen::makeCall("makeResult",
                            CodeGen::makeCall("collGet",
                                "GLOBALS", "LIT_\(id)")))
                )*)));

    <> stat.usualIndent(1)
};

fn compile(sourcePath, targetPath) {
    def sourceText = Io1::readFileUtf8(sourcePath);

    ## Note: The node resulting from a call to `parseProgram` is always of
    ## type `closure`.
    def mainNode = Lang2::parseProgram(sourceText);

    def interner = Interner::makeInterner();
    def litsNode = internLiterals(mainNode, interner);

    def closuresNode = collectClosures(litsNode);
    def closures = closuresNode::closures;
    def closureDeclarations = cat(
        ( idx in (0..), clo in closures ->
            def stat = CodeGen::makeStatement(closureDeclaration(idx, clo));
            <> "\(stat.usualIndent(0))\n"
        )*);
    def closureMakers = cat(
        ( idx in (0..), clo in closures <> closureMaker(idx, clo) )*);
    def closureBodies = cat(
        ( idx in (0..), clo in closures <> closureBody(idx, clo) )*);
    def mainClosure = mainClosureMaker(closuresNode::node, interner);

    def literals = interner.interns;
    def literalDeclarations = cat(
        ( index in (0..!#literals) ->
            <> "static zvalue LIT_\(index) = NULL;\n"
        )*);
    def literalInits = cat(
        ( index in (0..), lit in literals ->
            def init = CodeGen::makeStatement(
                CodeGen::makeCall("datImmortalize",
                    CodeGen::makeAssign("LIT_\(index)",
                        DataCode::convert(lit))));
            <> init.usualIndent(2)
        )*);

    def replacements = {
        closureBodies,
        closureDeclarations,
        closureMakers,
        literalDeclarations,
        literalInits,
        mainClosure
    };

    def outputText = Template::apply(templateText, replacements);

    Io1::writeFileUtf8(targetPath, outputText)
};

<> {compile}
