## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def templateText = submoduleRead("template.txt");
def collectLiterals = submoduleUse("collectLiterals");

def DataCode = moduleUse({name: ["DataCode"]});
def Lang0Node = moduleUse({name: ["Lang0Node"]});
def Template = moduleUse({name: ["Template"]});

def Io1 = moduleUse({name: ["core", "Io1"]});
def Lang2 = moduleUse({name: ["core", "Lang2"]});

def get formals = Lang0Node::get formals;
def get statements = Lang0Node::get statements;
def get yield = Lang0Node::get yield;
def get yieldDef = Lang0Node::get yieldDef;

fn compile(sourcePath, targetPath) {
    def sourceText = Io1::readFileUtf8(sourcePath);
    def tree = Lang2::parseProgram(sourceText);

    ## Note: The node resulting from parsing a program must be of
    ## type `closure`.

    ## Reject closures that define any `formals`.
    ## TODO: Remove this restriction.
    if (tree.formals != []) {
        Io1::die("Program must not define formals.");
    };

    ## Reject closures that have a `yieldDef`. TODO: Remove this restriction.
    if (tree.yieldDef) {
        Io1::die("Program must not have a yield definition.");
    };

    ## Reject closures that do not have a `yield`. TODO: Remove this
    ## restriction.
    if (!tree.yield) {
        Io1::die("Program must yield a value.");
    };

    ## TODO: Something real here.
    def statements = [ s in tree.statements <> "\%q(s)\n\n" ];

    Io1::note("=== \%q(DataCode::convert([]))");
    Io1::note("=== \%q(DataCode::convert({}))");
    Io1::note("=== \%q(DataCode::convert(123))");
    Io1::note("=== \%q(DataCode::convert("hello"))");
    Io1::note("=== \%q(DataCode::convert([1, 2, 3]))");
    Io1::note("=== \%q(DataCode::convert({a: "axe"}))");
    Io1::note("=== \%q(DataCode::convert(null))");
    Io1::note("=== \%q(DataCode::convert(true))");
    Io1::note("=== \%q(DataCode::convert(@blort))");

    def literals = collectLiterals(tree);
    for (lit in literals) {
        Io1::note("=== \%q(lit)")
    };

    def replacements = {
        minArgs: 0,
        maxArgs: 0,
        name:    sourcePath[^0],
        body:    "\%Q(statements)"
    };

    def outputText = Template::apply(templateText, replacements);

    Io1::writeFileUtf8(targetPath, outputText)
};

<> {compile}
