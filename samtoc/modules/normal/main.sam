## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

def templateText = submoduleRead("template.txt");
def collectLiterals = submoduleUse("collectLiterals");

def DataCode = moduleUse({name: ["DataCode"]});
def Lang0Node = moduleUse({name: ["Lang0Node"]});
def Template = moduleUse({name: ["Template"]});

def Io1 = moduleUse({name: ["core", "Io1"]});
def Lang2 = moduleUse({name: ["core", "Lang2"]});

def get formals = Lang0Node::get formals;
def get statements = Lang0Node::get statements;
def get yield = Lang0Node::get yield;
def get yieldDef = Lang0Node::get yieldDef;

fn compile(sourcePath, targetPath) {
    def sourceText = Io1::readFileUtf8(sourcePath);
    def tree = Lang2::parseProgram(sourceText);

    ## Note: The node resulting from parsing a program must be of
    ## type `closure`.

    ## Reject closures that define any `formals`.
    ## TODO: Remove this restriction.
    if (tree.formals != []) {
        Io1::die("Program must not define formals.");
    };

    ## Reject closures that have a `yieldDef`. TODO: Remove this restriction.
    if (tree.yieldDef) {
        Io1::die("Program must not have a yield definition.");
    };

    ## Reject closures that do not have a `yield`. TODO: Remove this
    ## restriction.
    if (!tree.yield) {
        Io1::die("Program must yield a value.");
    };

    def litsNode = collectLiterals(tree);
    def literals = litsNode::literals;
    def unlitTree = litsNode::node;

    Io1::note("=== Literals:");
    for (lit in literals) {
        Io1::note("===   \%q(lit)")
    };

    Io1::note("\n=== tree \%q(unlitTree)\n\n");

    ## TODO: Something real here.
    def treeText = DataCode::indent(
        DataCode::convert(unlitTree),
        2,
        78);

    def replacements = {
        minArgs: 0,
        maxArgs: 0,
        name:    sourcePath[^0],
        body:    "\(treeText)"
    };

    def outputText = Template::apply(templateText, replacements);

    Io1::writeFileUtf8(targetPath, outputText)
};

<> {compile}
