## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import core.LangNode :: *;

import ./get_varDefs :: get_varDefs;

##
## Exported Generics
##

## `node.get_varRefs()`: Generic that returns free variable references of
## `node`, as list of names.
export fn .get_varRefs();


##
## Private Definitions
##

## Extracts and combines the `varRefs` of all the arguments.
fn catVarRefs(nodes*) {
    return [].cat(( n in nodes -> n.varRefs )*)
};


##
## Exported Definitions
##

fn @@apply.get_varRefs() {
    return catVarRefs(this.function, this.values)
};

fn @@call.get_varRefs() {
    return catVarRefs(this.function, this.values*)
};

fn @@closure.get_varRefs() {
    if (def refs = this::varRefs) {
        ## Already calculated for this node.
        return refs
    };

    ## `baseLocals` is the list of all local variables defined at the
    ## top of the closure, including formal arguments and a yield def
    ## (if any).
    def baseLocals = [
        this.yieldDef?*,
        ( f in this.formals -> f::name )*];

    ## The extra element at the end is to represent the closure yield.
    def statementDefs = [( s in this.statements -> s.varDefs )*, []];

    ## What's happening here is that for each statement (and the yield at
    ## the end), we get its variable references and remove from them refs
    ## for any variables that are locally defined before the statement.
    ## This produces the array `statementRefs` whose elements are merged,
    ## producing the full set of free variables referenced by the closure
    ## as a whole. Deletion from the list is achieved by converting the
    ## refs to a map (refs as keys, values all `null`), and then doing
    ## key deletion. The resulting `statmentRefs` is a list of these maps.
    def statementRefs = (
            s in [this.statements*, this.yieldNode],
            idx in (0..) ->
        def defs = baseLocals.cat(statementDefs[..!idx]*);
        var refs = {s.varRefs*: null};
        for (d in defs) {
           refs := $Collection::del(refs, d)
        };
        refs
    );

    ## The result of concatenating all the `statementRefs` is a map. The
    ## final result is the list of refs, that is, a list of all the keys.
    return $Collection::keyList({}.cat(statementRefs*))
};

fn @@closureRef.get_varRefs() {
    return this::varRefs
};

fn @@fetch.get_varRefs() {
    return this.target.varRefs
};

fn @@importModule.get_varRefs() {
    def statements = makeDynamicImport(this);
    return catVarRefs(statements*)
};

fn @@importModuleSelection.get_varRefs() {
    def statements = makeDynamicImport(this);
    return catVarRefs(statements*)
};

fn @@importResource.get_varRefs() {
    def statements = makeDynamicImport(this);
    return catVarRefs(statements*)
};

fn @@literal.get_varRefs() {
    return []
};

fn @@literalRef.get_varRefs() {
    return []
};

fn @@maybe.get_varRefs() {
    return this.nodeValue.varRefs
};

fn @@noYield.get_varRefs() {
    return this.nodeValue.varRefs
};

fn @@store.get_varRefs() {
    return catVarRefs(this.target, this.nodeValue)
};

fn @@varDef.get_varRefs() {
    return (def v = this.nodeValue) & v.varRefs | []
};

fn @@varDefMutable.get_varRefs() {
    return (def v = this.nodeValue) & v.varRefs | []
};

fn @@varRef.get_varRefs() {
    return [this.name]
};

fn @@void.get_varRefs() {
    return []
};
