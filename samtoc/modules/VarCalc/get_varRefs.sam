## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import core.LangNode :: *;

import ./get_varDefs :: get_varDefs;

##
## Private Definitions
##

## Extracts and combines the `varRefs` of all the arguments.
fn catVarRefs(nodes*) {
    return [].cat(( n in nodes -> n.varRefs )*)
};


##
## Exported Definitions
##

## `node.get_varRefs()`: Generic that returns free variable references of
## `node`, as list of names.
export fn get_varRefs(node) {
    return switch (get_class(node)) {
        @@apply: {
            catVarRefs(node.function, node.values)
        };

        @@call: {
            catVarRefs(node.function, node.values*)
        };

        @@closure: {
            if (def refs = node::varRefs) {
                ## Already calculated for this node.
                return refs
            };

            ## `baseLocals` is the list of all local variables defined at
            ## the top of the closure, including formal arguments and a
            ## yield def (if any).
            def baseLocals = [
                node.yieldDef?*,
                ( f in node.formals -> f::name )*];

            ## The extra element at the end is to represent the closure
            ## yield.
            def statementDefs =
                [( s in node.statements -> s.varDefs )*, []];

            ## What's happening here is that for each statement (and the
            ## yield at the end), we get its variable references and
            ## remove from them refs for any variables that are locally
            ## defined before the statement. This produces the array
            ## `statementRefs` whose elements are merged, producing the
            ## full set of free variables referenced by the closure as a
            ## whole. Deletion from the list is achieved by converting the
            ## refs to a map (refs as keys, values all `null`), and then
            ## doing key deletion. The resulting `statmentRefs` is a list
            ## of these maps.
            def statementRefs = (
                    s in [node.statements*, node.yieldNode],
                    idx in (0..) ->
                def defs = baseLocals.cat(statementDefs[..!idx]*);
                var refs = {s.varRefs*: null};
                for (d in defs) {
                   refs := $Collection::del(refs, d)
                };
                refs
            );

            ## The result of concatenating all the `statementRefs` is a
            ## map. The final result is the list of refs, that is, a list
            ## of all the keys.
            $Collection::keyList({}.cat(statementRefs*));
        };

        @@closureRef: {
            node::varRefs
        };

        @@fetch: {
            node.target.varRefs
        };

        @@store: {
            catVarRefs(node.target, node.nodeValue)
        };

        @@varRef: {
            [node.name]
        };

        @@maybe:
        @@noYield: {
            node.nodeValue.varRefs
        };

        @@varDef:
        @@varDefMutable: {
            (def v = node.nodeValue) & v.varRefs | []
        };

        @@importModule:
        @@importModuleSelection:
        @@importResource: {
            def statements = makeDynamicImport(node);
            catVarRefs(statements*)
        };

        @@literal:
        @@literalRef:
        @@void: {
            []
        }
    }
};
