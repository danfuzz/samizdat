## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Convert data into C code that constructs that data.
##

import CodeGen ::
    flatten,
    indent,
    genCall;


##
## Private Definitions
##

## Encode the given values as a list of C-style `\xNN` escapes.
fn hexEscape(values*) {
    return [ value in values ->
        def digit1 = (value >>> 4) &&& 0x0f;
        def digit2 =  value        &&& 0x0f;
        "\\x\%x(digit1)\%x(digit2)"
    ]
};

## UTF-8 encode the given character, returning a representation as a list of
## C-style `\xNN` escapes.
fn utf8Char(ch) {
    def value = toInt(ch);

    return if (value < 0) {
        die("Out of range for UTF-8 encoding: 0x\%x(value)");
    } else if (value < 0x80) {
        hexEscape(value)
    } else if (value < 0x800) {
        def x0 = 0xc0 |||  (value >>> 6)           ;
        def x1 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1)
    } else if (value < 0x1_0000) {
        def x0 = 0xe0 |||  (value >>> 12)          ;
        def x1 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x2 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2)
    } else if (value < 0x20_0000) {
        def x0 = 0xf0 |||  (value >>> 18)          ;
        def x1 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x3 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3)
    } else if (value < 0x400_0000) {
        def x0 = 0xf8 |||  (value >>> 24)          ;
        def x1 = 0x80 ||| ((value >>> 18) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x3 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x4 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3, x4)
    } else if (value < 0x8000_0000) {
        def x0 = 0xfc |||  (value >>> 30)          ;
        def x1 = 0x80 ||| ((value >>> 24) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 18) &&& 0x3f);
        def x3 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x4 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x5 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3, x4, x5)
    } else if (value < 0x1_0000_0000) {
        def x0 = 0xfe                              ;
        def x1 = 0x80 ||| ((value >>> 30) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 24) &&& 0x3f);
        def x3 = 0x80 ||| ((value >>> 18) &&& 0x3f);
        def x4 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x5 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x6 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3, x4, x5, x6)
    } else {
        die("Out of range for UTF-8: 0x\%x(value)");
    }
};

## Map of special-case characters to either their stringified forms or
## to `"x"` to indicate a need to convert as hex.
def SPECIAL_CHARS = {
    ("\x1;".."\x1f;")*: "x",
    "\x7f;":            "x",
    "\0":               "\\0",
    "\n":               "\\n",
    "\r":               "\\r",
    "\t":               "\\t",
    "\"":               "\\\"",
    "\\":               "\\\\"
};

## Helper for converting strings: Returns the converted form of the
## given character as a list of single-character forms in C syntax.
fn stringChar(ch) {
    if (ch > "\x7f;") {
        return utf8Char(ch)
    } else if (def special = SPECIAL_CHARS[ch]) {
        if (special == "x") {
            return hexEscape(toInt(ch))
        } else {
            return [special]
        }
    };

    return [ch]
};


##
## Exported definitions
##

## Converts a class. Only works on derived data classes.
fn Class_convert(value) {
    return genCall("makeDerivedDataClass", convert(className(value)))
};

## Converts an int.
fn Int_convert(value) {
    return genCall("intFromZint", "\(value)")
};

## Converts a list.
fn List_convert(value) {
    if (value == []) {
        return "EMPTY_LIST"
    };

    def listElems = [ elem in value -> convert(elem) ];
    return genCall("listFromArgs", listElems*, "NULL")
};

## Converts a map.
fn Map_convert(value) {
    if (value == {}) {
        return "EMPTY_MAP"
    };

    def mapPairs = [ mapping in value ->
        [convert(get_key(mapping)), convert(get_value(mapping))]
    ];

    return genCall("mapFromArgs", cat(mapPairs*)*, "NULL")
};

## Converts a string.
fn String_convert(value) {
    if (value == "") {
        return "EMPTY_STRING"
    };

    ## Each `stringChar()` call returns a list (each list element representing
    ## one byte), and we have to interpolate+concatenate them all together in
    ## order to find the encoded length.
    def bodyChars = cat((ch in value -> stringChar(ch))*);

    return genCall("stringFromUtf8",
        "\(#bodyChars)", "\"\(bodyChars)\"")
};

## Converts a derived value or an opaque core value.
fn Value_convert(value) {
    def data = (def dval = dataOf(value)) & convert(dval) | "NULL";
    def cls = get_class(value);

    if (!hasClass(value, DerivedData)) {
        die("Cannot convert opaque non-data value: \%q(value)")
    };

    return genCall("makeData", convert(cls), data)
};

## Converts a value into C code to construct that value. This function
## returns a tree that can be stringified with `indent()`.
export fn convert(value) {
    return switch (get_class(value)) {
        (Class):  { Class_convert(value) };
        (Int):    { Int_convert(value) };
        (List):   { List_convert(value) };
        (Map):    { Map_convert(value) };
        (String): { String_convert(value) };
        default:  { Value_convert(value) }
    }
};
