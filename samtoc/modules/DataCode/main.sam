## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Convert data into C code that constructs that data.
##

import CodeGen :: genCall, genCodeString;


##
## Private Definitions
##

## Representation of a C `NULL`.
def CODE_C_NULL = genCodeString("NULL");

## Values with special conversions.
def SPECIAL_VALUES = {
    (Bool) :       genCodeString("CLS_Bool"),
    (Class):       genCodeString("CLS_Class"),
    (Core):        genCodeString("CLS_Core"),
    (Int):         genCodeString("CLS_Int"),
    (List):        genCodeString("CLS_List"),
    (Map):         genCodeString("CLS_Map"),
    (Null):        genCodeString("CLS_Null"),
    (Record):      genCodeString("CLS_Record"),
    (String):      genCodeString("CLS_String"),
    (Symbol):      genCodeString("CLS_Symbol"),
    (SymbolTable): genCodeString("CLS_SymbolTable"),
    (Value):       genCodeString("CLS_Value"),
    (false):       genCodeString("BOOL_FALSE"),
    (true):        genCodeString("BOOL_TRUE"),
    (null):        genCodeString("THE_NULL"),
    []:            genCodeString("EMPTY_LIST"),
    {}:            genCodeString("EMPTY_MAP"),
    @{}:           genCodeString("EMPTY_SYMBOL_TABLE"),
    "":            genCodeString("EMPTY_STRING"),
    0:             genCodeString("INT_0"),
    1:             genCodeString("INT_1"),
    -1:            genCodeString("INT_NEG1")
};

## Encode the given values as a list of C-style `\xNN` escapes.
fn hexEscape(values*) {
    return [ value in values ->
        def digit1 = (value >>> 4) &&& 0x0f;
        def digit2 =  value        &&& 0x0f;
        "\\x\%x(digit1)\%x(digit2)"
    ]
};

## UTF-8 encode the given character, returning a representation as a list of
## C-style `\xNN` escapes.
fn utf8Char(ch) {
    def value = ch.toInt();

    return if (value < 0) {
        die("Out of range for UTF-8 encoding: 0x\%x(value)");
    } else if (value < 0x80) {
        hexEscape(value)
    } else if (value < 0x800) {
        def x0 = 0xc0 |||  (value >>> 6)           ;
        def x1 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1)
    } else if (value < 0x1_0000) {
        def x0 = 0xe0 |||  (value >>> 12)          ;
        def x1 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x2 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2)
    } else if (value < 0x20_0000) {
        def x0 = 0xf0 |||  (value >>> 18)          ;
        def x1 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x3 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3)
    } else if (value < 0x400_0000) {
        def x0 = 0xf8 |||  (value >>> 24)          ;
        def x1 = 0x80 ||| ((value >>> 18) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x3 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x4 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3, x4)
    } else if (value < 0x8000_0000) {
        def x0 = 0xfc |||  (value >>> 30)          ;
        def x1 = 0x80 ||| ((value >>> 24) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 18) &&& 0x3f);
        def x3 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x4 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x5 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3, x4, x5)
    } else if (value < 0x1_0000_0000) {
        def x0 = 0xfe                              ;
        def x1 = 0x80 ||| ((value >>> 30) &&& 0x3f);
        def x2 = 0x80 ||| ((value >>> 24) &&& 0x3f);
        def x3 = 0x80 ||| ((value >>> 18) &&& 0x3f);
        def x4 = 0x80 ||| ((value >>> 12) &&& 0x3f);
        def x5 = 0x80 ||| ((value >>> 6)  &&& 0x3f);
        def x6 = 0x80 ||| ( value         &&& 0x3f);
        hexEscape(x0, x1, x2, x3, x4, x5, x6)
    } else {
        die("Out of range for UTF-8: 0x\%x(value)");
    }
};

## Map of special-case characters to either their stringified forms or
## to `"x"` to indicate a need to convert as hex.
def SPECIAL_CHARS = {
    ("\x1;".."\x1f;")*: "x",
    ("\x7f;"):          "x",
    ("\0"):             "\\0",
    ("\n"):             "\\n",
    ("\r"):             "\\r",
    ("\t"):             "\\t",
    ("\""):             "\\\"",
    ("\\"):             "\\\\"
};

## Helper for converting strings: Returns the converted form of the
## given character as a list of single-character forms in C syntax.
fn stringChar(ch) {
    if (ch > "\x7f;") {
        return utf8Char(ch)
    } else if (def special = SPECIAL_CHARS[ch]) {
        if (special == "x") {
            return hexEscape(ch.toInt())
        } else {
            return [special]
        }
    };

    return [ch]
};


##
## Exported definitions
##

## Converts an int.
fn Int_convert(value) {
    return genCall("intFromZint", "\(value)")
};

## Converts a list.
fn List_convert(value) {
    def listElems = [ elem in value -> convert(elem) ];
    return genCall("listFromArgs", listElems*, CODE_C_NULL)
};

## Converts a map.
fn Map_convert(value) {
    def mapPairs = [ mapping in value ->
        [convert(mapping.key), convert(mapping.value)]
    ];

    return genCall("mapFromArgs", [].cat(mapPairs*)*, CODE_C_NULL)
};

## Converts a record.
fn Record_convert(value) {
    return genCall("makeRecord", convert(value.name), convert(value.dataOf()))
};

## Converts a string.
fn String_convert(value) {
    ## Each `stringChar()` call returns a list (each list element representing
    ## one byte), and we have to interpolate+concatenate them all together in
    ## order to find the encoded length.
    def bodyChars = [].cat((ch in value -> stringChar(ch))*);

    return genCall("stringFromUtf8",
        "\(#bodyChars)", "\"\(bodyChars)\"")
};

## Converts a symbol.
fn Symbol_convert(value) {
    if (!value.isInterned()) {
        die("Cannot convert unlisted symbol: \%q(value)")
    };

    ## See comment in `String_convert`.
    def name = value.toString();
    def bodyChars = [].cat((ch in name -> stringChar(ch))*);

    return genCall("symbolFromUtf8", "\(#bodyChars)", "\"\(bodyChars)\"")
};


## Converts a symbol table.
fn SymbolTable_convert(value) {
    ## Convert to a map, and process the result similar to how map conversion
    ## works.

    def map = {}.cat(value);
    def mapPairs = [ mapping in map ->
        [convert(mapping.key), convert(mapping.value)]
    ];

    return genCall("symbolTableFromArgs", [].cat(mapPairs*)*, CODE_C_NULL)
};

## Converts an opaque value. Or rather, always complains that it can't
## actually do that.
fn Value_convert(value) {
    die("Cannot convert value: \%q(value)")
};

## Converts a value into C code to construct that value. This function
## returns a tree that can be stringified with `indent()`.
export fn convert(value) {
    return if (def special = SPECIAL_VALUES[value]) {
        special
    } else {
        switch (get_class(value)) {
            (Class):       { Class_convert(value)       };
            (Int):         { Int_convert(value)         };
            (List):        { List_convert(value)        };
            (Map):         { Map_convert(value)         };
            (Record):      { Record_convert(value)      };
            (String):      { String_convert(value)      };
            (Symbol):      { Symbol_convert(value)      };
            (SymbolTable): { SymbolTable_convert(value) };
            default:       { Value_convert(value)       }
        }
    }
};
