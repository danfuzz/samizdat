## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import core.CommandLine;
import core.FilePath;
import core.Io0;

import Resolver;

## Default mode to use.
def DEFAULT_MODE = "simple";

## Suffix for normal source files.
def SOURCE_SUFFIX = ".sam";

## Map from `--mode` values to module names.
def MODE_MAP = {
    "interp-text": "interpText",
    "interp-tree": "interpTree",
    "linkage":     "linkage",
    "simple":      "simple"
};

## Removes the `.*` suffix from `name`.
fn withoutSuffix(name) {
    def dotsAt = [ index in (0..), ch in name <> (ch == ".") & index ];

    if (dotsAt == []) {
        ## No suffix on the name.
        return name
    } else {
        return name[..!dotsAt[^0]]
    }
};

## Returns `name` iff the given name has the proper suffix for a source
## file.
fn isSourceName(name) {
    <> (#name > #SOURCE_SUFFIX)
        & (name[^(#SOURCE_SUFFIX - 1)..] == SOURCE_SUFFIX)
        & name
};

fn getSourcePath(rawPath, args) {
    return (def inDir = args::options::"in-dir")
        & "\(inDir)/\(rawPath)"
        | rawPath;
};

fn getOutputPath(rawPath, args, defaultSuffix) {
    if (def output = args::options::output) {
        return output
    };

    def path = (def outDir = args::options::"out-dir")
        & "\(outDir)/\(rawPath)"
        | rawPath;

    def dir = $FilePath::get_directory(path);
    def baseName = withoutSuffix($FilePath::get_file(path));
    return "\(dir)/\(baseName).\(defaultSuffix)"
};

fn doFile(modeModule, resolver, args, sourceName, sourcePath) {
    def outputPath = getOutputPath(sourceName, args, modeModule::SUFFIX);
    note("-> \%q(outputPath)\n");
    modeModule::compile(resolver, sourcePath, outputPath)
};

## Handles processing of directories.
fn doDirectory(modeModule, resolver, args, sourcePath) {
    if (($Io0::fileType(sourcePath) | "notFound") != "directory") {
        ## No such directory. Ignore it, per the header comment.
        return
    };

    if (($Io0::fileType("\(sourcePath)/main.sam") | "notFound") == "file") {
        ## There's a `main.sam` in the directory. Treat it as a module
        ## implementation. First handle a "captive" `modules` directory
        ## (if any), then handle the main implementation files.
        def captiveDir = "\(sourcePath)/modules";
        def subResolver =
            (($Io0::fileType(captiveDir) | "notFound") == "directory")
            & $Resolver::makeExternalResolver(captiveDir, resolver)
            | resolver;

        if (resolver != subResolver) {
            ## There's a captive `modules` directory. Iterate over its
            ## subdirectories.
            def files = $Io0::readDirectory(captiveDir);
            for (one in files) {
                if (one.value == "directory") {
                    def path = "\(captiveDir)/\(one.key)";
                    doDirectory(modeModule, subResolver, args, path)
                }
            }
        };

        def internalResolver =
            $Resolver::makeInternalResolver(sourcePath, subResolver);

        ## Helper to process an internal directory (including the top-level
        ## internal directory).
        fn doInternalDir(dir) {
            def files = $Io0::readDirectory(dir);
            for (one in files) {
                def path = "\(dir)/\(one.key)";
                if (one.value == "directory") {
                    if (path != captiveDir) {
                        doInternalDir(path)
                    }
                } else if (isSourceName(path)) {
                    doOne(modeModule, internalResolver, args, path)
                }
            };
        };

        ## Process the rest of the files (skipping `modules`).
        doInternalDir(sourcePath)
    } else {
        ## No `main.sam`. Treat it as a `modules` directory. Make an external
        ## resolver for the given directory, and recursively process all
        ## subdirectories.
        def subResolver =
            $Resolver::makeExternalResolver(sourcePath, resolver);
        def files = $Io0::readDirectory(sourcePath);
        for (one in files) {
            if (one.value == "directory") {
                def path = "\(sourcePath)/\(one.key)";
                doDirectory(modeModule, subResolver, args, path)
            }
        }
    }
};

## Processes a single file or directory.
fn doOne(modeModule, resolver, args, sourceName) {
    def sourcePath = getSourcePath(sourceName, args);

    note("\%q(sourcePath)");

    switch (def type = $Io0::fileType(sourcePath)) {
        file: {
            doFile(modeModule, resolver, args, sourceName, sourcePath)
        };
        directory: {
            doDirectory(modeModule, resolver, args, sourcePath)
        };
        default: {
            die("Cannot handle file type \%q(type).")
        };
        else: {
            die("File not found: \%q(sourcePath)")
        }
    }
};

export fn main(selfPath, rawArgs*) {
    note("\n\
        Starting: \%q(selfPath)
        Arguments:");
    for (arg in rawArgs) {
        note("    \%q(arg)");
    };

    def args = $CommandLine::parseArgs(rawArgs);

    note("Options:");
    for (opt in args::options) {
        note("    \%q(opt)");
    };
    note("");

    def sources = args::args;
    def modeName = MODE_MAP[args::options::mode | DEFAULT_MODE] |
        {
            note("Unknown compilation mode: \%q(args::options::mode)");
            return 1
        }();
    def modeModule = loadModule(@external("mode.\(modeName)"));

    def externalResolver = (def dirs = args::options::"external-dirs")
        & $Resolver::makeResolverChain(dirs)
        | null;
    def resolver = (def dir = args::options::"internal-dir")
        & $Resolver::makeInternalResolver(dir, externalResolver)
        | externalResolver;

    if (#sources == 0) {
        note("No source files specified!");
        return 1
    };

    if (args::options::output & (#sources > 1)) {
        note("Cannot use --output with more than one source!");
        return 1
    };

    for (s in sources) {
        doOne(modeModule, resolver, args, s)
    }
};
