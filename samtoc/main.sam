## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

import core.CommandLine;
import core.FilePath;

import Resolver;

## Default mode to use
def DEFAULT_MODE = "simple";

## Map from `--mode` values to module names.
def MODE_MAP = {
    "interp-text": "interpText",
    "interp-tree": "interpTree",
    "linkage":     "linkage",
    "simple":      "simple"
};

## Removes the `.*` suffix from `name`.
fn withoutSuffix(name) {
    def dotsAt = [ index in (0..), ch in name <> (ch == ".") & index ];

    if (dotsAt == []) {
        ## No suffix on the name.
        return name
    } else {
        return name[..!dotsAt[^0]]
    }
};

fn getSourcePath(rawPath, args) {
    return (def inDir = args::options::"in-dir")
        & "\(inDir)/\(rawPath)"
        | rawPath;
};

fn getOutputPath(rawPath, args, defaultSuffix) {
    if (def output = args::options::output) {
        return output
    };

    def path = (def outDir = args::options::"out-dir")
        & "\(outDir)/\(rawPath)"
        | rawPath;

    def dir = $FilePath::get_directory(path);
    def baseName = withoutSuffix($FilePath::get_file(path));
    return "\(dir)/\(baseName).\(defaultSuffix)"
};

fn doOne(modeModule, resolver, args, sourceName) {
    def sourcePath = getSourcePath(sourceName, args);
    def outputPath = getOutputPath(sourceName, args, modeModule::SUFFIX);

    note("\
        \%q(sourcePath)
        -> \%q(outputPath)\n");

    modeModule::compile(resolver, sourcePath, outputPath);
};

export fn main(selfPath, rawArgs*) {
    note("\n\
        Starting: \%q(selfPath)
        Arguments:");
    for (arg in rawArgs) {
        note("    \%q(arg)");
    };
    note("");

    def args = $CommandLine::parseArgs(rawArgs);
    def sources = args::args;
    def modeName = MODE_MAP[args::options::mode | DEFAULT_MODE] |
        {
            note("Unknown compilation mode: \%q(args::options::mode)");
            return 1
        }();
    def modeModule = loadModule(@external("mode.\(modeName)"));

    def externalResolver = (def dirs = args::options::"external-dirs")
        & $Resolver::makeResolverChain(dirs)
        | null;
    def resolver = (def dir = args::options::"internal-dir")
        & $Resolver::makeInternalResolver(dir, externalResolver)
        | externalResolver;

    if (#sources == 0) {
        note("No source files specified!");
        return 1
    };

    if (args::options::output & (#sources > 1)) {
        note("Cannot use --output with more than one source!");
        return 1
    };

    for (s in sources) {
        doOne(modeModule, resolver, args, s)
    };
};
