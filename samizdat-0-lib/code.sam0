# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Code functions
#


#
# Helper definitions
#

# Standard "voided" generator. This is a generator, not a generator
# constructor.
fn voidedGenerator(box) {
    boxSet(box)
};

# Empty list generator. It always yields the empty list and returns
# itself. This is a generator, not a generator constructor.
fn emptyListGenerator(box) {
    boxSet(box, []);
    <> emptyListGenerator
};

# Makes a generator from a value and an `nth` function.
fn makeCollectionGenerator(value, nthFunction) {
    def size = lowSize(value);

    # Main generator maker.
    fn makeCollectionGenerator1(index) {
        <> ifIs { <> eq(index, size) }
            { <> voidedGenerator }
            {
                <> { box ::
                    boxSet(box, nthFunction(value, index));
                    <> makeCollectionGenerator1(iadd(index, 1))
                }
            }
    };

    <> makeCollectionGenerator1(0)
};

# Makes a generator for a list.
fn makeListGenerator(list) {
    <> makeCollectionGenerator(list, listNth)
};

# Makes a generator for a map.
fn makeMapGenerator(map) {
    <> makeCollectionGenerator(map, mapNth)
};

# Makes a generator for a string.
fn makeStringGenerator(string) {
    <> makeCollectionGenerator(string, stringNth)
};

# Degenerate generator maker for uniqlets, which are tacitly assumed to
# already be generators.
fn makeUniqletGenerator(uniqlet) {
    <> uniqlet
};

# Map from low-layer value types to corresponding appropriate generator
# maker functions.
def GENERATOR_MAKERS = [
    list:    makeListGenerator,
    map:     makeMapGenerator,
    string:  makeStringGenerator,
    uniqlet: makeUniqletGenerator
];

# General range generator. Takes an int starting value, an int increment,
# a "test" function (test of a value to see if it is in range), and
# a "filter" function (turn an int into the proper actual value).
#
# TODO: Use this for ranges per se and in service of the collection
# generators.
fn makeRangeGenerator(first, increment, testFunction, filterFunction) {
    # Main generator maker.
    fn makeRangeGenerator1(value) {
        <> ifIs { <> testFunction(value) }
            {
                <> { box ::
                    boxSet(box, filterFunction(value));
                    <> makeRangeGenerator1(iadd(value, increment));
                }
            }
            { <> voidedGenerator }
    };

    <> makeRangeGenerator1(first)
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn cogenerator(values*) {
    # Main generator maker, which takes a list (per se) of generators
    # as a single argument.
    fn cogenerator1(generators) {
        <> { <out> box ::
            def generatorCalls = listMap(generators)
                { ., generator ::
                    def innerBox = yieldBox();
                    <> ifValue { <> generator(innerBox) }
                        { nextGenerator ::
                            <> [boxGet(innerBox), nextGenerator]
                        }
                        {
                            boxSet(box); # Void result.
                            <out>
                        }
                };
            def yields = listMap(generatorCalls)
                { ., one :: <> listFirst(one) };
            def nexts = listMap(generatorCalls)
                { ., one :: <> listLast(one) };

            boxSet(box, yields);
            <> cogenerator1(nexts);
        }
    };

    # Handle the degenerate case of no arguments.
    ifIs { <> eq(values, []) }
        { return voidedGenerator };

    # Coerce all the original arguments to generators.
    def generators = listMap(values) { ., value :: <> generator(value) };

    # Make the initial inner call (to the function defined above).
    <> cogenerator1(generators)
};

# Documented in Samizdat Layer 0 spec.
fn forwardFunction() {
    def box = yieldBox();

    fn doForward(optFunction?, args*) {
        ifIs { <> eq(optFunction, []) }
            { io0Die("Attempt to forward to void.") };
        ifIs { <> ne(args, []) }
            { io0Die("Attempt to forward too many arguments.") };

        def function = optFunction*;

        ifNot { <> isUniqlet(function) }
            { io0Die("Attempt to forward to non-function.") };

        boxSet(box, function);
        <> function
    };

    fn forwarder(args*) {
        <> ifValue { <> boxGet(box) }
            { function :: <> function(args*) }
            { <> doForward(args*) }
    };

    <> forwarder
};

# Documented in Samizdat Layer 0 spec.
fn generator(value) {
    <> ifValue { <> mapGet(GENERATOR_MAKERS, lowType(value)) }
        { maker :: <> maker(value) }
        { io0Die("Invalid generator source.") }
};

# Documented in Samizdat Layer 0 spec.
fn listFromGenerator(value) {
    loopReduce([generator(value), []]) { result ::
        def gen = listFirst(result);
        def list = listLast(result);
        def box = yieldBox();
        <> ifValue { <> gen(box) }
            { nextGenerator :: <> [nextGenerator, [list*, boxGet(box)]] }
            { return list }
    }
};

# Documented in Samizdat Layer 0 spec.
fn optGenerator(value) {
    # Main generator maker, which takes a generator (per se) as its argument.
    fn optGenerator1(gen) {
        <> { box ::
            def innerBox = yieldBox();
            <> ifValue { <> gen(innerBox) }
                { nextGenerator ::
                    boxSet(box, [boxGet(innerBox)]);
                    <> optGenerator1(nextGenerator)
                }
                { <> emptyListGenerator(box) }
        }
    };

    <> optGenerator1(generator(value));
};

# Documented in Samizdat Layer 0 spec.
fn partialApply(function, args*) {
    <> { more* :: <> function(args*, more*) }
};

<> [
    cogenerator:       cogenerator,
    forwardFunction:   forwardFunction,
    generator:         generator,
    listFromGenerator: listFromGenerator,
    optGenerator:      optGenerator,
    partialApply:      partialApply
]
