# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Code functions
#


#
# Helper definitions
#

# Standard "voided" generator. This is a generator, not a generator
# constructor.
fn voidedGenerator() {
    <> { box ::
        boxSet(box)
    }
};

# Make a generator from a list and an index.
fn makeListGenerator(list, index) {
    ifIs { eq(index, lowSize(list)) }
        { return voidedGenerator };

    <> { box ::
        boxSet(box, listNth(list, index));
        <> makeListGenerator(list, iadd(index, 1))
    }
};

# Make a generator from a map and an index
fn makeMapGenerator(map, index) {
    ifIs { eq(map, [:]) }
        { return voidedGenerator };

    <> { box ::
        boxSet(box, mapNth(map, index));
        <> makeMapGenerator(map, iadd(index, 1))
    }
};

# Make a generator from a string and an index.
fn makeStringGenerator(string, index) {
    ifIs { eq(index, lowSize(string)) }
        { return voidedGenerator };

    <> { box ::
        boxSet(box, stringNth(string, 0));
        <> makeStringGenerator(string, iadd(index, 1))
    }
};

# Degenerate generator maker for uniqlets, which are tacitly assumed to
# already be generators.
fn makeUniqletGenerator(uniqlet, index) {
    <> uniqlet
};

# Map from low-layer value types to corresponding appropriate generator
# maker functions.
def GENERATOR_MAKERS = [
    list:    makeListGenerator,
    map:     makeMapGenerator,
    string:  makeStringGenerator,
    uniqlet: makeUniqletGenerator
];


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn cogenerator(values*) {
    # Handle the degenerate case of no arguments.
    ifIs { <> eq(values, []) }
        { return voidedGenerator };

    def size = lowSize(values);
    def generators = listMap(values) { ., value :: <> generator(value) };

    <> { box ::
        def generatorCalls = listMap(generators)
            { ., generator ::
                def innerBox = yieldBox();
                <> ifValue { <> generator(innerBox) }
                    { nextGenerator :: <> [boxGet(innerBox), nextGenerator] }
                    {
                        boxSet(box); # Void result.
                        return voidedGenerator
                    }
            };
        def yields = listMap(generatorCalls) { ., one :: <> listFirst(one) };
        def nexts = listMap(generatorCalls) { ., one :: <> listLast(one) };

        boxSet(box, yields);
        <> cogenerator(nexts*);
    }
};

# Documented in Samizdat Layer 0 spec.
fn forwardFunction() {
    def box = yieldBox();

    fn doForward(optFunction?, args*) {
        ifIs { <> eq(optFunction, []) }
            { io0Die("Attempt to forward to void.") };
        ifIs { <> ne(args, []) }
            { io0Die("Attempt to forward too many arguments.") };

        def function = optFunction*;

        ifNot { <> isUniqlet(function) }
            { io0Die("Attempt to forward to non-function.") };

        boxSet(box, function);
        <> function
    };

    fn forwarder(args*) {
        <> ifValue { <> boxGet(box) }
            { function :: <> function(args*) }
            { <> doForward(args*) }
    };

    <> forwarder
};

# Documented in Samizdat Layer 0 spec.
fn generator(value) {
    <> ifValue { <> mapGet(GENERATOR_MAKERS, lowType(value)) }
        { maker :: <> maker(value, 0) }
        { io0Die(format("Invalid generator source: %q", value)) }
};

# Documented in Samizdat Layer 0 spec.
fn partialApply(function, args*) {
    <> { more* :: <> function(args*, more*) }
};

<> [
    cogenerator:     cogenerator,
    forwardFunction: forwardFunction,
    generator:       generator,
    partialApply:    partialApply
]
