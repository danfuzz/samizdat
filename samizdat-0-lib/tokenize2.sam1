# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 2 Tokenizer
#

#
# Helper functions
#

# These are all the int digits, as a map from strings to
# digit values.
INT_CHARS = ["0"=0 "1"=1 "2"=2 "3"=3 "4"=4 "5"=5 "6"=6 "7"=7 "8"=8 "9"=9];

# Helper to convert digit characters to digit values.
intFromDigitChar = { ch :: <> mapGet(INT_CHARS, tokenType(ch)) };


#
# Grammar rules
#

# Parses whitespace and comments. **Note:** The yielded result is always
# ignored.
tokWhitespace = {/
    [" " "\n"]
|
    "#" [! "\n"]* "\n"
/};

# Parses punctuation and operators. The lookahead is done to avoid bothering
# with the choice expression unless we have a definite match.
tokPunctuation = {/
    &["-/&!@:.=+?;*<>{}()[]"]
    ("@@" | "::" | "<>" | "()" | ".." | "{/" | "/}" | .)
/};

# Parses a single character, inside a quoted string.
tokStringChar = {/
    (
        ch = [! "\\" "\""]
        { <> tokenType(ch) }
    )
|
    (
        "\\"
        (
            "\\" { <> "\\" } |
            "\"" { <> "\"" } |
            "n"  { <> "\n" } |
            "0"  { <> "\0" }
        )
    )
/};

# Parses a quoted string.
tokString = {/
    "\""
    chars = tokStringChar*
    "\""
    { <> @["string" (apply(stringAdd, chars))] }
/};

# Parses an identifier (in the usual form).
tokIdentifier = {/
    first = ["_" "a".."z" "A".."Z"]
    rest = ["_" "a".."z" "A".."Z" "0".."9"]*
    { <> @["identifier" (stringFromTokenList(listPrepend(first, rest)))] }
/};

# Parses the quoted-string identifier form.
tokQuotedIdentifier = {/
    "\\"
    s = tokString
    { <> @["identifier" (tokenValue(s))] }
/};

# Parses an integer literal.
tokInt = {/
    sign = ("-" { <> -1 } | { <> 1 })
    digits = (
        ch = ["0".."9"]
        { <> intFromDigitChar(ch) }
    )+

    {
        positiveValue = listReduce(0, digits)
            { result . digit :: <> iadd(imul(result, 10), digit) };
        <> @["int" (imul(sign, positiveValue))]
    }
/};

# "Parses" an unrecognized character. This also consumes any further characters
# on the same line, in an attempt to resynch the input.
tokError = {/
    badCh = .
    [! "\n"]*
    {
        msg = format("Unrecognized character: %q", tokenType(badCh));
        <> @["error" msg]
    }
/};

# Parses an arbitrary token or error.
#
# **Note:** Ints are parsed ahead of punctuation, so that a `-` attached
# to a digit gets interpreted as part of a negative number literal and not
# a separate operator.
tokToken = {/
    tokInt | tokPunctuation | tokString | tokIdentifier | tokQuotedIdentifier
|
    tokError
/};

# Parses a file of tokens, yielding a list of them.
tokFile = {/
    tokens=(tokWhitespace* tokToken)* tokWhitespace*
    { <> tokens }
/};


#
# Exported functions
#

# Documented in Samizdat Layer 1 spec.
sam2Tokenize = { programText ::
    <> pegApply(tokFile, programText)
};

<> [
    "sam2Tokenize" = sam2Tokenize
]
