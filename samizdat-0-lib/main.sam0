# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

# The following declares the arguments passed to the library itself.
#
# `LIBRARY_DIR` is expected to be a flat path naming the directory
# where library files may be found.

LIBRARY_DIR ->


#
# Private Definitions
#

# Reads the named library file.
fn readLibraryFile(name) {
    def path = cat(LIBRARY_DIR, "/", name);
    <> ifIs { <> Io0_flatFileExists(path) }
        { <> Io0_flatReadFileUtf8(path) }
        { Io0_die(cat("No such core library file: ", name)) }
};

# Loads the named library file in the given context, returning a map
# representing both the originally-given context *and* the bindings defined
# by the named library. Each library file is expected to return a map of
# bindings that it wishes to export.
fn loadLibrary(ctx, name) {
    def text = readLibraryFile(name);
    def tree = ctx::Lang0_parseProgram(text);
    def function = ctx::Lang0_eval({ctx*, LIBRARY: ctx}, tree);

    # Evaluating the program text/tree results in a function which, when
    # called, yields the bindings defined by that file (because that's how
    # each library file is written). If the function yields void, then
    # the file was only loaded for side effects (such as binding generic
    # functions).
    <> ifValue { <> function() }
        { bindings ->
            # The end result is the addition of the new bindings to the
            # original context.
            <> {ctx*, bindings*};
        }
        {
            # No new bindings.
            <> ctx
        }
};

# Loads the named library or module, using either `loadLibrary` or
# `loadModule` above (see which).
fn loadLibraryOrModule(ctx, name) {
    <> ifIs { <> hasType(name, List) }
        {
            def Module0 = ctx::moduleGet({name: ["core", "Module0"]});
            Io0_note(cat("    module:  ", Module0::stringFromModuleName(name)));
            <> Module0::load(ctx, LIBRARY_DIR, name)
        }
        {
            Io0_note(cat("    library: ", name));
            <> loadLibrary(ctx, name)
        }
};

# Loads all of libraries named by the manifest, in order, allowing later
# libraries to depend on earlier ones. The first listed library can depend
# only on the initial given `baseCtx` (that is, the primitive library context).
fn loadAllLibraries(baseCtx) {
    # Read the manifest file, to figure out what all to load and in what order.
    def manifest = loadLibrary(baseCtx, "manifest.sam0")::MANIFEST;

    <> loopReduce(manifest, baseCtx)
        { names, ctx ->
            <> ifValue { <> Collection_nth(names, 0) }
                { name ->
                    <> [
                        Collection_slice(names, 1),
                        loadLibraryOrModule(ctx, name)
                    ]
                }
                { return ctx }
        }
};

# Builds the final core library, by doing file loading / evaluation, and then
# adding a couple extra bindings.
fn makeCoreLibrary() {
    # Make a replacement (or new) `MODULE_PATHS` that includes `LIBRARY_DIR`.
    def modulePaths = ifValue { <> ENVIRONMENT::MODULE_PATHS }
        { orig <> cat(LIBRARY_DIR, ":", orig) }
        { <> LIBRARY_DIR };

    def newEnvironment =
        Collection_put(ENVIRONMENT, "MODULE_PATHS", modulePaths);
    def baseCtx =
        Collection_put(LIBRARY, "ENVIRONMENT", newEnvironment);

    # Do the loading.
    def fullCtx = loadAllLibraries(baseCtx);

    # "Manually inline" `makeLibrary` to produce the final core library.
    <> {fullCtx*, LIBRARY: fullCtx};
};


#
# Main Definition
#

Io0_note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

Io0_note("    [fin]");
Io0_note("");

<> CORE_LIBRARY
