# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

# The following declares the arguments passed to the library itself.
#
# `LIBRARY_DIR` is expected to be a flat path naming the directory
# where library files may be found.

LIBRARY_DIR ->


#
# Private Definitions
#

# Reads the named library file.
fn readLibraryFile(name) {
    def path = cat(LIBRARY_DIR, "/", name);
    <> ifIs { <> io0FlatFileExists(path) }
        { <> io0FlatReadFileUtf8(path) }
        { io0Die(cat("No such core library file: ", name)) }
};

# Loads the named library file in the given context, returning a map
# representing both the originally-given context *and* the bindings defined
# by the named library. Each library file is expected to return a map of
# bindings that it wishes to export.
fn loadLibrary(ctx, name) {
    io0Note(cat("    ", name));

    def text = readLibraryFile(name);
    def tree = ctx::samParseProgram(text);
    def function = ctx::samEval({ctx*:, LIBRARY: ctx}, tree);

    # Evaluating the program text/tree results in a function which, when
    # called, yields the bindings defined by that file (because that's how
    # each library file is written).
    def bindings = function();

    # The end result is the addition of the new bindings to the original
    # context.
    <> {ctx*:, bindings*:};
};

# Loads all of libraries named by the manifest, in order, allowing later
# libraries to depend on earlier ones. The first listed library can depend
# only on the initial `LIBRARY` (that is, the primitive context).
fn loadAllLibraries() {
    # Read the manifest file, to figure out what all to load and in what order.
    def manifest = loadLibrary(LIBRARY, "manifest.sam0")::MANIFEST;

    <> loopReduce(manifest, LIBRARY)
        { names, ctx ->
            <> ifValue { <> nth(names, 0) }
                { name <> [slice(names, 1), loadLibrary(ctx, name)] }
                { return ctx }
        }
};

# Builds the final core library, by doing file loading / evaluation, and then
# adding a couple extra bindings.
fn makeCoreLibrary() {
    def base = loadAllLibraries();

    # Convert `LIBRARY_DIR` to a structured path, using the appropriate
    # library function found in `base`, and wrap it in a list to become
    # the value of `MODULE_PATHS`.
    def modulePaths = [base::io0PathFromFlat(LIBRARY_DIR)];

    def full = {
        base*:,
        MODULE_PATHS: modulePaths
    };

    # "Manually" inline `makeLibrary` to produce the final core library.
    <> {full*:, LIBRARY: full};
};


#
# Main Definition
#

io0Note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

io0Note("    [fin]");
io0Note("");

<> CORE_LIBRARY
