# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

# The following declares the arguments passed to the library itself.
#
# `LIBRARY_DIR` is expected to be a flat path naming the directory
# where library files may be found.

LIBRARY_DIR ->


#
# Private Definitions
#

# Flattens a module name to a simple directory name.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Io*` modules, because this function needs to be called before any modules
# are loaded.
fn flattenName(name) {
    # Suffix each component with `/`, concatenate them all together, and
    # drop the final `/`.

    def withSlashes = filter(name, { elem <> cat(elem, "/") });
    def nearResult = cat(withSlashes*);
    <> slice(nearResult, 0, sub(sizeOf(nearResult), 1))
};

# Reads the named library file.
fn readLibraryFile(name) {
    def path = cat(LIBRARY_DIR, "/", name);
    <> ifIs { <> Io0_flatFileExists(path) }
        { <> Io0_flatReadFileUtf8(path) }
        { Io0_die(cat("No such core library file: ", name)) }
};

# Loads the named library file in the given context, returning a map
# representing both the originally-given context *and* the bindings defined
# by the named library. Each library file is expected to return a map of
# bindings that it wishes to export.
fn loadLibrary(ctx, name) {
    def text = readLibraryFile(name);
    def tree = ctx::samParseProgram(text);
    def function = ctx::samEval({ctx*, LIBRARY: ctx}, tree);

    # Evaluating the program text/tree results in a function which, when
    # called, yields the bindings defined by that file (because that's how
    # each library file is written). If the function yields void, then
    # the file was only loaded for side effects (such as binding generic
    # functions).
    <> ifValue { <> function() }
        { bindings ->
            # The end result is the addition of the new bindings to the
            # original context.
            <> {ctx*, bindings*};
        }
        {
            # No new bindings.
            <> ctx
        }
};

# Loads the named module (given a flattened directory name), installing
# it by using `moduleDef` from the given `ctx`.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Module`, because this function needs to be called before `Module` is
# fully loaded.
fn loadModule(ctx, flatName) {
    def mainText = readLibraryFile(cat(flatName, "/main.sam"));
    def infoText = readLibraryFile(cat(flatName, "/module.sam"));

    # Evaluate `mainText` as per `loadLibrary` above (same rationale),
    # but with the result becoming the module exports.
    def mainTree = ctx::samParseProgram(mainText);
    def mainFunction = ctx::samEval(ctx, mainTree);
    def exports = mainFunction();

    # Evaluate `infoText` as an expression, expecting a map.
    def info = ctx::samEval(LIBRARY, ctx::samParseExpression(infoText));

    # Combine `info` and `exports to form the final module.
    def result = @[Module: {info: info, exports: exports}];
    ctx::moduleDef(result);

    # If `info` indicates that the module is to be exported to the
    # global context, do so. Otherwise, return the original context.
    <> ifValue { <> info::globalName }
        { name <> { ctx*, (name): result } }
        { <> ctx }
};

# Loads the named library or module, using either `loadLibrary` or
# `loadModule` above (see which).
fn loadLibraryOrModule(ctx, name) {
    <> ifIs { <> hasType(name, List) }
        {
            def flatName = flattenName(name);
            Io0_note(cat("    module:  ", flatName));
            <> loadModule(ctx, flatName)
        }
        {
            Io0_note(cat("    library: ", name));
            <> loadLibrary(ctx, name)
        }
};

# Loads all of libraries named by the manifest, in order, allowing later
# libraries to depend on earlier ones. The first listed library can depend
# only on the initial given `baseCtx` (that is, the primitive library context).
fn loadAllLibraries(baseCtx) {
    # Read the manifest file, to figure out what all to load and in what order.
    def manifest = loadLibrary(baseCtx, "manifest.sam0")::MANIFEST;

    <> loopReduce(manifest, baseCtx)
        { names, ctx ->
            <> ifValue { <> nth(names, 0) }
                { name <> [slice(names, 1), loadLibraryOrModule(ctx, name)] }
                { return ctx }
        }
};

# Builds the final core library, by doing file loading / evaluation, and then
# adding a couple extra bindings.
fn makeCoreLibrary() {
    # Make a replacement (or new) `MODULE_PATHS` that includes `LIBRARY_DIR`.
    def modulePaths = ifValue { <> ENVIRONMENT::MODULE_PATHS }
        { orig <> cat(LIBRARY_DIR, ":", orig) }
        { <> LIBRARY_DIR };

    def newEnvironment = put(ENVIRONMENT, "MODULE_PATHS", modulePaths);
    def baseCtx = put(LIBRARY, "ENVIRONMENT", newEnvironment);

    # Do the loading.
    def fullCtx = loadAllLibraries(baseCtx);

    # "Manually inline" `makeLibrary` to produce the final core library.
    <> {fullCtx*, LIBRARY: fullCtx};
};


#
# Main Definition
#

Io0_note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

Io0_note("    [fin]");
Io0_note("");

<> CORE_LIBRARY
