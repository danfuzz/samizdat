# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

# The following declares the arguments passed to the library itself.
#
# `LIBRARY_DIR` is expected to be a flat path naming the directory
# where library files may be found.

LIBRARY_DIR ->


#
# Private Definitions
#

# Flattens a module name to a simple directory name.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `io0*`, because this function needs to be called before `io0*` is loaded.
fn flattenName(name) {
    # Suffix each component with `/`, and concatenate them all together.
    def withSlashes = filter(name, { elem <> cat(elem, "/") });
    <> cat(withSlashes*)
};

# Reads the named library file.
fn readLibraryFile(name) {
    def path = cat(LIBRARY_DIR, "/", name);
    <> ifIs { <> io0FlatFileExists(path) }
        { <> io0FlatReadFileUtf8(path) }
        { io0Die(cat("No such core library file: ", name)) }
};

# Loads the named library file in the given context, returning a map
# representing both the originally-given context *and* the bindings defined
# by the named library. Each library file is expected to return a map of
# bindings that it wishes to export.
fn loadLibrary(ctx, name) {
    def text = readLibraryFile(name);
    def tree = ctx::samParseProgram(text);
    def function = ctx::samEval({ctx*, LIBRARY: ctx}, tree);

    # Evaluating the program text/tree results in a function which, when
    # called, yields the bindings defined by that file (because that's how
    # each library file is written).
    def bindings = function();

    # The end result is the addition of the new bindings to the original
    # context.
    <> {ctx*, bindings*};
};

# Loads the named module (given a flattened directory name), installing
# it by using `moduleDef` from the given `ctx`.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Module`, because this function needs to be called before `Module` is
# fully loaded.
fn loadModule(ctx, flatName) {
    def mainText = readLibraryFile(cat(flatName, "main.sam"));
    def infoText = readLibraryFile(cat(flatName, "module.sam"));

    # Evaluate `mainText` as per `loadLibrary` above (same rationale),
    # but with the result becoming the module exports.
    def mainTree = ctx::samParseProgram(mainText);
    def mainFunction = ctx::samEval(ctx, mainTree);
    def exports = mainFunction();

    # Evaluate `infoText` as an expression, expecting a map.
    def info = ctx::samEval(LIBRARY, ctx::samParseExpression(infoText));

    # Combine `info` and `exports to form the final module.
    def result = @[Module: {info: info, exports: exports}];
    ctx::moduleDef(result);
};

# Loads the named library or module, using either `loadLibrary` or
# `loadModule` above (see which).
fn loadLibraryOrModule(ctx, name) {
    <> ifIs { <> hasType(name, List) }
        {
            def flatName = flattenName(name);
            io0Note(cat("    module:  ", flatName));
            loadModule(ctx, flatName);
            <> ctx
        }
        {
            io0Note(cat("    library: ", name));
            <> loadLibrary(ctx, name)
        }
};

# Loads all of libraries named by the manifest, in order, allowing later
# libraries to depend on earlier ones. The first listed library can depend
# only on the initial given `baseCtx` (that is, the primitive library context).
fn loadAllLibraries(baseCtx) {
    # Read the manifest file, to figure out what all to load and in what order.
    def manifest = loadLibrary(baseCtx, "manifest.sam0")::MANIFEST;

    <> loopReduce(manifest, baseCtx)
        { names, ctx ->
            <> ifValue { <> nth(names, 0) }
                { name <> [slice(names, 1), loadLibraryOrModule(ctx, name)] }
                { return ctx }
        }
};

# Builds the final core library, by doing file loading / evaluation, and then
# adding a couple extra bindings.
fn makeCoreLibrary() {
    # Make a replacement (or new) `MODULE_PATHS` that includes `LIBRARY_DIR`.
    def modulePaths = ifValue { <> ENVIRONMENT::MODULE_PATHS }
        { orig <> cat(LIBRARY_DIR, ":", orig) }
        { <> LIBRARY_DIR };

    def newEnvironment = put(ENVIRONMENT, "MODULE_PATHS", modulePaths);
    def baseCtx = put(LIBRARY, "ENVIRONMENT", newEnvironment);

    # Do the loading.
    def fullCtx = loadAllLibraries(baseCtx);

    # "Manually inline" `makeLibrary` to produce the final core library.
    <> {fullCtx*, LIBRARY: fullCtx};
};


#
# Main Definition
#

io0Note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

io0Note("    [fin]");
io0Note("");

<> CORE_LIBRARY
