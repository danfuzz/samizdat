# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

# The following declares the arguments passed to the library itself.
#
# `LIBRARY_DIR` is expected to be a flat path naming the directory
# where library files may be found.

LIBRARY_DIR ->


#
# Private Definitions
#

# Flattens a module name to a simple directory name.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Io*` modules, because this function needs to be called before any modules
# are loaded.
fn flattenName(name) {
    # Suffix each component with `/`, concatenate them all together, and
    # drop the final `/`.

    def withSlashes = Generator_filter(name, { elem <> cat(elem, "/") });
    def nearResult = cat(withSlashes*);
    <> Collection_slice(
        nearResult,
        0,
        Number_sub(Collection_sizeOf(nearResult), 1))
};

# Reads the named library file.
fn readLibraryFile(name) {
    def path = cat(LIBRARY_DIR, "/", name);
    <> ifIs { <> Io0_flatFileExists(path) }
        { <> Io0_flatReadFileUtf8(path) }
        { Io0_die(cat("No such core library file: ", name)) }
};

# Loads the named library file in the given context, returning a map
# representing both the originally-given context *and* the bindings defined
# by the named library. Each library file is expected to return a map of
# bindings that it wishes to export.
fn loadLibrary(ctx, name) {
    def text = readLibraryFile(name);
    def tree = ctx::Lang0_parseProgram(text);
    def function = ctx::Lang0_eval({ctx*, LIBRARY: ctx}, tree);

    # Evaluating the program text/tree results in a function which, when
    # called, yields the bindings defined by that file (because that's how
    # each library file is written). If the function yields void, then
    # the file was only loaded for side effects (such as binding generic
    # functions).
    <> ifValue { <> function() }
        { bindings ->
            # The end result is the addition of the new bindings to the
            # original context.
            <> {ctx*, bindings*};
        }
        {
            # No new bindings.
            <> ctx
        }
};

# Makes a submodule global context, based on the given `baseCtx` and which
# adds submodule read and load functions that use the given `directory` (a
# flat path).
fn makeModuleContext(baseCtx, directory) {
    # A box for the final load context, to enable the necessary self-reference.
    def ctxBox = Box_makeYieldBox();

    # A box for all the loaded submodules.
    def subsBox = Box_makeMutableBox({});

    fn submoduleRead(name) {
        Io0_note(cat("                 ", name));
        <> readLibraryFile(cat(directory, "/", name))
    };

    fn submoduleLoad(name) {
        def ctx = Box_fetch(ctxBox);
        def text = submoduleRead(cat(name, ".sam"));
        def tree = ctx::submoduleParse(text);
        def func = ctx::submoduleEval(ctx, tree);
        <> func()
    };

    fn submoduleUse(name) {
        ifValue { <> get(Box_fetch(subsBox), name) }
            { value -> return value };

        def result = ifValue { <> submoduleLoad(name) }
            { r <> r }
            { <> {} };

        Box_store(subsBox, {(Box_fetch(subsBox))*, (name): result});
        <> result
    };

    # This must evaluate to a map.
    def moduleInfo = Lang0_eval(baseCtx,
        Lang0_parseExpression(submoduleRead("module.sam")));

    def languageName = moduleInfo::language;
    def languageModule = ifIs { <> ne(languageName, "none") }
        { <> baseCtx::moduleGet({name: ["core", languageName]}) }
        {
            # Fall-back used when loading modules before `Lang0` is defined.
            <> {
                eval:         Lang0_eval,
                parseProgram: Lang0_parseProgram
            }
        };

    def fullCtx = {
        baseCtx*,
        moduleInfo:     moduleInfo,
        submoduleEval:  languageModule::eval,
        submoduleUse:   submoduleUse,
        submoduleParse: languageModule::parseProgram,
        submoduleRead:  submoduleRead
    };

    Box_store(ctxBox, fullCtx);
    <> fullCtx
};

# Loads the named module (given a fully-qualified name), using a
# global context based on the given `baseCtx`.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Module`, because this function needs to be called before `Module` is
# fully loaded.
fn loadModule(baseCtx, name) {
    def flatName = flattenName(name);
    def ctx = makeModuleContext(baseCtx, flatName);

    # This must evaluate to a map.
    def exports = ctx::submoduleUse("main");

    # Combine `moduleInfo` and `exports` to form the final module value.
    def result = @[Module: {info: ctx::moduleInfo, exports: exports}];
    ctx::moduleDef(result);

    # If `moduleInfo` indicates that the module is to be exported to the
    # global context, do so. Otherwise, return the original context.
    <> ifValue { <> ctx::moduleInfo::globalName }
        { name <> { baseCtx*, (name): result } }
        { <> baseCtx }
};

# Loads the named library or module, using either `loadLibrary` or
# `loadModule` above (see which).
fn loadLibraryOrModule(ctx, name) {
    <> ifIs { <> hasType(name, List) }
        {
            def Module0 = ctx::moduleGet({name: ["core", "Module0"]});
            Io0_note(cat("    module:  ", Module0::stringFromModuleName(name)));
            <> loadModule(ctx, name)
        }
        {
            Io0_note(cat("    library: ", name));
            <> loadLibrary(ctx, name)
        }
};

# Loads all of libraries named by the manifest, in order, allowing later
# libraries to depend on earlier ones. The first listed library can depend
# only on the initial given `baseCtx` (that is, the primitive library context).
fn loadAllLibraries(baseCtx) {
    # Read the manifest file, to figure out what all to load and in what order.
    def manifest = loadLibrary(baseCtx, "manifest.sam0")::MANIFEST;

    <> loopReduce(manifest, baseCtx)
        { names, ctx ->
            <> ifValue { <> Collection_nth(names, 0) }
                { name ->
                    <> [
                        Collection_slice(names, 1),
                        loadLibraryOrModule(ctx, name)
                    ]
                }
                { return ctx }
        }
};

# Builds the final core library, by doing file loading / evaluation, and then
# adding a couple extra bindings.
fn makeCoreLibrary() {
    # Make a replacement (or new) `MODULE_PATHS` that includes `LIBRARY_DIR`.
    def modulePaths = ifValue { <> ENVIRONMENT::MODULE_PATHS }
        { orig <> cat(LIBRARY_DIR, ":", orig) }
        { <> LIBRARY_DIR };

    def newEnvironment =
        Collection_put(ENVIRONMENT, "MODULE_PATHS", modulePaths);
    def baseCtx =
        Collection_put(LIBRARY, "ENVIRONMENT", newEnvironment);

    # Do the loading.
    def fullCtx = loadAllLibraries(baseCtx);

    # "Manually inline" `makeLibrary` to produce the final core library.
    <> {fullCtx*, LIBRARY: fullCtx};
};


#
# Main Definition
#

Io0_note("Loading core library...");

def CORE_LIBRARY = makeCoreLibrary();

Io0_note("    [fin]");
Io0_note("");

<> CORE_LIBRARY
