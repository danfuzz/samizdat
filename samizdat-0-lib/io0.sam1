# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Baseline I/O functions
#


#
# Helper functions
#

# Parses a single path component.
def parPathComponent = {/
    # Ignore duplicate slashes, but require at least one. Note: The parser
    # is only ever called on a string that begins with a slash.
    "/"+

    # Match the component text. This is a `*` and not a `+` rule, in order to
    # successfully match a string-final empty component (that is, a trailing
    # slash on the overall path string).
    component = [! "/"]*
    { <> stringFromTokenList(component) }
/};

# Parses a regular (non-up-directory) component. The `..` check ensures that
# `..` only gets parsed as part of a balanced `name/..` pair.
def parRegularComponent = {/
    component = parPathComponent
    {
        <> ifIs { <> ne(component, "..") }
            { <> [component] }
    }
/};

# Parses a matched set of components that are collectively ignored, e.g.
# `"/x/y/../.."` or `"/."`.
def parIgnoredComponent = forwardFunction();
def implIgnoredComponent = {/
    component = parPathComponent

    (
        { <> eq(component, ".") }
    |
        parIgnoredComponent?
        dotdot = parPathComponent
        { <> eq(dotdot, "..") }
    )

    { <> [] }
/};
parIgnoredComponent(implIgnoredComponent);

# Helper for `io0PathFromFlat` which parses absolute path strings
# into components. This canonicalizes the path by ignoring duplicate
# slashes, `.` components, and matched `name/..` pairs.
def parPathString = {/
    components = (parIgnoredComponent | parRegularComponent)+

    (
        .
        { <> "Invalid `..` component in path" }
    |
        { <> listAdd(components*) }
    )
/};

# Helper for `io0FlatFromPath` which validates a single path component.
# Yields an error string on invalid. Parsing fails for valid components.
def parErrorFromPathComponent = {/
    ".." !.
    { <> "Invalid `..` component in path" }
|
    "." !.
    { <> "Invalid `.` component in path" }
|
    !.
    { <> "Invalid empty component in path" }
|
    [! "/\0"]+
    (
        "/"
        { <> "Invalid `/` in path" }
    |
        "\0"
        { <> "Invalid `\\0` in path" }
    )
/};

# Checks whether the given alleged prefix is actually a prefix of the
# given path, or equal to it.
fn isPrefix(prefix, path) {
    def prefixSize = coreSizeOf(prefix);

    ifIs { <> gt(prefixSize, coreSizeOf(path)) }
        {
            # The "prefix" is longer than the path, so it can't actually be
            # a prefix.
            return
        };

    <> eq(prefix, listSlice(path, 0, prefixSize))
};

# Dies with the given message including the given path.
fn dieWith(msg, path) {
    io0Die(stringAdd(msg, ": ", sourceString(path)))
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn io0FlatFromPath(path) {
    ifIs { <> eq(path, []) }
        { dieWith("Invalid empty path", path) };

    def gen = filterGenerator(path, openRange(coreSizeOf(path), -1))
        { <out> one, n ::
            # This test skips the check on the last path component, if it
            # happens to be empty (which is the only valid case of an empty
            # path component).
            ifIs { <> eq([one, n], ["", 1]) }
                { <out> "/" }
                {
                    ifValue { <> pegApply(parErrorFromPathComponent, one) }
                        { error :: dieWith(error, path) }
                };
            <> stringAdd("/", one)
        };

    <> stringAdd(gen*)
};

# Documented in Samizdat Layer 0 spec.
fn io0PathFromFlat(string) {
    # Reject the empty string.
    ifIs { <> eq(string, "") }
        { dieWith("Invalid path", "") };

    # Prepend the current directory if the path isn't absolute.
    def absoluteString = ifIs { <> eq(stringNth(string, 0), "/") }
        { <> string }
        { <> stringAdd(io0FlatCwd(), "/", string) };

    # Parse the string into components (or an error string).
    def components = pegApply(parPathString, absoluteString);

    ifIs { <> isString(components) }
        { dieWith(components, string) };

    <> components
};

# Documented in Samizdat Layer 0 spec.
fn io0ReadFileUtf8(path) {
    <> io0FlatReadFileUtf8(io0FlatFromPath(path))
};

# Documented in Samizdat Layer 0 spec.
fn io0ReadLink(path) {
    <> ifValue { <> io0FlatReadLink(io0FlatFromPath(path)) }
        { newPath <> io0PathFromFlat(newPath) }
};

# Helper for `io0SandboxedReader` which does symbolic link resolution,
# respecting the sandbox directory.
#
# This is located in the "exported" section, as it makes use of
# the exported function `io0ReadLink`, defined above.
fn resolveLinks(sandboxDirectory, path) {
    loopReduce(path, 50) { path, limit ::
        ifIs { <> le(limit, 0) }
            { io0Die("Too many links in symbolic link chain.") };
        ifNot { <> isPrefix(sandboxDirectory, path) }
            { io0Die("Symbolic link escapes sandbox directory.") };

        <> ifValue { <> io0ReadLink(path) }
            { newPath <> [newPath, (isub(limit, 1))] }
            { return path }
    }
};

# Documented in Samizdat Layer 0 spec.
fn io0SandboxedReader(directory) {
    <> { path ::
        def fullPath = resolveLinks(directory, [directory*, path*]);
        <> io0ReadFileUtf8(fullPath);
    }
};

# Documented in Samizdat Layer 0 spec.
fn io0WriteFileUtf8(path, text) {
    <> io0FlatWriteFileUtf8(io0FlatFromPath(path), text)
};

<> [
    io0FlatFromPath:    io0FlatFromPath,
    io0PathFromFlat:    io0PathFromFlat,
    io0ReadFileUtf8:    io0ReadFileUtf8,
    io0ReadLink:        io0ReadLink,
    io0SandboxedReader: io0SandboxedReader,
    io0WriteFileUtf8:   io0WriteFileUtf8
];
