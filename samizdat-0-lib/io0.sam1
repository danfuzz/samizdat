# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Baseline I/O functions
#


#
# Helper functions
#

# Helper for `io0PathFromFlat` which parses absolute path strings
# into components. Notably, this takes care of ignoring double slashes
# (or triple, etc.) and `.` components, but it leaves the handling of
# `..` components to a higher layer.
def parPathString = {/
    (
        ("/"+ "." &"/")*
        "/"+
        !("." !.)

        # This is a `*` and not a `+` rule, in order to successfully
        # match a string-final empty component (that is, a trailing slash).
        component = [! "/"]*
        { <> stringFromTokenList(component) }
    )+
/};

# Helper for `io0FlatFromPath` which validates a single path component.
# Yields an error string on invalid. Parsing fails for valid components.
def parErrorFromPathComponent = {/
    ".." !.
    { <> "Invalid `..` component in path" }
|
    "." !.
    { <> "Invalid `.` component in path" }
|
    [! "/\0"]+
    (
        "/"
        { <> "Invalid `/` in path" }
    |
        "\0"
        { <> "Invalid `\\0` in path" }
    )
/};

# Checks whether the given alleged prefix is actually a prefix of the
# given path, or equal to it.
fn isPrefix(prefix, path) {
    def prefixSize = lowSize(prefix);

    ifIs { <> gt(prefixSize, lowSize(path)) }
        {
            # The "prefix" is longer than the path, so it can't actually be
            # a prefix.
            return
        };

    <> eq(prefix, listSlice(path, 0, prefixSize))
};

# Dies with the given message including the given path.
fn dieWith(msg, path) {
    io0Die(stringAdd(msg, ": ", sourceString(path)))
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn io0FlatFromPath(path) {
    <> listReduce("", path) { result, n, one ::
        ifValue { <> pegApply(parErrorFromPathComponent, one) }
            { error :: dieWith(error, path) };
        ifIs
            { <> and { <> eq(one, "") } { <> ne(n, isub(lowSize(path), 1)) } }
            { dieWith("Invalid empty component in path", path) };
        <> stringAdd(result, "/", one)
    }
};

# Documented in Samizdat Layer 0 spec.
fn io0PathFromFlat(string) {
    # Reject the empty string.
    ifIs { <> eq(string, "") }
        { io0Die("Invalid path (empty).") };

    # Prepend the current directory if the path isn't absolute.
    def absoluteString = ifIs { <> eq(stringNth(string, 0), "/") }
        { <> string }
        { <> stringAdd(io0FlatCwd(), "/", string) };

    # Do the first layer of parsing.
    def components = pegApply(parPathString, absoluteString);

    # Handle `..` components, to produce the final result.
    <> listReduce([], components) { result, ., one ::
        <> ifIs { <> eq(one, "..") }
            {
                ifIs { <> eq(result, []) }
                    { dieWith("Invalid `..` component in path", string) };
                <> listButLast(result)
            }
            { <> [result*, one] }
    }
};

# Documented in Samizdat Layer 0 spec.
fn io0ReadFileUtf8(path) {
    <> io0FlatReadFileUtf8(io0FlatFromPath(path))
};

# Documented in Samizdat Layer 0 spec.
fn io0ReadLink(path) {
    <> ifValue { <> io0FlatReadLink(io0FlatFromPath(path)) }
        { newPath :: <> io0PathFromFlat(newPath) }
};

# Helper for `io0SandboxedReader` which does symbolic link resolution,
# respecting the sandbox directory.
#
# This is located in the "exported" section, as it makes use of
# the exported function `io0ReadLink`, defined above.
fn resolveLinks(sandboxDirectory, path) {
    loopReduce(path, 50) { path, limit ::
        ifIs { <> le(limit, 0) }
            { io0Die("Too many links in symbolic link chain.") };
        ifNot { <> isPrefix(sandboxDirectory, path) }
            { io0Die("Symbolic link escapes sandbox directory.") };

        <> ifValue { <> io0ReadLink(path) }
            { newPath :: <> [newPath, (isub(limit, 1))] }
            { return path }
    }
};

# Documented in Samizdat Layer 0 spec.
fn io0SandboxedReader(directory) {
    <> { path ::
        def fullPath = resolveLinks(directory, [directory*, path*]);
        <> io0ReadFileUtf8(fullPath);
    }
};

# Documented in Samizdat Layer 0 spec.
fn io0WriteFileUtf8(path, text) {
    <> io0FlatWriteFileUtf8(io0FlatFromPath(path), text)
};

<> [
    io0FlatFromPath: io0FlatFromPath,
    io0PathFromFlat: io0PathFromFlat,
    io0ReadFileUtf8: io0ReadFileUtf8,
    io0ReadLink: io0ReadLink,
    io0SandboxedReader: io0SandboxedReader,
    io0WriteFileUtf8: io0WriteFileUtf8
];
