# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

#
# Helper functions
#

# Generic reduce function, which in addition to the three arguments
# accepted by the exported reduce functions, also takes the size of
# the value to be reduced and the function to get the `nth` element
# from the value.
generalReduce = { base value func size nthFunc ::
    doReduce = { reduction index ::
        <> ifTrue { <> eq index size }
            { <> reduction }
            {
                <> doReduce
                    (func reduction (nthFunc value index) index)
                    (iadd index @1)
            }
    };

    <> doReduce base @0
};


#
# Exported definitions
#

# Documented in Samizdat Layer 0 spec.
null = [:@null:];

# Documented in Samizdat Layer 0 spec.
eq = { v1 v2 :: <> lowOrderIs v1 v2 @0 };

# Documented in Samizdat Layer 0 spec.
ne = { v1 v2 :: <> lowOrderIs v1 v2 @-1 @1 };

# Documented in Samizdat Layer 0 spec.
lt = { v1 v2 :: <> lowOrderIs v1 v2 @-1 };

# Documented in Samizdat Layer 0 spec.
gt = { v1 v2 :: <> lowOrderIs v1 v2 @1 };

# Documented in Samizdat Layer 0 spec.
le = { v1 v2 :: <> lowOrderIs v1 v2 @-1 @0 };

# Documented in Samizdat Layer 0 spec.
ge = { v1 v2 :: <> lowOrderIs v1 v2 @1 @0 };

# Documented in Samizdat Layer 0 spec.
not = { value ::
    <> ifTrue { <> eq value true }
        { <> false }
        {
            <> ifTrue { <> eq value false }
                { <> true }
                { die @"Non-boolean argument to `not`." }
        }
};

# Documented in Samizdat Layer 0 spec.
if = { predicate consequent rest* ::
    <> ifTrue predicate
        consequent
        # Note: `{}` by definition is a function that returns void.
        { <> ifTrue { <> eq rest @[] } {} { <> apply if rest } }
};

# Documented in Samizdat Layer 0 spec.
else = { <> true };

# Documented in Samizdat Layer 0 spec.
and = { predicate rest* ::
    <> ifTrue predicate
        { <> ifTrue { <> eq rest @[] } { <> true } { <> apply and rest } }
        { <> false }
};

# Documented in Samizdat Layer 0 spec.
or = { predicate rest* ::
    <> ifTrue predicate
        { <> true }
        { <> ifTrue { <> eq rest @[] } { <> false } { <> apply and rest } }
};

# Documented in Samizdat Layer 0 spec.
listletAppend = { listlet value ::
    <> listletInsNth listlet (lowSize listlet) value
};

# Documented in Samizdat Layer 0 spec.
listletPrepend = { value listlet ::
    <> listletInsNth listlet @0 value
};

# Documented in Samizdat Layer 0 spec.
listletReduce = { base listlet func ::
    <> generalReduce base listlet func (lowSize listlet) listletNth
};

# Documented in Samizdat Layer 0 spec.
listletMap = { listlet func ::
    <> listletReduce @[] listlet
        { reduction value index ::
            <> listletAppend reduction (func value index)
        }
};

# Documented in Samizdat Layer 0 spec.
listletCat = { listlet rest* ::
    <> listletReduce listlet rest
        { reduction value :: <> listletAdd reduction value }
};

# Documented in Samizdat Layer 0 spec.
stringletReduce = { base stringlet func ::
    <> generalReduce base stringlet func (lowSize stringlet) stringletNth
};

# Documented in Samizdat Layer 0 spec.
stringletMap = { stringlet func ::
    <> stringletReduce @[] stringlet
        { reduction value index ::
            <> listletAppend reduction (func value index)
        }
};

# Documented in Samizdat Layer 0 spec.
stringletCat = { stringlet rest* ::
    <> listletReduce stringlet rest
        { reduction value :: <> stringletAdd reduction value }
};

# Documented in Samizdat Layer 0 spec.
mapletReduce = { base maplet func ::
    <> listletReduce base (mapletKeys maplet)
        { reduction key :: <> func reduction (mapletGet maplet key) key }
};

# Documented in Samizdat Layer 0 spec.
mapletMap = { maplet func ::
    <> mapletReduce @[=] maplet
        { reduction value key :: <> mapletPut reduction key (func value key) }
};

# Documented in Samizdat Layer 0 spec.
mapletCat = { maplet rest* ::
    <> listletReduce maplet rest
        { reduction value :: <> mapletAdd reduction value }
};

# Documented in Samizdat Layer 0 spec.
isIntlet = { value ::
    <> eq (lowType value) @intlet
};

# Documented in Samizdat Layer 0 spec.
isStringlet = { value ::
    <> eq (lowType value) @stringlet
};

# Documented in Samizdat Layer 0 spec.
isListlet = { value ::
    <> eq (lowType value) @listlet
};

# Documented in Samizdat Layer 0 spec.
isMaplet = { value ::
    <> eq (lowType value) @maplet
};

# Documented in Samizdat Layer 0 spec.
isUniqlet = { value ::
    <> eq (lowType value) @uniqlet
};

# Documented in Samizdat Layer 0 spec.
isHighlet = { value ::
    <> eq (lowType value) @highlet
};

# Documented in Samizdat Layer 0 spec.
sourceStringlet = { value ::
    intletBody = { start value ::
        <> if { <> eq value @0 } {
            <> start
        } else {
            digit = iadd (imod value @10) @48;   # 48 == "0"
            more = idiv value @10;
            <> stringletAdd (intletBody start more) (stringletFromIntlet digit)
        }
    };

    intletHex = { value ::
        <> if { <> eq value @0 } {
            <> @""
        } else {
            digit = stringletNth @"0123456789abcdef" (imod value @16);
            more = idiv value @16;
            <> stringletAdd (intletHex more) digit
        }
    };

    # Single-character stringlets `@"\0"` `@"\x7f;"` and `@"\x9f;"`.
    CHAR0 = stringletFromIntlet @0;
    CHAR127 = stringletFromIntlet @127;
    CHAR159 = stringletFromIntlet @159;

    stringletChar = { ch ::
        <> if { <> eq ch CHAR0 } {
            <> @"\\0"
        } { <> eq ch @"\n" } {
            <> @"\\n"
        } { <> or { <> eq ch @"\"" } { <> eq ch @"\\" } } {
            <> stringletAdd @"\\" ch
        } { <> or { <> lt ch @" " }
                  { <> and { <> ge ch CHAR127 } { <> le ch CHAR159 } } } {
            # These are the ranges for nonprinting control characters.
            <> stringletCat @"\\x" (intletHex (intletFromStringlet ch)) @";"
        } else {
            <> ch
        }
    };

    <> if { <> eq value @[] } {
        <> @"@[]"
    } { <> eq value @[=] } {
        <> @"@[=]"
    } { <> isIntlet value } {
        <> if { <> eq value @0 } {
            <> @"@0"
        } { <> gt value @0 } {
            <> intletBody @"@" value
        } else {
            <> intletBody @"@-" (ineg value)
        }
    } { <> isStringlet value } {
        body = stringletReduce @"" value
            { reduction ch :: <> stringletAdd reduction (stringletChar ch) };
        <> stringletCat @"@\"" body @"\""
    } { <> isListlet value } {
        body = listletReduce @"" value
            { reduction elem ::
                <> stringletCat
                    reduction
                    (if { <> eq reduction @"" } { <> @"" } else { <> @" " })
                    (sourceStringlet elem)
            };
        <> stringletCat @"@[" body @"]"
    } { <> isMaplet value } {
        body = mapletReduce @"" value
            { reduction value key ::
                <> stringletCat
                    reduction
                    (if { <> eq reduction @"" } { <> @"" } else { <> @" " })
                    (sourceStringlet key)
                    @"="
                    (sourceStringlet value)
            };
        <> stringletCat @"@[" body @"]"
    } { <> isHighlet value } {
        type = highletType value;
        <> stringletCat
            @"[:"
            (sourceStringlet type)
            (ifValue { <> highletValue value }
                { v :: <> stringletAdd @" " (sourceStringlet v) }
                { <> @"" })
            @":]"
    } { <> isUniqlet value } {
        <> @"@@"
    } else {
        <> stringletCat
            @"@[(unknown) "
            (sourceStringlet (lowType value))
            @" "
            (sourceStringlet (lowSize value))
            @"]"
    }
};

# Documented in Samizdat Layer 0 spec.
sam0Library = {
    <> CORELIB   # Defined toward the bottom of the file.
};


#
# Export mechanics
#

# Maplet of all of the core library bindings. Note that
# this has to be placed *after* all the core definitions in order
# to execute in a context where they're all in scope.
CORELIB = mapletAdd PRIMLIB @[
    @eq = eq
    @ne = ne
    @lt = lt
    @gt = gt
    @le = le
    @ge = ge
    @and = and
    @else = else
    @if = if
    @isHighlet = isHighlet
    @isIntlet = isIntlet
    @isListlet = isListlet
    @isMaplet = isMaplet
    @isStringlet = isStringlet
    @isUniqlet = isUniqlet
    @listletAppend = listletAppend
    @listletCat = listletCat
    @listletMap = listletMap
    @listletPrepend = listletPrepend
    @listletReduce = listletReduce
    @mapletCat = mapletCat
    @mapletMap = mapletMap
    @mapletReduce = mapletReduce
    @not = not
    @null = null
    @or = or
    @sam0Library = sam0Library
    @sourceStringlet = sourceStringlet
    @stringletCat = stringletCat
    @stringletMap = stringletMap
    @stringletReduce = stringletReduce
];

<> CORELIB

