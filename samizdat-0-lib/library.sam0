# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. See the associated file "LICENSE.md" for details.

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

# The value more commonly known as `null`.
null = [:@"null":];

# "Equal" comparison in overall value order.
eq = { v1 v2 :: <> lowOrderIs v1 v2 @0; };

# "Not equal" comparison in overall value order.
ne = { v1 v2 :: <> lowOrderIs v1 v2 @-1 @1; };

# "Less than" comparison in overall value order.
lt = { v1 v2 :: <> lowOrderIs v1 v2 @-1; };

# "Greater than" comparison in overall value order.
gt = { v1 v2 :: <> lowOrderIs v1 v2 @1; };

# "Less than or equal" comparison in overall value order.
le = { v1 v2 :: <> lowOrderIs v1 v2 @-1 @0; };

# "Greater than or equal" comparison in overall value order.
ge = { v1 v2 :: <> lowOrderIs v1 v2 @1 @0; };

# Boolean not. The given argument must be a boolean.
not = { value ::
    <> ifElse (eq value true)
        { <> false; }
        {
            <> ifElse (eq value false)
                { <> true; }
                { die @"Non-boolean argument to `not`."; };
        };
};

# Cascading conditional. Takes an even number of arguments,
# alternating predicates and consequents. The predicates are run in
# order until one returns `true`. The consequent immediately after the
# `true` predicate then gets run, and its return value becomes the
# result of this function. If no predicate returns `true`, this
# function returns `void` (that is, a non-value).
if = { predicate consequent rest* ::
    <> ifElse (predicate())
        consequent
        # Note: `{}` by definition is a function that returns void.
        { <> ifElse (eq rest @[]) {} { <> apply if rest; }; };
};

# Function to use as the final catch-all predicate in an `if` call.
else = { <> true; };

# Short-circuit conjunction. Takes an arbitrary number of predicates.
# Runs each of them in turn until one of them returns `false`. If no
# predicate returns `false`, this function returns `true`.
and = { predicate rest* ::
    <> ifElse (predicate())
        { <> ifElse (eq rest @[]) { <> true; } { <> apply and rest; }; }
        { <> false; };
};

# Short-circuit disjunction. Takes an arbitrary number of predicates.
# Runs each of them in turn until one of them returns `true`. If no
# predicate returns `true`, this function returns `false`.
or = { predicate rest* ::
    <> ifElse (predicate())
        { <> true; }
        { <> ifElse (eq rest @[]) { <> false; } { <> apply and rest; }; };
};

# Reduces a listlet to a single value, given a base value and a
# reducer function, operating in low-to-high index order (that is,
# this is a left-reduce operation). The given function is called on
# each value, with three arguments: the last reduction result, the
# value, and its index number.
#
# Note: Unlike many other languages with similar functions, the
# function argument is the *last* one and not the *first* one. This is
# specifically done to make it natural to write a multi-line function
# without losing track of the other two arguments.
reduce = { base listlet func ::
    size = lowSize listlet;

    doReduce = { reduction index ::
        <> ifElse (eq index size)
            { <> reduction; }
            {
                <> doReduce
                    (func reduction (listletNth listlet index) index)
                    (iadd index @1);
            };
    };

    <> doReduce base @0;
};

# Maps each value of a listlet, collecting the results into a new
# listlet. The given function is called on each value, with two
# arguments, namely the value and its index number.
#
# Note: Unlike many other languages with similar functions, the
# function argument is the *last* one and not the *first* one. This is
# specifically done to make it natural to write a multi-line function
# without losing track of the listlet argument.
listletMap = { listlet func ::
    <> reduce @[] listlet
        { reduction value index ::
            <> listletAppend reduction (func value index);
        };
};


# Concatenates one or more listlets together into a single resulting
# listlet.
listletCat = { listlet rest* ::
    <> reduce listlet rest
        { reduction value :: <> listletAdd reduction value; };
};

# Concatenates one or more stringlets together into a single resulting
# stringlet.
stringletCat = { stringlet rest* ::
    <> reduce stringlet rest
        { reduction value :: <> stringletAdd reduction value; };
};

# Returns true iff the given value is an intlet.
isIntlet = { value ::
    <> eq (lowType value) @"intlet";
};

# Returns true iff the given value is a stringlet.
isStringlet = { value ::
    <> eq (lowType value) @"stringlet";
};

# Returns true iff the given value is a listlet.
isListlet = { value ::
    <> eq (lowType value) @"listlet";
};

# Returns true iff the given value is a maplet.
isMaplet = { value ::
    <> eq (lowType value) @"maplet";
};

# Returns true iff the given value is a uniqlet.
isUniqlet = { value ::
    <> eq (lowType value) @"uniqlet";
};

# Returns true iff the given value is a highlet.
isHighlet = { value ::
    <> eq (lowType value) @"highlet";
};

# Converts an arbitrary value into a stringlet representation form
# meant to mimic the Samizdat source syntax.
#
# Note that the output differs from Samizdat Layer 0 syntax in that
# stringlet forms may get represented using hex escapes, which is not
# defined in Layer 0.
sourceStringlet = { value ::
    intletBody = { start value ::
        <> if { <> eq value @0; } {
            <> start;
        } else {
            digit = iadd (imod value @10) @48; # 48 == "0"
            more = idiv value @10;
            <> stringletAdd (intletBody start more) (stringletFromChar digit);
        };
    };

    intletHex = { value ::
        <> if { <> eq value @0; } {
            <> @"";
        } else {
            digit = stringletNth @"0123456789abcdef" (imod value @16);
            more = idiv value @16;
            <> stringletAdd (intletHex more) (stringletFromChar digit);
        };
    };

    stringletChar = { ch ::
        <> if { <> eq ch @0; } {
            <> @"\\0";
        } { <> eq ch @10; } {
            <> @"\\n";
        } { <> or { <> eq ch @34; } { <> eq ch @92; }; } {
            # 34 == "\"" and 92 == "\\"
            <> stringletAdd @"\\" (stringletFromChar ch);
        } { <> or { <> le ch @31; }
                  { <> and { <> ge ch @127; } { <> le ch @159; }; }; } {
            # These are the ranges for nonprinting control characters.
            <> stringletCat @"\\x" (intletHex ch) @";";
        } else {
            <> stringletFromChar ch;
        };
    };

    <> if { <> eq value @[]; } {
        <> @"@[]";
    } { <> eq value @[=]; } {
        <> @"@[=]";
    } { <> isIntlet value; } {
        <> if { <> eq value @0; } {
            <> @"@0";
        } { <> gt value @0; } {
            <> intletBody @"@" value;
        } else {
            <> intletBody @"@-" (ineg value);
        };
    } { <> isStringlet value; } {
        body = listletMap (stringletToChars value) stringletChar;
        result = listletCat @[@"@\""] body @[@"\""];
        <> apply stringletCat result;
    } { <> isListlet value; } {
        body = reduce @"" value
            { reduction elem ::
                <> stringletCat
                    reduction
                    (if { <> eq reduction @""; } { <> @""; } else { <> @" "; })
                    (sourceStringlet elem);
            };
        <> stringletCat @"@[" body @"]";
    } { <> isMaplet value; } {
        body = reduce @"" (getKeys value)
            { reduction key ::
                <> stringletCat
                    reduction
                    (if { <> eq reduction @""; } { <> @""; } else { <> @" "; })
                    (sourceStringlet key)
                    @"="
                    (sourceStringlet (getValue value key));
            };
        <> stringletCat @"@[" body @"]";
    } { <> isHighlet value; } {
        type = highletType value;
        noValue = @@;
        v = ifVoid { <> highletValue value; } { <> noValue; };
        <> stringletCat
            @"[:"
            (sourceStringlet type)
            (ifElse (eq v noValue)
                { <> @""; }
                { <> stringletAdd @" " (sourceStringlet v); })
            @":]";
    } { <> isUniqlet value; } {
        <> @"@@";
    } else {
        <> @"<unknown>";
    };
};


#
# Exports
#

<> @[
    @"eq" = eq
    @"ne" = ne
    @"lt" = lt
    @"gt" = gt
    @"le" = le
    @"ge" = ge
    @"and" = and
    @"else" = else
    @"if" = if
    @"isHighlet" = isHighlet
    @"isIntlet" = isIntlet
    @"isListlet" = isListlet
    @"isMaplet" = isMaplet
    @"isStringlet" = isStringlet
    @"isUniqlet" = isUniqlet
    @"listletCat" = listletCat
    @"listletMap" = listletMap
    @"not" = not
    @"null" = null
    @"or" = or
    @"reduce" = reduce
    @"sourceStringlet" = sourceStringlet
    @"stringletCat" = stringletCat
];
