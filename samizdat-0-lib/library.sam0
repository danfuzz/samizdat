# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. See the associated file "LICENSE.md" for details.

#
# Samizdat Layer 0 Core Library
#
# This is a Samizdat Layer 0 program which defines all the
# core library functions and other bindings that aren't primitive.
#

#
# Helper functions
#

# Generic reduce function, which in addition to the three arguments
# accepted by the exported reduce functions, also takes the size of
# the value to be reduced and the function to get the `nth` element
# from the value.
generalReduce = { base value func size nthFunc ::
    doReduce = { reduction index ::
        <> ifTrue { <> eq index size }
            { <> reduction }
            {
                <> doReduce
                    (func reduction (nthFunc value index) index)
                    (iadd index @1)
            }
    };

    <> doReduce base @0
};


#
# Exported definitions
#

# Documented in Samizdat Layer 0 spec.
null = [:@"null":];

# Documented in Samizdat Layer 0 spec.
eq = { v1 v2 :: <> lowOrderIs v1 v2 @0 };

# Documented in Samizdat Layer 0 spec.
ne = { v1 v2 :: <> lowOrderIs v1 v2 @-1 @1 };

# Documented in Samizdat Layer 0 spec.
lt = { v1 v2 :: <> lowOrderIs v1 v2 @-1 };

# Documented in Samizdat Layer 0 spec.
gt = { v1 v2 :: <> lowOrderIs v1 v2 @1 };

# Documented in Samizdat Layer 0 spec.
le = { v1 v2 :: <> lowOrderIs v1 v2 @-1 @0 };

# Documented in Samizdat Layer 0 spec.
ge = { v1 v2 :: <> lowOrderIs v1 v2 @1 @0 };

# Documented in Samizdat Layer 0 spec.
not = { value ::
    <> ifTrue { <> eq value true }
        { <> false }
        {
            <> ifTrue { <> eq value false }
                { <> true }
                { die @"Non-boolean argument to `not`." }
        }
};

# Documented in Samizdat Layer 0 spec.
if = { predicate consequent rest* ::
    <> ifTrue predicate
        consequent
        # Note: `{}` by definition is a function that returns void.
        { <> ifTrue { <> eq rest @[] } {} { <> apply if rest } }
};

# Documented in Samizdat Layer 0 spec.
else = { <> true };

# Documented in Samizdat Layer 0 spec.
and = { predicate rest* ::
    <> ifTrue predicate
        { <> ifTrue { <> eq rest @[] } { <> true } { <> apply and rest } }
        { <> false }
};

# Documented in Samizdat Layer 0 spec.
or = { predicate rest* ::
    <> ifTrue predicate
        { <> true }
        { <> ifTrue { <> eq rest @[] }
            { <> false }
            { <> apply and rest } }
};

# Documented in Samizdat Layer 0 spec.
listletReduce = { base listlet func ::
    <> generalReduce base listlet func (lowSize listlet) listletNth
};

# Documented in Samizdat Layer 0 spec.
listletMap = { listlet func ::
    <> listletReduce @[] listlet
        { reduction value index ::
            <> listletAppend reduction (func value index)
        }
};

# Documented in Samizdat Layer 0 spec.
listletCat = { listlet rest* ::
    <> listletReduce listlet rest
        { reduction value :: <> listletAdd reduction value }
};

# Documented in Samizdat Layer 0 spec.
stringletReduce = { base stringlet func ::
    <> generalReduce base stringlet func (lowSize stringlet) stringletNth
};

# Documented in Samizdat Layer 0 spec.
stringletMap = { stringlet func ::
    <> stringletReduce @[] stringlet
        { reduction value index ::
            <> listletAppend reduction (func value index)
        }
};

# Documented in Samizdat Layer 0 spec.
stringletCat = { stringlet rest* ::
    <> listletReduce stringlet rest
        { reduction value :: <> stringletAdd reduction value }
};

# Documented in Samizdat Layer 0 spec.
isIntlet = { value ::
    <> eq (lowType value) @"intlet"
};

# Documented in Samizdat Layer 0 spec.
isStringlet = { value ::
    <> eq (lowType value) @"stringlet"
};

# Documented in Samizdat Layer 0 spec.
isListlet = { value ::
    <> eq (lowType value) @"listlet"
};

# Documented in Samizdat Layer 0 spec.
isMaplet = { value ::
    <> eq (lowType value) @"maplet"
};

# Documented in Samizdat Layer 0 spec.
isUniqlet = { value ::
    <> eq (lowType value) @"uniqlet"
};

# Documented in Samizdat Layer 0 spec.
isHighlet = { value ::
    <> eq (lowType value) @"highlet"
};

# Documented in Samizdat Layer 0 spec.
sourceStringlet = { value ::
    intletBody = { start value ::
        <> if { <> eq value @0 } {
            <> start
        } else {
            digit = iadd (imod value @10) @48;   # 48 == "0"
            more = idiv value @10;
            <> stringletAdd (intletBody start more) (stringletFromChar digit)
        }
    };

    intletHex = { value ::
        <> if { <> eq value @0 } {
            <> @""
        } else {
            digit = stringletNth @"0123456789abcdef" (imod value @16);
            more = idiv value @16;
            <> stringletAdd (intletHex more) (stringletFromChar digit)
        }
    };

    stringletChar = { ch ::
        <> if { <> eq ch @0 } {
            <> @"\\0"
        } { <> eq ch @10 } {
            <> @"\\n"
        } { <> or { <> eq ch @34 } { <> eq ch @92 } } {
            # 34 == "\"" and 92 == "\\"
            <> stringletAdd @"\\" (stringletFromChar ch)
        } { <> or { <> le ch @31 }
                  { <> and { <> ge ch @127 } { <> le ch @159 } } } {
            # These are the ranges for nonprinting control characters.
            <> stringletCat @"\\x" (intletHex ch) @";"
        } else {
            <> stringletFromChar ch
        }
    };

    <> if { <> eq value @[] } {
        <> @"@[]"
    } { <> eq value @[=] } {
        <> @"@[=]"
    } { <> isIntlet value } {
        <> if { <> eq value @0 } {
            <> @"@0"
        } { <> gt value @0 } {
            <> intletBody @"@" value
        } else {
            <> intletBody @"@-" (ineg value)
        }
    } { <> isStringlet value } {
        body = stringletReduce @"" value
            { reduction ch :: <> stringletAdd reduction (stringletChar ch) };
        <> stringletCat @"@\"" body @"\""
    } { <> isListlet value } {
        body = listletReduce @"" value
            { reduction elem ::
                <> stringletCat
                    reduction
                    (if { <> eq reduction @"" } { <> @"" } else { <> @" " })
                    (sourceStringlet elem)
            };
        <> stringletCat @"@[" body @"]"
    } { <> isMaplet value } {
        body = listletReduce @"" (mapletKeys value)
            { reduction key ::
                <> stringletCat
                    reduction
                    (if { <> eq reduction @"" } { <> @"" } else { <> @" " })
                    (sourceStringlet key)
                    @"="
                    (sourceStringlet (mapletGet value key))
            };
        <> stringletCat @"@[" body @"]"
    } { <> isHighlet value } {
        type = highletType value;
        <> stringletCat
            @"[:"
            (sourceStringlet type)
            (ifValue { <> highletValue value }
                { v :: <> stringletAdd @" " (sourceStringlet v) }
                { <> @"" })
            @":]"
    } { <> isUniqlet value } {
        <> @"@@"
    } else {
        <> stringletCat
            @"@[(unknown) "
            (sourceStringlet (lowType value))
            @" "
            (sourceStringlet (lowSize value))
            @"]"
    }
};

# Documented in Samizdat Layer 0 spec.
sam0Library = {
    <> CORELIB   # Defined toward the bottom of the file.
};


#
# Export mechanics
#

# Maplet of all of the core library bindings. Note that
# this has to be placed *after* all the core definitions in order
# to execute in a context where they're all in scope.
CORELIB = mapletAdd PRIMLIB @[
    @"eq" = eq
    @"ne" = ne
    @"lt" = lt
    @"gt" = gt
    @"le" = le
    @"ge" = ge
    @"and" = and
    @"else" = else
    @"if" = if
    @"isHighlet" = isHighlet
    @"isIntlet" = isIntlet
    @"isListlet" = isListlet
    @"isMaplet" = isMaplet
    @"isStringlet" = isStringlet
    @"isUniqlet" = isUniqlet
    @"listletCat" = listletCat
    @"listletMap" = listletMap
    @"listletReduce" = listletReduce
    @"not" = not
    @"null" = null
    @"or" = or
    @"sam0Library" = sam0Library
    @"sourceStringlet" = sourceStringlet
    @"stringletCat" = stringletCat
    @"stringletMap" = stringletMap
    @"stringletReduce" = stringletReduce
];

<> CORELIB

