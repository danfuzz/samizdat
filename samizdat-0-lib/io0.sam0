# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Baseline I/O functions
#


#
# Helper functions
#

# Helper for `io0PathFromFlat` which parses absolute path strings
# into components. The grammar is basically
#
# ```
# {/
#    (
#       ("/"+ "." &"/")*
#       "/"+
#       !("." !.)
#       component = [! "/"]*
#    )+
# /}
# ```
#
# with code to convert each `component` into a string (per se). Notably,
# this takes care of ignoring double slashes (or triple, etc.) and `.`
# components, but it leaves the handling of `..` components to a higher
# layer.
def parsePathString = pegMakePlus(
    pegMakeSequence(
        pegMakeStar(
            pegMakeSequence(
                pegMakePlus(pegMakeToken("/")),
                pegMakeToken("."),
                pegMakeLookaheadSuccess(pegMakeToken("/")))),
        pegMakePlus(pegMakeToken("/")),
        pegMakeLookaheadFailure(
            pegMakeSequence(
                pegMakeToken("."),
                pegRuleEof)),
        pegMakeMainSequence(
            pegMakeStar(pegMakeCharSetComplement("/")),
            pegMakeCode { chars :: <> stringFromTokenList(chars) })));

# Checks whether the given alleged prefix is actually a prefix of the
# given path, or equal to it.
def isPrefix = { <out> prefix, path ::
    def prefixSize = lowSize(prefix);

    ifTrue { <> gt(prefixSize, lowSize(path)) }
        {
            # The "prefix" is longer than the path, so it can't actually be
            # a prefix.
            <out> false
        };

    <> eq(prefix, listSlice(path, 0, prefixSize))
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
def io0FlatFromPath = { path ::
    <> listReduce("", path) { result, n, one ::
        ifTrue { <> eq(one, ".") }
            { io0Die(format("Invalid `.` component in path: %q", path)) };
        ifTrue { <> eq(one, "..") }
            { io0Die(format("Invalid `..` component in path: %q", path)) };
        ifTrue
            { <> and { <> eq(one, "") } { <> ne(n, isub(lowSize(path), 1)) } }
            { io0Die(format("Invalid empty component in path: %q", path)) };
        stringForEach(one) { ., ch ::
            ifTrue { <> eq(ch, "/") }
                { io0Die(format("Invalid `/` in path: %q", path)) };
            ifTrue { <> eq(ch, "\0") }
                { io0Die(format("Invalid `\\0` in path: %q", path)) };
        };
        <> stringAdd(result, "/", one)
    }
};

# Documented in Samizdat Layer 0 spec.
def io0PathFromFlat = { string ::
    # Reject the empty string.
    ifTrue { <> eq(string, "") }
        { io0Die("Invalid path (empty).") };

    # Prepend the current directory if the path isn't absolute.
    def absoluteString = ifTrue { <> eq(stringNth(string, 0), "/") }
        { <> string }
        { <> stringAdd(io0FlatCwd(), "/", string) };

    # Do the first layer of parsing.
    def components = pegApply(parsePathString, absoluteString);

    # Handle `..` components, to produce the final result.
    <> listReduce([], components) { result, ., one ::
        <> ifTrue { <> eq(one, "..") }
            {
                ifTrue { <> eq(result, []) }
                    {
                        io0Die(format(
                            "Invalid `..` component in path: %q", string))
                    };
                <> listButLast(result)
            }
            { <> [result*, one] }
    }
};

# Documented in Samizdat Layer 0 spec.
def io0ReadFileUtf8 = { path ::
    <> io0FlatReadFileUtf8(io0FlatFromPath(path))
};

# Documented in Samizdat Layer 0 spec.
def io0ReadLink = { path ::
    <> ifValue { <> io0FlatReadLink(io0FlatFromPath(path)) }
        { newPath :: <> io0PathFromFlat(newPath) }
};

# Helper for `io0SandboxedReader` which does symbolic link resolution,
# respecting the sandbox directory.
#
# This is located in the "exported" section, as it makes use of
# the exported function `io0ReadLink`, defined above.
def resolveLinks = { <out> sandboxDirectory, path ::
    loopReduce([path, 50]) { result ::
        def path = listNth(result, 0);
        def limit = listNth(result, 1);

        ifTrue { <> le(limit, 0) }
            { io0Die("Too many links in symbolic link chain.") };
        ifFalse { <> isPrefix(sandboxDirectory, path) }
            { io0Die("Symbolic link escapes sandbox directory.") };

        <> ifValue { <> io0ReadLink(path) }
            { newPath :: <> [newPath, (isub(limit, 1))] }
            { <out> path }
    }
};

# Documented in Samizdat Layer 0 spec.
def io0SandboxedReader = { directory ::
    <> { path ::
        def fullPath = resolveLinks(directory, [directory*, path*]);
        <> io0ReadFileUtf8(fullPath);
    }
};

# Documented in Samizdat Layer 0 spec.
def io0WriteFileUtf8 = { path ::
    <> io0FlatWriteFileUtf8(io0FlatFromPath(path))
};

<> [
    io0FlatFromPath: io0FlatFromPath,
    io0PathFromFlat: io0PathFromFlat,
    io0ReadFileUtf8: io0ReadFileUtf8,
    io0ReadLink: io0ReadLink,
    io0SandboxedReader: io0SandboxedReader,
    io0WriteFileUtf8: io0WriteFileUtf8
];
