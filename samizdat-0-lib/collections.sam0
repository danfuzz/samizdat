# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Collection library functions: string, list, and map
#
# These are all grouped together because the functionality implemented
# for each is similar to the others.
#


#
# Helper functions
#

# Generic for-each function. Instead of the value-to-iterate argument, this
# takes an `nthFunc` of one argument.
genericForEach = { <out> nthFunc, function ::
    loopReduce(0) { index ::
        <> ifValue { <> nthFunc(index) }
            { item ::
                function(index, item);
                <> iadd(index, 1)
            }
            { <out> }
    }
};

# Generic reduce function. Instead of the value-to-reduce argument, this
# takes an `nthFunc` of one argument.
genericReduce = { <out> base, nthFunc, function ::
    loopReduce([base, 0]) { state ::
        result = listNth(state, 0);
        index = listNth(state, 1);
        <> ifValue { <> nthFunc(index) }
            { item ::
                nextResult = ifValue { <> function(result, index, item) }
                    { value :: <> value }
                    { <> result };
                <> [nextResult, iadd(index, 1)]
            }
            { <out> result }
    }
};

# Generic map function. Instead of the value-to-map argument, this
# takes an `nthFunc` of one argument.
genericMap = { nthFunc, function ::
    <> genericReduce([], nthFunc)
        { result, index, item ::
            <> ifValue { <> function(index, item) }
                { value :: <> listInsNth(result, lowSize(result), value) }
                { <> result }
        }
};


#
# List
#

# Documented in Samizdat Layer 0 spec.
listAppend = { list, value ::
    <> listInsNth(list, lowSize(list), value)
};

# Documented in Samizdat Layer 0 spec.
listButFirst = { <out> list, notFound? ::
    <> ifTrue { <> eq(list, []) }
        { <> apply(out, notFound) }
        { <> listSlice(list, 1) }
};

# Documented in Samizdat Layer 0 spec.
listButLast = { <out> list, notFound? ::
    <> ifTrue { <> eq(list, []) }
        { <> apply(out, notFound) }
        { <> listSlice(list, 0, isub(lowSize(list), 1)) }
};

# Documented in Samizdat Layer 0 spec.
listFirst = { list, notFound? ::
    <> apply(listNth, list, 0, notFound)
};

# Documented in Samizdat Layer 0 spec.
listForEach = { list, function ::
    <> genericForEach({ n :: <> listNth(list, n) }, function)
};

# Documented in Samizdat Layer 0 spec.
listLast = { list, notFound? ::
    <> apply(listNth, list, isub(lowSize(list), 1), notFound)
};

# Documented in Samizdat Layer 0 spec.
listMap = { list, function ::
    <> genericMap({ n :: <> listNth(list, n) }, function)
};

# Documented in Samizdat Layer 0 spec.
listPrepend = { value, list ::
    <> listInsNth(list, 0, value)
};

# Documented in Samizdat Layer 0 spec.
listReduce = { base, list, function ::
    <> genericReduce(base, { n :: <> listNth(list, n) }, function)
};


#
# Map
#

# Documented in Samizdat Layer 0 spec.
#
# **Note:** This one is out-of (alphabetical) order, because it's used
# by other functions in this section, and *Samizdat Layer 0* does not allow
# use-before-def.
mapReduce = { base, map, function ::
    <> genericReduce(base) { n :: <> mapNth(map, n) }
        { reduction, ., mapping ::
            <> function(reduction,
                mapNthKey(mapping, 0), mapNthValue(mapping, 0))
        }
};

# Documented in Samizdat Layer 0 spec.
mapForEach = { map, function ::
    genericForEach { n :: <> mapNth(map, n) }
        { ., mapping ::
            function(mapNthKey(mapping, 0), mapNthValue(mapping, 0))
        }
};

# Documented in Samizdat Layer 0 spec.
mapMap = { map, function ::
    <> mapReduce([=], map)
        { reduction, key, value ::
            <> ifValue { <> function(key, value) }
                { newValue :: <> mapPut(reduction, key, newValue) }
                { <> reduction }
        }
};


#
# String
#

# Documented in Samizdat Layer 0 spec.
stringForEach = { string, function ::
    <> genericForEach({ n :: <> stringNth(string, n) }, function)
};

# Documented in Samizdat Layer 0 spec.
stringFromTokenList = { tokens ::
    <> listReduce("", tokens)
        { result, ., token :: <> stringAdd(result, tokenType(token)) };
};

# Documented in Samizdat Layer 0 spec.
stringMap = { string, function ::
    <> genericMap({ n :: <> stringNth(string, n) }, function)
};

# Documented in Samizdat Layer 0 spec.
stringReduce = { base, string, function ::
    <> genericReduce(base, { n :: <> stringNth(string, n) }, function)
};


#
# Exports
#

<> [
    "listAppend" = listAppend,
    "listButFirst" = listButFirst,
    "listButLast" = listButLast,
    "listFirst" = listFirst,
    "listForEach" = listForEach,
    "listLast" = listLast,
    "listMap" = listMap,
    "listPrepend" = listPrepend,
    "listReduce" = listReduce,
    "mapForEach" = mapForEach,
    "mapMap" = mapMap,
    "mapReduce" = mapReduce,
    "stringForEach" = stringForEach,
    "stringFromTokenList" = stringFromTokenList,
    "stringMap" = stringMap,
    "stringReduce" = stringReduce
]
