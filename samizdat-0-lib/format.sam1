# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Text formatting functions
#

# Gets the current format string position.
fn xFmtAt(state) {
    <> mapGet(state, "fmtAt")
};

# Peeks at the current format string character.
fn xPeek(state) {
    <> stringNth(mapGet(state, "fmt"), xFmtAt(state))
};

# Peeks at the next format string character.
fn xPeek1(state) {
    def at = iadd(1, xFmtAt(state));
    <> stringNth(mapGet(state, "fmt"), at)
};

# Gets the current argument consumption position.
fn xArgsAt(state) {
    <> mapGet(state, "argsAt")
};

# Gets the current argument.
fn xArg(state) {
    <> ifValue { <> listNth(mapGet(state, "args"), xArgsAt(state)) }
        { value :: <> value }
        { <> "(missing argument)" }
};

# Performs the standard update of state after processing a `%`,
# consuming one argument and two format characters.
fn xUsualUpdate(state) {
    def argsAt = iadd(1, xArgsAt(state));
    def fmtAt = iadd(2, xFmtAt(state));

    <> [state*, fmtAt: fmtAt, argsAt: argsAt]
};

# Formats a literal percent.
fn doPercent(yield, state) {
    yield("%");

    def fmtAt = iadd(2, mapGet(state, "fmtAt"));
    <> [state*, fmtAt: fmtAt]
};

# Formats a literal quoted argument.
fn doLiteral(yield, state) {
    yield(sourceString(xArg(state)));
    <> xUsualUpdate(state)
};

# Formats a literal quoted argument, without top-level adornment.
fn doUnadornedLiteral(yield, state) {
    yield(sourceStringUnadorned(xArg(state)));
    <> xUsualUpdate(state)
};

# Formats a string argument.
fn doPlainString(yield, state) {
    yield(xArg(state));
    <> xUsualUpdate(state)
};

# Formats a hex int argument.
fn doHex(yield, state) {
    yield(stringFromInt(xArg(state), 16));
    <> xUsualUpdate(state)
};

# Mapping from format escape characters to their respective handler functions.
def FORMATTERS = [
    "%": doPercent,
    q:   doLiteral,
    Q:   doUnadornedLiteral,
    s:   doPlainString,
    x:   doHex
];

# Formats a plain character (that is, returns it as-is).
fn doPlain(yield, state, ch) {
    yield(ch);

    def fmtAt = iadd(1, mapGet(state, "fmtAt"));
    <> [state*, fmtAt: fmtAt]
};

# Formats an arbitrary escape.
fn doEscape(yield, state) {
    <> ifValue { <> xPeek1(state) }
        { ch ::
            <> ifValue { <> mapGet(FORMATTERS, ch) }
                { formatter :: <> formatter(yield, state) }
                { <> doPercent(yield, state) }
        }
        { <> doPercent(yield, state) }
};

# Formats a single character out of the format string.
fn formatOne(yield, state) {
    <> ifValue { <> xPeek(state) }
        { ch ::
            <> ifIs { <> eq(ch, "%") }
                { <> doEscape(yield, state) }
                { <> doPlain(yield, state, ch) }
        }
        { yield() }
};

# Documented in Samizdat Layer 0 spec.
fn format(formatString, rest*) {
    def formatter = object(formatOne, [
        fmt:    formatString,
        fmtAt:  0,
        args:   rest,
        argsAt: 0
    ]);

    loopReduce("") { result ::
        <> ifValue { <> formatter() }
            { s :: <> stringAdd(result, s) }
            { return result }
    }
};


#
# Export mechanics
#

<> [
    format: format
]
