# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operators
#



#
# Helper definitions
#

# Map from low-layer types to corresponding "get" functions.
def GET_MAP = [
    list:   listNth,
    string: stringNth,
    map:    mapGet
];

# Verifies that it should be possible to compare the two given values,
# terminating the runtime if not.
fn assertComparable(v1, v2) {
    def type1 = lowType(v1);
    def type2 = lowType(v2);

    ifIs { <> ne(type1, type2) }
        { io0Die(format("Incomparable values: %q, %q"), v1, v2) };

    ifIs { <> eq(type1, "token") }
        {
            ifIs { <> ne(tokenType(v1), tokenType(v2)) }
                { io0Die(format("Incomparable values: %q, %q"), v1, v2) }
        }
};


#
# Exported functions
#

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary+"(v1, v2) {
    <> iadd(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary-"(v1, v2) {
    <> isub(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary*"(v1, v2) {
    <> imul(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary/"(v1, v2) {
    <> idiv(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary%"(v1, v2) {
    <> irem(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary=="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> eq(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary!="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ne(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary<"(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> lt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary>"(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> gt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary<="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> le(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary>="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ge(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary+"(value) {
    <> iadd(0, value)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary-"(value) {
    <> ineg(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary&"(value) {
    <> logicFromBoolean(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary[]"(value, indices*) {
    <> listReduce(value, indices)
        { result, ., index ::
            <> ifValue { <> mapGet(GET_MAP, lowType(result)) }
                { getter ::
                    <> ifValue { <> getter(result, index) }
                        { got :: <> got }
                }
                { return }
        }
};

<> [
    "binary+":      \"binary+",
    "binary-":      \"binary-",
    "binary*":      \"binary*",
    "binary/":      \"binary/",
    "binary%":      \"binary%",
    "binary==":     \"binary==",
    "binary!=":     \"binary!=",
    "binary<":      \"binary<",
    "binary>":      \"binary>",
    "binary<=":     \"binary<=",
    "binary>=":     \"binary>=",
    "unary+":       \"unary+",
    "unary-":       \"unary-",
    "unary&":       \"unary&",
    "unary[]":      \"unary[]"
]
