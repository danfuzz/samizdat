# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operators
#


#
# Helper definitions
#

# Message dispatch table, mapping from types to maps from names to functions.
# TODO: This is "scaffolding" meant to be replaced later with a more
# general mechanism.
def MESSAGE_DISPATCH = [
    int: [
        get:  ibit,
        nth:  ibit,
        size: lowSize
    ],

    list: [
        get:  listNth,
        nth:  listNth,
        size: lowSize
    ],

    map: [
        get:  mapGet,
        nth:  mapNth,
        size: lowSize
    ],

    string: [
        get:  stringNth,
        nth:  stringNth,
        size: lowSize
    ]
];

# Verifies that it should be possible to compare the two given values,
# terminating the runtime if not.
fn assertComparable(v1, v2) {
    def type1 = lowType(v1);
    def type2 = lowType(v2);

    ifIs { <> ne(type1, type2) }
        { io0Die("Incomparable values: \%q(v1), \%q(v2)") };

    ifIs { <> eq(type1, "token") }
        {
            ifIs { <> ne(tokenType(v1), tokenType(v2)) }
                { io0Die("Incomparable values: \%q(v1), \%q(v2)") };
        }
};


#
# Exported functions
#

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary+"(v1, v2) {
    <> iadd(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary-"(v1, v2) {
    <> isub(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary*"(v1, v2) {
    <> imul(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary/"(v1, v2) {
    <> idiv(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary%"(v1, v2) {
    <> irem(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary=="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> eq(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary!="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ne(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary<"(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> lt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary>"(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> gt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary<="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> le(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"binary>="(v1, v2) {
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ge(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary."(name) {
    <> { value ::
        def function = mapGet(mapGet(MESSAGE_DISPATCH, lowType(value)), name);
        <> { args* :: <> function(value, args*) }
    }
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary+"(value) {
    <> iadd(0, value)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary-"(value) {
    <> ineg(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary**"(value) {
    <> logicFromBoolean(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
fn \"unary[]"(value, indices*) {
    def getGet = \"unary."("get");
    <> listReduce(value, indices)
        { result, index ::
            <> ifValue { <> getGet(result) }
                { getter :: <> getter(index) }
                { return }
        }
};

<> [
    "binary+":  \"binary+",
    "binary-":  \"binary-",
    "binary*":  \"binary*",
    "binary/":  \"binary/",
    "binary%":  \"binary%",
    "binary==": \"binary==",
    "binary!=": \"binary!=",
    "binary<":  \"binary<",
    "binary>":  \"binary>",
    "binary<=": \"binary<=",
    "binary>=": \"binary>=",
    "unary.":   \"unary.",
    "unary+":   \"unary+",
    "unary-":   \"unary-",
    "unary**":  \"unary**",
    "unary[]":  \"unary[]"
]
