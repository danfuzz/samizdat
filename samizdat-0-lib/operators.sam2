# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operators
#



#
# Helper definitions
#

# Map from low-layer types to corresponding "get" functions.
GET_MAP = [
    "list" = listNth,
    "string" = stringNth,
    "map" = mapGet
];

# Verifies that it should be possible to compare the two given values,
# terminating the runtime if not.
assertComparable = { v1, v2 ::
    type1 = lowType(v1);
    type2 = lowType(v2);

    ifTrue { <> ne(type1, type2)}
        { io0Die(format("Incomparable values: %q, %q"), v1, v2); };

    ifTrue { <> eq(type1, "token") }
        {
            tok1 = tokenType(v1);
            tok2 = tokenType(v2);
            ifTrue { <> ne(tok1, tok2)}
                { io0Die(format("Incomparable values: %q, %q"), v1, v2); };
        };
};


#
# Exported functions
#

# TODO: Documented in Samizdat Layer 2 spec.
\"binary+" = { v1, v2 ::
    <> iadd(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary-" = { v1, v2 ::
    <> isub(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary*" = { v1, v2 ::
    <> imul(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary/" = { v1, v2 ::
    <> idiv(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary%" = { v1, v2 ::
    <> irem(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary&&&" = { v1, v2 ::
    <> iand(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary|||" = { v1, v2 ::
    <> ior(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary^^^" = { v1, v2 ::
    <> ixor(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary<<<" = { v1, v2 ::
    <> ishl(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary>>>" = { v1, v2 ::
    <> ishr(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary==" = { v1, v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> eq(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary!=" = { v1, v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ne(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary<" = { v1, v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> lt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary>" = { v1, v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> gt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary<=" = { v1, v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> le(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary>=" = { v1, v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ge(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary\\==" = { v1, v2 ::
    <> eq(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary\\!=" = { v1, v2 ::
    <> ne(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary\\<" = { v1, v2 ::
    <> lt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary\\>" = { v1, v2 ::
    <> gt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary\\<=" = { v1, v2 ::
    <> le(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary\\>=" = { v1 v2 ::
    <> ge(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"unary+" = { value ::
    <> iadd(0, value)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"unary-" = { value ::
    <> ineg(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"unary!" = { value ::
    <> not(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"unary[]" = { <out> value, indices* ::
    <> listReduce(value, indices)
        { result, ., index ::
            <> ifValue { <> mapGet(GET_MAP, lowType(result)) }
                { getter ::
                    <> ifValue { <> getter(result, index) }
                        { got :: <> got }
                }
                { <out> }
        }
};

# TODO: Documented in Samizdat Layer 2 spec.
\"unary!!!" = { value ::
    <> inot(value)
};

# TODO: Documented in Samizdat Layer 2 spec.
compareChain = { <out> functions, values* ::
    listForEach(functions) { index, function ::
        v1 = listNth(values, index);
        v2 = listNth(values, iadd(index, 1));
        ifFalse { <> function(v1, v2) }
            { <out> false }
    };

    <> true
};

# TODO: Documented in Samizdat Layer 2 spec.
ifChain = { <out> functions, thens* ::
    listForEach(functions) { index, function ::
        ifTrue { <> function() }
            { <out> listNth(thens, index)() }
    };

    # Optional final else clause.
    <> ifTrue { <> gt(lowSize(thens), lowSize(functions)) }
        { <> listLast(thens)() }
};

<> [
    "binary+"      = \"binary+",
    "binary-"      = \"binary-",
    "binary*"      = \"binary*",
    "binary/"      = \"binary/",
    "binary%"      = \"binary%",
    "binary&&&"    = \"binary&&&",
    "binary|||"    = \"binary|||",
    "binary^^^"    = \"binary^^^",
    "binary<<<"    = \"binary<<<",
    "binary>>>"    = \"binary>>>",
    "binary=="     = \"binary==",
    "binary!="     = \"binary!=",
    "binary<"      = \"binary<",
    "binary>"      = \"binary>",
    "binary<="     = \"binary<=",
    "binary>="     = \"binary>=",
    "binary\\=="   = \"binary\\==",
    "binary\\!="   = \"binary\\!=",
    "binary\\<"    = \"binary\\<",
    "binary\\>"    = \"binary\\>",
    "binary\\<="   = \"binary\\<=",
    "binary\\>="   = \"binary\\>=",
    "unary+"       = \"unary+",
    "unary-"       = \"unary-",
    "unary!"       = \"unary!",
    "unary[]"      = \"unary[]",
    "unary!!!"     = \"unary!!!",
    "compareChain" = compareChain,
    "ifChain"      = ifChain
]
