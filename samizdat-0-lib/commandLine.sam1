# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Command line interpreter
#

#
# Helper definitions
#


# def wordBreak = {/ "\0" /}
def parWordBreak = pegMakeToken("\0");

# def word = {/
#     chars=[! "\0"]* wordBreak
#     { <> stringFromTokenList(chars) }
# /}
def parWord = pegMakeMainSequence(
    pegMakeStar(pegMakeCharSetComplement("\0")),
    parWordBreak,
    pegMakeCode { chars, . :: <> stringFromTokenList(chars) });

# def key = {/
#     chars=[! "=\0"]*
#     { <> stringFromTokenList(chars) }
# /}
def parKey = pegMakeMainSequence(
    pegMakeStar(pegMakeCharSetComplement("=\0")),
    pegMakeCode { chars :: <> stringFromTokenList(chars) });

# def keyValue = {/
#     "--" k=key "=" v=word
#     { <> [(k): v] }
# /}
def parKeyValue = pegMakeMainSequence(
    pegMakeString("--"),
    parKey,
    pegMakeToken("="),
    parWord,
    pegMakeCode { ., k, ., v :: <> [(k): v] });

# def flag = {/
#     "--" w=word
#     { <> [(w): true] }
# /}
def parFlag = pegMakeMainSequence(
    pegMakeString("--"),
    parWord,
    pegMakeCode { ., w :: <> [(w): true] });

# def error = {/
#     "-" [! "-\0"] word
#     { ... <> [error: true] }
# /}
def parError = pegMakeMainSequence(
    pegMakeToken("-"),
    pegMakeCharSetComplement("-\0"),
    parWord,
    pegMakeCode { ch1, ch2, word ::
        def value = stringAdd(stringFromTokens(ch1, ch2), word);
        io0Note(format("Unknown option: %Q", value));
        <> [error: true]
    });

# def option = {/
#     keyValue | flag | error
# /}
def parOption = pegMakeChoice(parKeyValue, parFlag, parError);

# def arguments = {/
#     optList=option* ("--" wordBreak)? words=word*
#     { ... <> [options: options, args: args] }
# /}
def parArguments = pegMakeMainSequence(
    pegMakeStar(parOption),
    pegMakeOpt(pegMakeSequence(pegMakeString("--"), parWordBreak)),
    pegMakeStar(parWord),
    pegMakeCode { optList, ., args ::
        def options = mapAdd(optList*);
        ifIs { <> mapGet(options, "error") }
            { io0Die("Trouble with options.") };
        <> [options: options, args: args]
    });

# Simple command-line argument parser.
fn parArgs(args) {
    # Make a unified string with each argument "\0"-terminated.
    def argString = listReduce("", args)
        { result, ., arg ::
            <> stringAdd(result, arg, "\0");
        };

    # Use the peg grammar above to split the arguments back apart.
    <> pegApply(parArguments, argString)
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn samCommandLine(context, rawArgs*) {
    def parsedArgs = parArgs(rawArgs);
    def options = mapGet(parsedArgs, "options");
    def argWords = mapGet(parsedArgs, "args");

    def fileName = listFirst(argWords, "/dev/stdin");
    def filePath = io0PathFromFlat(fileName);
    def args = listButFirst(argWords, []);

    def nameForLookup = ifValue { <> mapGet(options, "file-suffix") }
        { suffix :: <> stringAdd("x.", suffix) }
        { <> listLast(filePath) };

    def metas = metaFunctions(context, nameForLookup);

    def programText = io0ReadFileUtf8(filePath);
    def parsedProgram = mapGet(metas, "tree")(programText);
    def evalledProgram = mapGet(metas, "eval")(context, parsedProgram);

    <> evalledProgram(filePath, args*)
};

<> [
    samCommandLine: samCommandLine
]
