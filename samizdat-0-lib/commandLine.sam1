# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Command line interpreter
#

#
# Private Definitions
#

# Parses a single `\0`-terminated word. Yields a simple string.
def parWord = {/
    chars = [! "\0"]*
    "\0"
    { <> stringFromTokenList(chars) }
/};

# Parses a key prefix of a word, not including the ending `=`.
def parKey = {/
    chars = [! "=\0"]+
    { <> stringFromTokenList(chars) }
/};

# Parses a key-value option word. Yields a single-mapping map of
# `[(key): value]`.
def parKeyValue = {/
    "--"
    key = parKey
    "="
    value = parWord
    { <> [(key): value] }
/};

# Parses a non-value flag option word. Yields a single-mapping map of
# `[(flag): true]`.
def parFlag = {/
    "--"
    flag = parWord
    { <> [(flag): true] }
/};

# Parses a syntactically invalid option. This includes words that start with
# just a single dash and are not *just* `-` (which is a valid non-option
# argument); as well as options with empty keys (`--=...`).
def parError = {/
    ch1 = "-"
    ch2 = [! "-\0"]
    word = parWord
    {
        def value = cat(stringFromTokens(ch1, ch2), word);
        io0Note(cat("Unknown option: ", sourceString(value)));
        <> [error: true]
    }
/};

# Parses and yields an arbitrary option (including errors).
def parOption = {/
    parKeyValue | parFlag | parError
/};

# Parses the entire list of argument words. Yields a map of
# `[options: [k: v, ...], args: [arg, ...]]`.
def parArguments = {/
    optionList = parOption*
    "--\0"?
    args = parWord*
    {
        def options = cat([:], optionList*);
        ifIs { <> get(options, "error") }
            { io0Die("Invalid option(s).") };
        <> [options: options, args: args]
    }
/};

# Simple command-line argument parser.
fn parseArgs(args) {
    # Make a unified string with each argument "\0"-terminated.
    def argFilter = makeFilterGenerator(args) { arg <> cat(arg, "\0") };
    def argString = cat(argFilter*);

    # Use the peg grammar above to split the arguments back apart.
    <> pegApply(parArguments, argString)
};

# Evals a program using layer 0.
fn evalText0(context, programText) {
    def parsedProgram = get(context, "sam0Tree")(programText);
    <> get(context, "sam0Eval")(context, parsedProgram);
};

# Evals a program using the highest-defined layer.
fn evalText(context, programText) {
    def parsedProgram = get(context, "samTree")(programText);
    <> get(context, "samEval")(context, parsedProgram);
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn samCommandLine(context, rawArgs*) {
    def parsedArgs = parseArgs(rawArgs);
    def options = get(parsedArgs, "options");
    def argWords = get(parsedArgs, "args");

    def fileName = ifValueOr { <> first(argWords) } { <> "/dev/stdin" };
    def filePath = io0PathFromFlat(fileName);
    def args = ifValueOr { <> butFirst(argWords) } { <> [] };

    def programText = io0ReadFileUtf8(filePath);

    def evalled = ifIs { <> get(options, "layer-0") }
        { <> evalText0(context, programText) }
        { <> evalText(context, programText) };

    <> evalled(filePath, args*)
};

<> [
    samCommandLine: samCommandLine
]
