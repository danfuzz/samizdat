# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 tree parser
#


#
# Helper functions
#

# Returns a `call` node.
makeCall = { function actuals* ::
    <> @["call" = ["function"=function, "actuals"=actuals]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @["varRef" = name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name actuals* ::
    <> @["call" = ["function"=makeVarRef(name), "actuals"=actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @["literal" = value]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* and *Samizdat Layer 1* specifications.
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations for expression, function, and parser.
parseExpression = forwardFunction();
parseFunction = forwardFunction();
parseParser = forwardFunction();

# Documented in Samizdat Layer 0 spec.
parseInt = pegMakeMainSequence(
    pegMakeToken("int"),
    pegMakeCode { int :: <> makeLiteral(tokenValue(int)) });

# Documented in Samizdat Layer 0 spec.
parseString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { string :: <> makeLiteral(tokenValue(string)) });

# Documented in Samizdat Layer 0 spec.
parseUnadornedList = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            parseExpression,
            pegMakeStar(pegMakeSequence(pegMakeToken(","), parseExpression)),
            pegMakeCode { first rest :: <> listPrepend(first, rest) }),
        pegMakeCode { <> [] }));

# Documented in Samizdat Layer 0 spec.
parseList = pegMakeMainSequence(
    pegMakeToken("["),
    parseUnadornedList,
    pegMakeToken("]"),
    pegMakeCode { . expressions . ::
        <> ifTrue { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> apply(makeCallName, "makeList", expressions) }
    });

# Documented in Samizdat Layer 0 spec.
parseEmptyMap = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeToken("="),
    pegMakeToken("]"),
    pegMakeCode { . . . :: <> makeLiteral([=]) });

# Documented in Samizdat Layer 0 spec.
parseMapping = pegMakeMainSequence(
    parseExpression,
    pegMakeToken("="),
    parseExpression,
    pegMakeCode { key . value :: <> [key, value] });

# Documented in Samizdat Layer 0 spec.
parseMap = pegMakeMainSequence(
    pegMakeToken("["),
    parseMapping,
    pegMakeStar(pegMakeSequence(pegMakeToken(","), parseMapping)),
    pegMakeToken("]"),
    pegMakeCode { . first rest . ::
        mappings = apply(listAdd, first, rest);
        <> apply(makeCallName, "makeMap", mappings)
    });

# Documented in Samizdat Layer 0 spec.
parseToken = pegMakeMainSequence(
    pegMakeToken("@"),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("["),
            parseExpression,
            pegMakeOpt(pegMakeSequence(pegMakeToken("="), parseExpression)),
            pegMakeToken("]"),
            pegMakeCode { . type value . ::
                <> apply(makeCallName, "makeToken", type, value)
            }),
        pegMakeMainSequence(
            pegMakeTokenSet("string", "identifier"),
            pegMakeCode { type ::
                <> makeCallName("makeToken", makeLiteral(tokenValue(type)))
            })));

# Documented in Samizdat Layer 0 spec.
parseUniqlet = pegMakeMainSequence(
    pegMakeToken("@@"),
    pegMakeCode { . :: <> makeCallName("makeUniqlet") });

# Documented in Samizdat Layer 0 spec.
parseVarRef = pegMakeMainSequence(
    pegMakeToken("identifier"),
    pegMakeCode { name :: <> makeVarRef(tokenValue(name)) });

# Documented in Samizdat Layer 0 spec.
parseVarDef = pegMakeMainSequence(
    pegMakeToken("identifier"),
    pegMakeToken("="),
    parseExpression,
    pegMakeCode { name . ex ::
        <> @["varDef" = ["name"=tokenValue(name), "value"=ex]]
    });

# Documented in Samizdat Layer 0 spec.
parseParenExpression = pegMakeMainSequence(
    pegMakeToken("("),
    parseExpression,
    pegMakeToken(")"),
    pegMakeCode { . ex . :: <> ex });

# Documented in Samizdat Layer 0 spec and Samizdat Layer 1 spec.
parseAtom = pegMakeMainSequence(
    pegMakeChoice(
        parseVarRef, parseInt, parseString,
        parseList, parseEmptyMap, parseMap,
        parseUniqlet, parseToken, parseFunction,
        parseParenExpression,
        # Defined by Samizdat Layer 1. The lookahead is just to make
        # it clear what is required to "jump into" Layer 1 parsing.
        pegMakeSequence(
            pegMakeLookaheadSuccess(pegMakeToken("{/")),
            parseParser)));

# Documented in Samizdat Layer 0 spec.
parseActualsList = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("()"),
            pegMakeStar(parseFunction)),
        pegMakeSequence(
            pegMakeToken("("),
            parseUnadornedList,
            pegMakeToken(")"),
            pegMakeStar(parseFunction),
            pegMakeCode { . normalActuals . functionActuals ::
                <> listAdd(normalActuals, functionActuals)
            }),
        pegMakePlus(parseFunction)));

# Documented in Samizdat Layer 0 spec.
parseCallExpression = pegMakeMainSequence(
    parseAtom,
    pegMakeStar(parseActualsList),
    pegMakeCode { base actualsLists ::
        <> listReduce(base, actualsLists) { result . list ::
            <> apply(makeCall, result, list)
        }
    });

# Documented in Samizdat Layer 0 spec.
implExpression = parseCallExpression;
parseExpression(implExpression);

# Documented in Samizdat Layer 0 spec.
parseStatement = pegMakeMainSequence(
    pegMakeChoice(parseVarDef, parseExpression));

# Documented in Samizdat Layer 0 spec.
parseNonlocalExit = pegMakeMainSequence(
    pegMakeToken("<"),
    parseVarRef,
    pegMakeToken(">"),
    pegMakeOpt(parseExpression),
    pegMakeCode { . name . ex :: <> apply(makeCall, name, ex) });

# Documented in Samizdat Layer 0 spec.
parseYield = pegMakeMainSequence(
    pegMakeToken("<>"),
    pegMakeChoice(
        pegMakeMainSequence(
            parseExpression,
            pegMakeCode { ex :: <> ["yield" = ex] }),
        pegMakeMainSequence(
            pegMakeCode { <> [=] })));

# Documented in Samizdat Layer 0 spec.
parseYieldDef = pegMakeMainSequence(
    pegMakeToken("<"),
    pegMakeToken("identifier"),
    pegMakeToken(">"),
    pegMakeCode { . name . :: <> tokenValue(name) });

# Documented in Samizdat Layer 0 spec.
parseFormal = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("identifier"),
            pegMakeCode { n :: <> ["name" = tokenValue(n)] }),
        pegMakeMainSequence(
            pegMakeToken("."),
            pegMakeCode { . :: <> [=] })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeTokenSet("?", "*", "+"),
            pegMakeCode { r :: <> ["repeat" = tokenType(r)] }),
        pegMakeMainSequence(
            pegMakeCode { <> [=] })),
    pegMakeCode { name repeat :: <> mapAdd(name, repeat) });

# Documented in Samizdat Layer 0 spec.
parseProgramBody = pegMakeMainSequence(
    pegMakeStar(pegMakeToken(";")),
    pegMakeStar(
        pegMakeMainSequence(
            parseStatement,
            pegMakePlus(pegMakeToken(";")),
            pegMakeCode { s . :: <> s })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeChoice(parseStatement, parseNonlocalExit),
            pegMakeCode { s :: <> ["statements" = [s]] }),
        pegMakeMainSequence(
            parseYield,
            pegMakeCode { y :: <> mapAdd(["statements" = []], y) }),
        pegMakeMainSequence(
            pegMakeCode { <> ["statements" = []] })),
    pegMakeStar(pegMakeToken(";")),
    pegMakeCode { . most last . ::
        allStatements = listAdd(most, mapGet(last, "statements"));
        <> mapPut(last, "statements", allStatements)
    });

# Documented in Samizdat Layer 0 spec.
parseProgramDeclarations = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakePlus(parseFormal),
            pegMakeCode { fs :: <> ["formals" = fs] }),
        pegMakeMainSequence(
            pegMakeCode { <> [=] })),
    pegMakeChoice(
        pegMakeMainSequence(
            parseYieldDef,
            pegMakeCode { y :: <> ["yieldDef" = y] }),
        pegMakeMainSequence(
            pegMakeCode { <> [=] })),
    pegMakeToken("::"),
    pegMakeCode { formals yieldDef . :: <> mapAdd(formals, yieldDef) });

# Documented in Samizdat Layer 0 spec.
parseProgram = pegMakeMainSequence(
    pegMakeChoice(
        parseProgramDeclarations,
        pegMakeCode { <> [=] }),
    parseProgramBody,
    pegMakeCode { decls body :: <> @["function" = mapAdd(decls, body)] });

# Documented in Samizdat Layer 0 spec.
implFunction = pegMakeMainSequence(
    pegMakeToken("{"),
    parseProgram,
    pegMakeToken("}"),
    pegMakeCode { . prog . :: <> prog });
parseFunction(implFunction);


#
# Samizdat Layer 1 definitions
#

# `choicePex` is the top-level parsing expression node type.
parseChoicePex = forwardFunction();

implParser = pegMakeMainSequence(
    pegMakeToken("{/"),
    parseChoicePex,
    pegMakeToken("/}"),
    pegMakeCode { . pex . :: <> @["parser" = pex] });
parseParser(implParser);

parseParenPex = pegMakeMainSequence(
    pegMakeToken("("),
    parseChoicePex,
    pegMakeToken(")"),
    pegMakeCode { . pex . :: <> pex });

parseParserString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { s ::
        value = tokenValue(s);
        <> ifTrue { <> eq(lowSize(value), 1) }
            { <> @["token" = value] }
            { <> s }
    });

parseParserCharRange = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { start ::
        <> ifTrue { <> eq(lowSize(tokenValue(start)), 1) }
            { <> intFromString(tokenValue(start)) }
    },
    pegMakeToken(".."),
    pegMakeToken("string"),
    pegMakeCode { . . . end ::
        <> ifTrue { <> eq(lowSize(tokenValue(end)), 1) }
            { <> intFromString(tokenValue(end)) }
    },
    pegMakeCode { . startInt . . endInt <out> ::
        loopReduce([startInt, ""]) { result ::
            at = listFirst(result);
            soFar = listLast(result);
            ifTrue { <> gt(at, endInt) } { <out> @["string" = soFar] };
            <> [iadd(at, 1), stringAdd(soFar, stringFromInt(at))]
        }
    });

parseParserToken = pegMakeMainSequence(
    pegMakeToken("@"),
    pegMakeTokenSet("identifier", "string"),
    pegMakeCode { . type :: <> @["token" = tokenValue(type)] });

parseParserSet = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("!"),
            pegMakeCode { . :: <> "[!]" }),
        pegMakeMainSequence(
            pegMakeCode { <> "[]" })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakePlus(
                pegMakeChoice(parseParserCharRange, pegMakeToken("string"))),
            pegMakeCode { strings ::
                oneString = listReduce("", strings)
                    { result . s :: <> stringAdd(result, tokenValue(s)) };
                <> stringReduce([], oneString)
                    { result . ch :: <> listAppend(result, ch) }
            }),
        pegMakeMainSequence(
            pegMakeStar(parseParserToken),
            pegMakeCode { tokens ::
                <> listMap(tokens) { . t :: <> tokenValue(t) }
            })),
    pegMakeToken("]"),
    pegMakeCode { . type terminals . :: <> @[type = terminals] });

parseParserCode = pegMakeMainSequence(
    pegMakeToken("{"),
    pegMakeChoice(
        pegMakeMainSequence(
            parseYieldDef,
            pegMakeToken("::"),
            pegMakeCode { y . :: <> ["yieldDef" = y] }),
        pegMakeMainSequence(
            pegMakeOpt(pegMakeToken("::")),
            pegMakeCode { . :: <> [=] })),
    parseProgramBody,
    pegMakeToken("}"),
    pegMakeCode { . yieldDef body . :: <> @["{}" = mapAdd(yieldDef, body)] });

parseParserAtom = pegMakeMainSequence(
    pegMakeChoice(
        parseVarRef,
        parseParserString,
        parseParserToken,
        parseParserSet,
        parseParserCode,
        pegMakeToken("."),
        pegMakeToken("()"),
        parseParenPex));

parseRepeatPex = pegMakeMainSequence(
    parseParserAtom,
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("?", "*", "+"),
            pegMakeCode { atom repeat :: <> @[tokenType(repeat) = atom] }),
        pegMakeCode { atom :: <> atom }));

parseLookaheadPex = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("&", "!"),
            parseRepeatPex,
            pegMakeCode { lookahead pex :: <> @[tokenType(lookahead) = pex] }),
        parseRepeatPex));

parseNamePex = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("identifier"),
            pegMakeToken("="),
            parseLookaheadPex,
            pegMakeCode { name . pex ::
                <> @["varDef" = ["name"=tokenValue(name), "value"=pex]]
            }),
        parseLookaheadPex));

parseSequencePex = pegMakeMainSequence(
    pegMakePlus(parseNamePex),
    pegMakeCode { items :: <> @["sequence" = items] });

implChoicePex = pegMakeMainSequence(
    parseSequencePex,
    pegMakeStar(
        pegMakeMainSequence(
            pegMakeToken("|"),
            parseSequencePex)),
    pegMakeCode { first rest :: <> @["choice" = listPrepend(first, rest)] });
parseChoicePex(implChoicePex);


#
# Exported function, and support thereof
#

# Reports the given list of pending tokens as part of error processing.
reportError = { pending ::
    io0Note("Pending tokens:");

    listForEach(pending)
        { . token :: io0Note(format("    %q", token)) };

    io0Die("\nExtra tokens at end of program.")
};

# Documented in Samizdat Layer 0 spec.
parseProgramOrError = pegMakeMainSequence(
    parseProgram,
    pegMakeOpt(
        pegMakeMainSequence(
            pegMakePlus(pegRuleAny),
            pegMakeCode { pending :: reportError(pending) })),
    pegMakeCode { prog . :: <> prog });

# Documented in Samizdat Layer 0 spec.
sam1Tree = { program ::
    tokens = ifTrue { <> isString(program) }
        { <> sam1Tokenize(program) }
        { <> program };

    <> pegApply(parseProgramOrError, tokens)
};

<> [
    "sam1Tree" = sam1Tree
]
