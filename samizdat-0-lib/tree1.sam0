# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 tree parser
#


#
# Private Definitions
#

# Reports the given list of pending tokens as part of error processing.
fn reportError(pending) {
    io0Note("Pending tokens:");

    filterPump(pending, makeInclusiveRange(1, 1, 50))
        { token, . :: io0Note(cat("    ", sourceString(token))) };

    io0Die("\nExtra tokens at end of program.")
};

# Set-like map of all lowercase identifier characters. Used to figure
# out if we're looking at a keyword in the `identifierString` rule.
def LOWER_ALPHA = [
    (makeInclusiveRange("a", 1, "z"))*: true
];

# Returns an `interpolate` node.
fn makeInterpolate(expression) {
    <> @[interpolate: expression]
};

# Returns a `literal` node.
fn makeLiteral(value) {
    <> @[literal: value]
};

# Returns a node representing a thunk (no-arg function) that returns the
# expression represented by the given node.
fn makeThunk(expression) {
    <> @[closure: [formals: [], statements: [], yield: expression]]
};

# Returns a `varDef` node.
fn makeVarDef(name, value) {
    <> @[varDef: [name: name, value: value]]
};

# Returns a `varRef` node.
fn makeVarRef(name) {
    <> @[varRef: name]
};

# Returns a `call` node.
fn makeCall(function, actuals*) {
    <> @[call: [function: function, actuals: actuals]]
};

# Returns a `call` node that names a function as a `varRef`.
fn makeCallName(name, actuals*) {
    <> @[call: [function: makeVarRef(name), actuals: actuals]]
};

# Returns an optional-value expression. This wraps `node` as
# `optValue { <> node }`.
fn makeOptValueExpression(node) {
    <> makeCallName("optValue", makeThunk(node))
};

# Returns a `call` node to a nonlocal exit with the given name and
# with optional expression value. If passed, the expression is allowed
# to evaluate to void, in which case the nonlocal exit yields void at
# its exit point.
fn makeCallNonlocalExit(name, optExpression?) {
    <> ifValue { <> optExpression* }
        { ex ::
            <> makeCallName("nonlocalExit",
                name,
                makeInterpolate(makeOptValueExpression(ex)))
        }
        { <> makeCallName("nonlocalExit", name) }
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* and *Samizdat Layer 1* specifications.
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations.
def parProgramBody = makeParseForwarder();
def parAtom = makeParseForwarder();
def parExpression = makeParseForwarder();
def parUnaryExpression = makeParseForwarder();

# Forward declaration required for integrating layer 1 definitions.
def parParser = makeParseForwarder();

# Documented in Samizdat Layer 0 spec.
def parYieldDef = pegMakeMainSequence(
    pegMakeToken("<"),
    pegMakeToken("identifier"),
    pegMakeToken(">"),
    pegMakeCode { ., name, . <> dataOf(name) });

# Documented in Samizdat Layer 0 spec.
def parOptYieldDef = pegMakeMainChoice(
    pegMakeSequence(
        parYieldDef,
        pegMakeCode { y <> [yieldDef: y] }),
    pegMakeResult([:]));

# Documented in Samizdat Layer 0 spec.
def parFormal = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("identifier"),
            pegMakeCode { n <> [name: dataOf(n)] }),
        pegMakeSequence(
            pegMakeToken("."),
            pegMakeResult([:]))),
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("?", "*", "+"),
            pegMakeCode { ., r <> [repeat: typeOf(r)] }),
        pegMakeResult([:])),
    pegMakeCode { name, repeat <> [name*:, repeat*:] });

# Documented in Samizdat Layer 0 spec.
def parFormalsList = pegMakeMainChoice(
    pegMakeSequence(
        parFormal,
        pegMakeStar(pegMakeSequence(pegMakeToken(","), parFormal)),
        pegMakeCode { one, rest <> [one, rest*] }),
    pegMakeResult([]));

# Documented in Samizdat Layer 0 spec.
def parProgramDeclarations = pegMakeMainChoice(
    pegMakeSequence(
        parOptYieldDef,
        parFormalsList,
        pegMakeChoice(
            pegMakeToken("::"),
            pegMakeLookaheadSuccess(pegMakeToken("<>"))),
        pegMakeCode { yieldDef, formals, . <> [formals: formals, yieldDef*:] }),
    pegMakeResult([formals: []]));

# Documented in Samizdat Layer 0 spec.
def parProgram = pegMakeMainSequence(
    parProgramDeclarations,
    parProgramBody,
    pegMakeCode { decls, body <> @[closure: [decls*:, body*:]] });

# Documented in Samizdat Layer 0 spec.
def parClosure = pegMakeMainSequence(
    pegMakeToken("{"),
    parProgram,
    pegMakeToken("}"),
    pegMakeCode { ., prog, . <> prog });

# Documented in Samizdat Layer 0 spec.
def parNullaryClosure = pegMakeMainSequence(
    parClosure,
    pegMakeCode { c ::
        def formals = get(dataOf(c), "formals");
        ifIs { <> ne(formals, []) }
            { io0Die("Invalid formal argument in code block.") };
        <> c
    });

# Documented in Samizdat Layer 0 spec.
def parCodeOnlyClosure = pegMakeMainSequence(
    parNullaryClosure,
    pegMakeCode { c ::
        ifIs { <> get(dataOf(c), "yieldDef") }
            { io0Die("Invalid yield definition in code block.") };
        <> c
    });

# Documented in Samizdat Layer 0 spec.
def parFnCommon = pegMakeMainSequence(
    pegMakeToken("fn"),
    pegMakeOpt(
        pegMakeSequence(
            parYieldDef,
            pegMakeCode { ., y <> makeVarDef(y, makeVarRef("return")) })),
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("identifier"),
            pegMakeCode { ., ., n <> [name: dataOf(n)] }),
        pegMakeResult([:])),
    pegMakeToken("("),
    parFormalsList,
    pegMakeToken(")"),
    parCodeOnlyClosure,
    pegMakeCode { ., returnDef, name, ., formals, ., code ::
        def codeMap = dataOf(code);
        def statements = [returnDef*, get(codeMap, "statements")*];
        <> [
            codeMap*:, name*:,
            formals: formals,
            yieldDef: "return",
            statements: statements
        ]
    });

# Documented in Samizdat Layer 0 spec.
def parFnDef = pegMakeMainSequence(
    parFnCommon,
    pegMakeCode { funcMap ::
        <> ifIs { <> get(funcMap, "name") }
            { <> @[fnDef: funcMap] }
    });

# Documented in Samizdat Layer 0 spec.
def parFnExpression = pegMakeMainSequence(
    parFnCommon,
    pegMakeChoice(
        pegMakeSequence(
            pegMakeCode { funcMap, . <> get(funcMap, "name") },
            pegMakeCode { funcMap, name ::
                def mainClosure = @[closure: [
                    formals: [],
                    statements: [@[fnDef: funcMap]],
                    yield: makeVarRef(name)
                ]];

                <> makeCall(mainClosure)
            }),
        pegMakeCode { funcMap <> @[closure: funcMap] }));

# Documented in Samizdat Layer 0 spec.

def parInt = pegMakeMainChoice(
    pegMakeSequence(
        pegMakeToken("-"),
        pegMakeToken("int"),
        pegMakeCode { ., i <> makeLiteral(neg(dataOf(i))) }),
    pegMakeSequence(
        pegMakeToken("int"),
        pegMakeCode { i <> makeLiteral(dataOf(i)) }));

# Documented in Samizdat Layer 0 spec.
def parString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { s <> makeLiteral(dataOf(s)) });

# Documented in Samizdat Layer 0 spec.
def parIdentifierString = pegMakeMainChoice(
    pegMakeSequence(
        pegMakeTokenSet("identifier", "string"),
        pegMakeCode { s <> makeLiteral(dataOf(s)) }),
    pegMakeSequence(
        pegAny,
        pegMakeCode { token ::
            <> ifNot { <> dataOf(token) }
                {
                    def type = typeOf(token);
                    def firstCh = nth(type, 0);
                    <> ifIs { <> get(LOWER_ALPHA, firstCh) }
                        { <> makeLiteral(type) }
                }
            }));

# Documented in Samizdat Layer 0 spec.
def parEmptyMap = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeToken(":"),
    pegMakeToken("]"),
    pegMakeResult(makeLiteral([:])));

# Documented in Samizdat Layer 0 spec.
def parKeyAtom = pegMakeMainChoice(
    pegMakeSequence(
        parIdentifierString,
        pegMakeLookaheadFailure(pegMakeToken("*")),
        pegMakeCode { key, . <> key }),
    pegMakeSequence(
        parAtom,
        pegMakeChoice(
            pegMakeSequence(
                pegMakeToken("*"),
                pegMakeCode { key, . <> makeInterpolate(key) }),
            pegMakeCode { key <> key })));

# Documented in Samizdat Layer 0 spec.
def parKey = parKeyAtom;

# Documented in Samizdat Layer 0 spec.
def parMapping = pegMakeMainChoice(
    pegMakeSequence(
        parKey,
        pegMakeToken(":"),
        parExpression,
        pegMakeCode { key, ., value ::
            <> makeCallName("makeValueMap", key, @[expression: value])
        }),
    pegMakeSequence(
        parAtom,
        pegMakeToken("*"),
        pegMakeToken(":"),
        pegMakeCode { map, ., . <> map }));

# Documented in Samizdat Layer 0 spec.
def parMap = pegMakeMainSequence(
    pegMakeToken("["),
    parMapping,
    pegMakeStar(pegMakeSequence(pegMakeToken(","), parMapping)),
    pegMakeToken("]"),
    pegMakeCode { ., one, rest, . ::
        <> makeCallName("cat", one, rest*)
    });

# Documented in Samizdat Layer 0 spec.
def parListItem = pegMakeMainChoice(
    pegMakeSequence(
        parIdentifierString,
        pegMakeToken(":"),
        pegMakeCode { ., . ::
            io0Die("Mapping syntax not valid as a list item or call argument.")
        }),
    pegMakeSequence(
        pegMakeToken("&"),
        parUnaryExpression,
        pegMakeCode { ., ex <> @[voidable: ex] }),
    parExpression);

# Documented in Samizdat Layer 0 spec.
def parUnadornedList = pegMakeMainChoice(
    pegMakeSequence(
        parListItem,
        pegMakeStar(
            pegMakeSequence(pegMakeToken(","), parListItem)),
        pegMakeCode { one, rest <> [one, rest*] }),
    pegMakeResult([]));

# Documented in Samizdat Layer 0 spec.
def parList = pegMakeMainSequence(
    pegMakeToken("["),
    parUnadornedList,
    pegMakeToken("]"),
    pegMakeCode { ., expressions, . ::
        <> ifIs { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> makeCallName("makeList", expressions*) }
    });

# Documented in Samizdat Layer 0 spec.
def parDeriv = pegMakeMainSequence(
    pegMakeToken("@"),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("["),
            pegMakeChoice(parIdentifierString, parAtom),
            pegMakeOpt(pegMakeSequence(pegMakeToken(":"), parExpression)),
            pegMakeToken("]"),
            pegMakeCode { ., type, value, . <> [type, value*] }),
        pegMakeMainSequence(
            parIdentifierString,
            pegMakeCode { type <> [type] })),
    pegMakeCode { ., tokenArgs <> makeCallName("makeValue", tokenArgs*) });

# Documented in Samizdat Layer 0 spec.
def parVarRef = pegMakeMainSequence(
    pegMakeToken("identifier"),
    pegMakeCode { name <> makeVarRef(dataOf(name)) });

# Documented in Samizdat Layer 0 spec.
def parVarDef = pegMakeMainSequence(
    pegMakeToken("def"),
    pegMakeToken("identifier"),
    pegMakeToken("="),
    parExpression,
    pegMakeCode { ., name, ., ex <> makeVarDef(dataOf(name), ex) });

# Documented in Samizdat Layer 0 spec.
def parParenExpression = pegMakeMainSequence(
    pegMakeToken("("),
    parExpression,
    pegMakeToken(")"),
    pegMakeCode { ., ex, . <> @[expression: ex] });

# Documented in Samizdat Layer 0 spec and Samizdat Layer 1 spec.
def implAtom = pegMakeMainChoice(
    parVarRef, parInt, parString,
    parMap, parList, parEmptyMap,
    parDeriv, parClosure,
    parParenExpression,
    # Defined by Samizdat Layer 1. The lookahead is just to make
    # it clear what is required to "jump into" Layer 1 parsing.
    pegMakeSequence(
        pegMakeLookaheadSuccess(pegMakeToken("{/")),
        parParser));
store(parAtom, implAtom);

# Documented in Samizdat Layer 0 spec.
def parActualsList = pegMakeMainChoice(
    pegMakeSequence(
        pegMakeToken("("),
        parUnadornedList,
        pegMakeToken(")"),
        pegMakeStar(parClosure),
        pegMakeCode { ., normalActuals, ., closureActuals ::
            <> [closureActuals*, normalActuals*]
        }),
    pegMakePlus(parClosure));

# Documented in Samizdat Layer 0 spec.
def parPostfixOperator = pegMakeMainChoice(
    pegMakeSequence(
        parActualsList,
        pegMakeCode { actuals <> { node <> makeCall(node, actuals*) } }),
    pegMakeSequence(
        pegMakeToken("*"),
        pegMakeCode { . <> { node <> makeInterpolate(node) } }));

# Documented in Samizdat Layer 0 spec.
def implUnaryExpression = pegMakeMainSequence(
    parAtom,
    pegMakeStar(parPostfixOperator),
    pegMakeCode { base, postfixes ::
        <> doReduce1(postfixes, base) { op, result <> op(result) }
    });
store(parUnaryExpression, implUnaryExpression);

# Documented in Samizdat Layer 0 spec.
def implExpression = pegMakeChoice(
    parUnaryExpression,
    parFnExpression);
store(parExpression, implExpression);

# Documented in Samizdat Layer 0 spec.
def parStatement = pegMakeChoice(
    parVarDef,
    parFnDef,
    parExpression);

# Documented in Samizdat Layer 0 spec.
def parNonlocalExit = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("<"),
            parVarRef,
            pegMakeToken(">"),
            pegMakeCode { ., n, . <> n }),
        pegMakeSequence(
            pegMakeToken("return"),
            pegMakeResult(makeVarRef("return")))),
    pegMakeOpt(parExpression),
    pegMakeCode { name, value ::
        <> makeCallNonlocalExit(name, value*)
    });

# Documented in Samizdat Layer 0 spec.
def parYield = pegMakeMainSequence(
    pegMakeToken("<>"),
    pegMakeChoice(
        pegMakeSequence(
            parExpression,
            pegMakeCode { ., ex <> [yield: ex] }),
        pegMakeResult([:])));

# Documented in Samizdat Layer 0 spec.
def implProgramBody = pegMakeMainSequence(
    pegMakeStar(pegMakeToken(";")),
    pegMakeStar(
        pegMakeMainSequence(
            parStatement,
            pegMakePlus(pegMakeToken(";")),
            pegMakeCode { s, . <> s })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeChoice(parStatement, parNonlocalExit),
            pegMakeCode { s <> [statements: [s]] }),
        pegMakeMainSequence(
            parYield,
            pegMakeCode { y <> [statements: [], y*:] }),
        pegMakeResult([statements: []])),
    pegMakeStar(pegMakeToken(";")),
    pegMakeCode { ., most, last, . ::
        def allStatements = [most*, get(last, "statements")*];
        <> [last*:, statements: allStatements]
    });
store(parProgramBody, implProgramBody);

# Documented in Samizdat Layer 0 spec.
def parProgramOrError = pegMakeMainSequence(
    parProgram,
    pegMakeOpt(
        pegMakeMainSequence(
            pegMakePlus(pegAny),
            pegMakeCode { pending :: reportError(pending) })),
    pegMakeCode { prog, . <> prog });


#
# Samizdat Layer 1 definitions
#

# `choicePex` is the top-level parsing expression node type.
def parChoicePex = makeParseForwarder();

# Map from parser tokens to derived value types for pexes.
def PEX_TYPES = [
    "&": "lookaheadSuccess",
    "!": "lookaheadFailure",
    "?": "opt",
    "*": "star",
    "+": "plus"
];

def implParser = pegMakeMainSequence(
    pegMakeToken("{/"),
    parChoicePex,
    pegMakeToken("/}"),
    pegMakeCode { ., pex, . <> @[parser: pex] });
store(parParser, implParser);

def parParenPex = pegMakeMainSequence(
    pegMakeToken("("),
    parChoicePex,
    pegMakeToken(")"),
    pegMakeCode { ., pex, . <> pex });

def parParserString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { s ::
        def value = dataOf(s);
        <> ifIs { <> eq(sizeOf(value), 1) }
            { <> @[token: value] }
            { <> s }
    });

def parParserToken = pegMakeMainSequence(
    pegMakeToken("@"),
    parIdentifierString,
    pegMakeCode { ., type <> @[token: dataOf(type)] });

def parParserSetString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken(".."),
            pegMakeToken("string"),
            pegMakeCode { s, ., end ::
                def startChar = dataOf(s);
                def endChar = dataOf(end);
                <> ifIs { <> eq(1, &eq(sizeOf(startChar), sizeOf(endChar))) }
                    { <> cat(makeInclusiveRange(startChar, 1, endChar)*) }
            }),
        pegMakeCode { s <> dataOf(s) }));

def parParserSet = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("!"),
            pegMakeResult("tokenSetComplement")),
        pegMakeResult("tokenSet")),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakePlus(parParserSetString),
            pegMakeCode { strings <> [cat(strings*)*] }),
        pegMakeMainSequence(
            pegMakePlus(parParserToken),
            pegMakeCode { tokens <> filter(tokens, dataOf) }),
        pegMakeResult([])),
    pegMakeToken("]"),
    pegMakeCode { ., type, terminals, . <> @[(type): terminals] });

def parParserCode = pegMakeMainSequence(
    parNullaryClosure,
    pegMakeCode { closure <> @[code: dataOf(closure)] });

def parParserAtom = pegMakeMainChoice(
    pegMakeSequence(
        pegMakeToken("."),
        pegMakeResult(@any)),
    pegMakeSequence(
        pegMakeToken("("),
        pegMakeToken(")"),
        pegMakeResult(@empty)),
    parVarRef,
    parParserString,
    parParserToken,
    parParserSet,
    parParserCode,
    parParenPex);

def parRepeatPex = pegMakeMainSequence(
    parParserAtom,
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("?", "*", "+"),
            pegMakeCode { atom, repeat <>
                @[(get(PEX_TYPES, typeOf(repeat))): atom]
            }),
        pegMakeCode { atom <> atom }));

def parLookaheadPex = pegMakeMainChoice(
    pegMakeSequence(
        pegMakeTokenSet("&", "!"),
        parRepeatPex,
        pegMakeCode { lookahead, pex <>
            @[(get(PEX_TYPES, typeOf(lookahead))): pex]
        }),
    parRepeatPex);

def parNamePex = pegMakeMainChoice(
    pegMakeSequence(
        pegMakeToken("identifier"),
        pegMakeToken("="),
        parLookaheadPex,
        pegMakeCode { name, ., pex ::
            <> @[varDef: [name: dataOf(name), value: pex]]
        }),
    parLookaheadPex);

def parSequencePex = pegMakeMainSequence(
    pegMakePlus(parNamePex),
    pegMakeCode { items <> @[sequence: items] });

def implChoicePex = pegMakeMainSequence(
    parSequencePex,
    pegMakeStar(
        pegMakeSequence(
            pegMakeToken("|"),
            parSequencePex)),
    pegMakeCode { one, rest <> @[choice: [one, rest*]] });
store(parChoicePex, implChoicePex);


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn sam1Tree(program) {
    def tokens = ifIs { <> isString(program) }
        { <> sam1Tokenize(program) }
        { <> program };

    <> pegApply(parProgramOrError, tokens)
};

<> [
    sam1Tree: sam1Tree
]
