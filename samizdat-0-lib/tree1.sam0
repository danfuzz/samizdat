# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 tree parser
#


#
# Helper functions
#

# Set-like map of all lowercase identifier characters. Used to figure
# out if we're looking at a keyword in the `identifierString` rule.
def LOWER_ALPHA = ["a".."z": true];

# Returns a `call` node.
fn makeCall(function, actuals*) {
    <> @[call: [function: function, actuals: actuals]]
};

# Returns a `varDef` node.
fn makeVarDef(name, value) {
    <> @[varDef: [name: name, value: value]]
};

# Returns a `varRef` node.
fn makeVarRef(name) {
    <> @[varRef: name]
};

# Returns a `call` node that names a function as a `varRef`.
fn makeCallName(name, actuals*) {
    <> @[call: [function: makeVarRef(name), actuals: actuals]]
};

# Returns a `literal` node.
fn makeLiteral(value) {
    <> @[literal: value]
};

# Returns a node representing a thunk (no-arg function) that returns the
# expression represented by the given node.
fn makeThunk(expression) {
    <> @[closure: [statements: [], yield: expression]]
};

# Returns a `call` node to a nonlocal exit with the given name and
# with optional expression value. The expression if supplied is automatically
# "thunked".
fn makeCallNonlocalExit(name, expression?) {
    <> ifValue { <> expression* }
        { ex :: <> makeCall(makeVarRef("nonlocalExit"), name, makeThunk(ex)) }
        { <> makeCall(makeVarRef("nonlocalExit"), name) }
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* and *Samizdat Layer 1* specifications.
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations.
def parseProgramBody = forwardFunction();
def parseExpression = forwardFunction();
def parseParser = forwardFunction();

# Documented in Samizdat Layer 0 spec.
def parseYieldDef = pegMakeMainSequence(
    pegMakeToken("<"),
    pegMakeToken("identifier"),
    pegMakeToken(">"),
    pegMakeCode { ., name, . :: <> tokenValue(name) });

# Documented in Samizdat Layer 0 spec.
def parseOptYieldDef = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            parseYieldDef,
            pegMakeCode { y :: <> [yieldDef: y] }),
        pegMakeCode { <> [:] }));

# Documented in Samizdat Layer 0 spec.
def parseFormal = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("identifier"),
            pegMakeCode { n :: <> [name: tokenValue(n)] }),
        pegMakeMainSequence(
            pegMakeToken("."),
            pegMakeCode { . :: <> [:] })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeTokenSet("?", "*", "+"),
            pegMakeCode { r :: <> [repeat: tokenType(r)] }),
        pegMakeMainSequence(
            pegMakeCode { <> [:] })),
    pegMakeCode { name, repeat :: <> [:, name*, repeat*] });

# Documented in Samizdat Layer 0 spec.
def parseFormalsList = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            parseFormal,
            pegMakeStar(pegMakeSequence(pegMakeToken(","), parseFormal)),
            pegMakeCode { first, rest ::
                <> [formals: [first, rest*]]
            }),
        pegMakeCode { <> [:] }));

# Documented in Samizdat Layer 0 spec.
def parseProgramDeclarations = pegMakeMainSequence(
    parseOptYieldDef,
    parseFormalsList,
    pegMakeToken("::"),
    pegMakeCode { yieldDef, formals, . :: <> [:, formals*, yieldDef*] });

# Documented in Samizdat Layer 0 spec.
def parseProgram = pegMakeMainSequence(
    pegMakeChoice(
        parseProgramDeclarations,
        pegMakeCode { <> [:] }),
    parseProgramBody,
    pegMakeCode { decls, body :: <> @[closure: [:, decls*, body*]] });

# Documented in Samizdat Layer 0 spec.
def parseClosure = pegMakeMainSequence(
    pegMakeToken("{"),
    parseProgram,
    pegMakeToken("}"),
    pegMakeCode { ., prog, . :: <> prog });

# Documented in Samizdat Layer 0 spec.
def parseNullaryClosure = pegMakeMainSequence(
    parseClosure,
    pegMakeCode { c ::
        ifIs { <> mapGet(tokenValue(c), "formals") }
            { io0Die("Invalid formal argument in code block.") };
        <> c
    });

# Documented in Samizdat Layer 0 spec.
def parseCodeOnlyClosure = pegMakeMainSequence(
    parseNullaryClosure,
    pegMakeCode { c ::
        ifIs { <> mapGet(tokenValue(c), "yieldDef") }
            { io0Die("Invalid yield definition in code block.") };
        <> c
    });

# Documented in Samizdat Layer 0 spec.
def parseFnCommon = pegMakeMainSequence(
    pegMakeToken("fn"),
    pegMakeOpt(
        pegMakeMainSequence(
            parseYieldDef,
            pegMakeCode { y :: <> makeVarDef(y, makeVarRef("return")) })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("identifier"),
            pegMakeCode { n :: <> [name: tokenValue(n)] }),
        pegMakeMainSequence(pegMakeCode { <> [:] })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("()"),
            pegMakeCode { . :: <> [:] }),
        pegMakeMainSequence(
            pegMakeToken("("),
            parseFormalsList,
            pegMakeToken(")"),
            pegMakeCode { ., f, . :: <> f })),
    parseCodeOnlyClosure,
    pegMakeCode { ., returnDef, name, formals, code ::
        def codeMap = tokenValue(code);
        def statements = [returnDef*, mapGet(codeMap, "statements")*];
        <> [
            codeMap*, name*, formals*,
            yieldDef: "return",
            statements: statements
        ]
    });

# Documented in Samizdat Layer 0 spec.
def parseFnDef = pegMakeMainSequence(
    parseFnCommon,
    pegMakeCode { funcMap ::
        <> ifIs { <> mapGet(funcMap, "name") }
            { <> @[fnDef: funcMap] }
    });

# Documented in Samizdat Layer 0 spec.
def parseFnExpression = pegMakeMainSequence(
    parseFnCommon,
    pegMakeCode { funcMap :: <> @[closure: funcMap] },
    pegMakeChoice(
        pegMakeSequence(
            pegMakeCode { funcMap, . :: <> mapGet(funcMap, "name") },
            pegMakeCode { funcMap, closure, name ::
                def mainClosure = @[closure: [
                    statements: [@[fnDef: funcMap]],
                    yield: makeVarRef(name)
                ]];

                <> makeCall(mainClosure)
            }),
        pegMakeCode { ., closure :: <> closure }));

# Documented in Samizdat Layer 0 spec.
def parseInt = pegMakeMainSequence(
    pegMakeToken("int"),
    pegMakeCode { int :: <> makeLiteral(tokenValue(int)) });

# Documented in Samizdat Layer 0 spec.
def parseString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { string :: <> makeLiteral(tokenValue(string)) });

# Documented in Samizdat Layer 0 spec.
def parseIdentifierString = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("identifier", "string"),
            pegMakeCode { s :: <> makeLiteral(tokenValue(s)) }),
        pegMakeSequence(
            pegRuleAny,
            pegMakeCode { token ::
                <> ifVoid { <> tokenValue(token) }
                    {
                        def type = tokenType(token);
                        def firstCh = stringNth(type, 0);
                        <> ifIs { <> mapGet(LOWER_ALPHA, firstCh) }
                            { <> makeLiteral(type) }
                    }
                })));

# Documented in Samizdat Layer 0 spec.
def parseUnadornedList = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            parseExpression,
            pegMakeStar(pegMakeSequence(pegMakeToken(","), parseExpression)),
            pegMakeCode { first, rest :: <> [first, rest*] }),
        pegMakeCode { <> [] }));

# Documented in Samizdat Layer 0 spec.
def parseList = pegMakeMainSequence(
    pegMakeToken("["),
    parseUnadornedList,
    pegMakeToken("]"),
    pegMakeCode { ., expressions, . ::
        <> ifIs { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> makeCallName("makeList", expressions*) }
    });

# Documented in Samizdat Layer 0 spec.
def parseEmptyMap = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeToken(":"),
    pegMakeToken("]"),
    pegMakeCode { ., ., . :: <> makeLiteral([:]) });

# Documented in Samizdat Layer 0 spec.
def parseMapping = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeChoice(
                pegMakeSequence(
                    parseIdentifierString,
                    pegMakeToken(":"),
                    pegMakeCode { k, . :: <> k }),
                pegMakeSequence(
                    parseExpression,
                    pegMakeToken(":"),
                    pegMakeCode { k, . :: <> k })),
            parseExpression,
            pegMakeCode { key, value ::
                <> makeCallName("makeList", value, key)
            }),
        pegMakeSequence(
            parseExpression,
            pegMakeCode { map ::
                <> ifIs { <> eq(tokenType(map), "interpolate") }
                    { <> tokenValue(map) }
            })));

# Documented in Samizdat Layer 0 spec.
def parseMap = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeOpt(pegMakeSequence(pegMakeToken(":"), pegMakeToken(","))),
    parseMapping,
    pegMakeStar(pegMakeSequence(pegMakeToken(","), parseMapping)),
    pegMakeToken("]"),
    pegMakeCode { ., ., first, rest, . ::
        <> makeCallName("makeMap", first, rest*)
    });

# Documented in Samizdat Layer 0 spec.
def parseToken = pegMakeMainSequence(
    pegMakeToken("@"),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("["),
            parseIdentifierString,
            pegMakeOpt(pegMakeSequence(pegMakeToken(":"), parseExpression)),
            pegMakeToken("]"),
            pegMakeCode { ., type, value, . :: <> [type, value*] }),
        pegMakeMainSequence(
            pegMakeToken("["),
            parseExpression,
            pegMakeOpt(pegMakeSequence(pegMakeToken(":"), parseExpression)),
            pegMakeToken("]"),
            pegMakeCode { ., type, value, . :: <> [type, value*] }),
        pegMakeMainSequence(
            parseIdentifierString,
            pegMakeCode { type :: <> [type] })),
    pegMakeCode { ., tokenArgs :: <> makeCallName("makeToken", tokenArgs*) });

# Documented in Samizdat Layer 0 spec.
def parseUniqlet = pegMakeMainSequence(
    pegMakeToken("@@"),
    pegMakeCode { . :: <> makeCallName("makeUniqlet") });

# Documented in Samizdat Layer 0 spec.
def parseVarRef = pegMakeMainSequence(
    pegMakeToken("identifier"),
    pegMakeCode { name :: <> makeVarRef(tokenValue(name)) });

# Documented in Samizdat Layer 0 spec.
def parseVarDef = pegMakeMainSequence(
    pegMakeToken("def"),
    pegMakeToken("identifier"),
    pegMakeToken("="),
    parseExpression,
    pegMakeCode { ., name, ., ex ::
        <> makeVarDef(tokenValue(name), ex)
    });

# Documented in Samizdat Layer 0 spec.
def parseParenExpression = pegMakeMainSequence(
    pegMakeToken("("),
    parseExpression,
    pegMakeToken(")"),
    pegMakeCode { ., ex, . :: <> @[expression: ex] });

# Documented in Samizdat Layer 0 spec and Samizdat Layer 1 spec.
def parseAtom = pegMakeMainSequence(
    pegMakeChoice(
        parseVarRef, parseInt, parseString,
        parseList, parseEmptyMap, parseMap,
        parseUniqlet, parseToken, parseClosure,
        parseParenExpression,
        # Defined by Samizdat Layer 1. The lookahead is just to make
        # it clear what is required to "jump into" Layer 1 parsing.
        pegMakeSequence(
            pegMakeLookaheadSuccess(pegMakeToken("{/")),
            parseParser)));

# Documented in Samizdat Layer 0 spec.
def parseActualsList = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("()"),
            pegMakeStar(parseClosure)),
        pegMakeSequence(
            pegMakeToken("("),
            parseUnadornedList,
            pegMakeToken(")"),
            pegMakeStar(parseClosure),
            pegMakeCode { ., normalActuals, ., closureActuals ::
                <> [normalActuals*, closureActuals*]
            }),
        pegMakePlus(parseClosure)));

# Documented in Samizdat Layer 0 spec.
def parsePrefixOperator = pegMakeMainSequence(
    pegMakeToken("-"),
    pegMakeCode { . :: <> { node :: <> makeCallName("ineg", node) } });

# Documented in Samizdat Layer 0 spec.
def parsePostfixOperator = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            parseActualsList,
            pegMakeCode { actuals ::
                <> { node :: <> makeCall(node, actuals*) }
            }),
        pegMakeSequence(
            pegMakeToken("*"),
            pegMakeCode { . ::
                <> { node :: <> @[interpolate: node] }
            })));

# Documented in Samizdat Layer 0 spec.
def parseUnaryExpression = pegMakeMainSequence(
    pegMakeStar(parsePrefixOperator),
    parseAtom,
    pegMakeStar(parsePostfixOperator),
    pegMakeCode { prefixes, base, postfixes ::
        def withPosts = listReduce(base, postfixes)
            { result, ., op :: <> op(result) };
        <> listReduce(withPosts, listReverse(prefixes))
            { result, ., op :: <> op(result) }
    });

# Documented in Samizdat Layer 0 spec.
def parseRangeExpression = pegMakeMainSequence(
    parseUnaryExpression,
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken(".."),
            parseUnaryExpression,
            pegMakeCode { base, ., limit ::
                <> @[
                    interpolate:
                    makeCallName("makeRangeInclusive", base, limit)
                ]
            }),
        pegMakeCode { base :: <> base }));

# Documented in Samizdat Layer 0 spec.
def implExpression = pegMakeChoice(
    parseRangeExpression,
    parseFnExpression);
parseExpression(implExpression);

# Documented in Samizdat Layer 0 spec.
def parseStatement = pegMakeChoice(
    parseVarDef,
    parseFnDef,
    parseExpression);

# Documented in Samizdat Layer 0 spec.
def parseNonlocalExit = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("<"),
            parseVarRef,
            pegMakeToken(">"),
            pegMakeCode { ., n, . :: <> n }),
        pegMakeSequence(
            pegMakeToken("return"),
            pegMakeCode { . :: <> makeVarRef("return") })),
    pegMakeOpt(parseExpression),
    pegMakeCode { name, value ::
        <> makeCallNonlocalExit(name, value*)
    });

# Documented in Samizdat Layer 0 spec.
def parseYield = pegMakeMainSequence(
    pegMakeToken("<>"),
    pegMakeChoice(
        pegMakeMainSequence(
            parseExpression,
            pegMakeCode { ex :: <> [yield: ex] }),
        pegMakeMainSequence(
            pegMakeCode { <> [:] })));

# Documented in Samizdat Layer 0 spec.
def implProgramBody = pegMakeMainSequence(
    pegMakeStar(pegMakeToken(";")),
    pegMakeStar(
        pegMakeMainSequence(
            parseStatement,
            pegMakePlus(pegMakeToken(";")),
            pegMakeCode { s, . :: <> s })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeChoice(parseStatement, parseNonlocalExit),
            pegMakeCode { s :: <> [statements: [s]] }),
        pegMakeMainSequence(
            parseYield,
            pegMakeCode { y :: <> [statements: [], y*] }),
        pegMakeMainSequence(
            pegMakeCode { <> [statements: []] })),
    pegMakeStar(pegMakeToken(";")),
    pegMakeCode { ., most, last, . ::
        def allStatements = [most*, mapGet(last, "statements")*];
        <> [last*, statements: allStatements]
    });
parseProgramBody(implProgramBody);


#
# Samizdat Layer 1 definitions
#

# `choicePex` is the top-level parsing expression node type.
def parseChoicePex = forwardFunction();

def implParser = pegMakeMainSequence(
    pegMakeToken("{/"),
    parseChoicePex,
    pegMakeToken("/}"),
    pegMakeCode { ., pex, . :: <> @[parser: pex] });
parseParser(implParser);

def parseParenPex = pegMakeMainSequence(
    pegMakeToken("("),
    parseChoicePex,
    pegMakeToken(")"),
    pegMakeCode { ., pex, . :: <> pex });

def parseParserString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeCode { s ::
        def value = tokenValue(s);
        <> ifIs { <> eq(lowSize(value), 1) }
            { <> @[token: value] }
            { <> s }
    });

def parseParserToken = pegMakeMainSequence(
    pegMakeToken("@"),
    parseIdentifierString,
    pegMakeCode { ., type :: <> @[token: tokenValue(type)] });

def parseParserSetString = pegMakeMainSequence(
    pegMakeToken("string"),
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken(".."),
            pegMakeToken("string"),
            pegMakeCode { s, ., end ::
                def startChar = tokenValue(s);
                def endChar = tokenValue(end);
                <> ifIs
                    { <> and
                        { <> eq(lowSize(startChar), 1) }
                        { <> eq(lowSize(endChar), 1) } }
                    { <> @[string: stringAdd([startChar..endChar]*)] }
            }),
        pegMakeCode { s :: <> s }));

def parseParserSet = pegMakeMainSequence(
    pegMakeToken("["),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakeToken("!"),
            pegMakeCode { . :: <> "[!]" }),
        pegMakeMainSequence(
            pegMakeCode { <> "[]" })),
    pegMakeChoice(
        pegMakeMainSequence(
            pegMakePlus(parseParserSetString),
            pegMakeCode { strings ::
                def oneString = listReduce("", strings)
                    { result, ., s :: <> stringAdd(result, tokenValue(s)) };
                <> stringReduce([], oneString)
                    { result, ., ch :: <> [result*, ch] }
            }),
        pegMakeMainSequence(
            pegMakePlus(parseParserToken),
            pegMakeCode { tokens ::
                <> listMap(tokens) { ., t :: <> tokenValue(t) }
            }),
        pegMakeMainSequence(
            pegMakeCode { <> [] })),
    pegMakeToken("]"),
    pegMakeCode { ., type, terminals, . :: <> @[(type): terminals] });

def parseParserCode = pegMakeMainSequence(
    parseNullaryClosure,
    pegMakeCode { closure :: <> @["{}": tokenValue(closure)] });

def parseParserPredicate = pegMakeMainSequence(
    pegMakeToken("&&"),
    parseParenExpression,
    pegMakeCode { ., predicate :: <> @["&&": predicate] });

def parseParserAtom = pegMakeMainSequence(
    pegMakeChoice(
        parseVarRef,
        parseParserString,
        parseParserToken,
        parseParserSet,
        parseParserCode,
        parseParserPredicate,
        pegMakeToken("."),
        pegMakeToken("()"),
        parseParenPex));

def parseRepeatPex = pegMakeMainSequence(
    parseParserAtom,
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("?", "*", "+"),
            pegMakeCode { atom, repeat :: <> @[tokenType(repeat): atom] }),
        pegMakeCode { atom :: <> atom }));

def parseLookaheadPex = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeTokenSet("&", "!"),
            parseRepeatPex,
            pegMakeCode { lookahead, pex :: <> @[tokenType(lookahead): pex] }),
        parseRepeatPex));

def parseNamePex = pegMakeMainSequence(
    pegMakeChoice(
        pegMakeSequence(
            pegMakeToken("identifier"),
            pegMakeToken("="),
            parseLookaheadPex,
            pegMakeCode { name, ., pex ::
                <> @[varDef: [name: tokenValue(name), value: pex]]
            }),
        parseLookaheadPex));

def parseSequencePex = pegMakeMainSequence(
    pegMakePlus(parseNamePex),
    pegMakeCode { items :: <> @[sequence: items] });

def implChoicePex = pegMakeMainSequence(
    parseSequencePex,
    pegMakeStar(
        pegMakeMainSequence(
            pegMakeToken("|"),
            parseSequencePex)),
    pegMakeCode { first, rest :: <> @[choice: [first, rest*]] });
parseChoicePex(implChoicePex);


#
# Exported function, and support thereof
#

# Reports the given list of pending tokens as part of error processing.
fn reportError(pending) {
    io0Note("Pending tokens:");

    listForEach(pending)
        { ., token :: io0Note(format("    %q", token)) };

    io0Die("\nExtra tokens at end of program.")
};

# Documented in Samizdat Layer 0 spec.
def parseProgramOrError = pegMakeMainSequence(
    parseProgram,
    pegMakeOpt(
        pegMakeMainSequence(
            pegMakePlus(pegRuleAny),
            pegMakeCode { pending :: reportError(pending) })),
    pegMakeCode { prog, . :: <> prog });

# Documented in Samizdat Layer 0 spec.
fn sam1Tree(program) {
    def tokens = ifIs { <> isString(program) }
        { <> sam1Tokenize(program) }
        { <> program };

    <> pegApply(parseProgramOrError, tokens)
};

<> [
    sam1Tree: sam1Tree
]
