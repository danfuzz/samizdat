# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#

#
# Helper definitions
#

# Variable name prefix for all module definitions.
def MODULE_PREFIX = "module:";

# Size of `MODULE_PREFIX`.
def MODULE_PREFIX_SIZE = coreSizeOf(MODULE_PREFIX);

# Given a name, returns the module name portion of it if it in fact starts
# with `MODULE_PREFIX`. Returns void if not.
fn moduleNameFromString(orig) {
    ifIs { <> le(coreSizeOf(orig), MODULE_PREFIX_SIZE) }
        { return };

    <> ifIs { <> eq(stringSlice(orig, 0, MODULE_PREFIX), MODULE_PREFIX) }
        { <> stringSlice(orig, iadd(MODULE_PREFIX_SIZE, 1)) }
};

# Does a `mapGet` on the payload data of the given value.
fn dataGet(value, key) {
    <> mapGet(dataOf(value), key)
};

# Does a `coreSizeOf` on the payload data of the given value.
fn dataSize(value) {
    <> coreSizeOf(dataOf(value))
};

# Returns `mod` iff it is a module (either uninitialized or initialized).
fn isModule(mod) {
    ifNot { <> eq(typeOf(mod), "Module") }
        { return };

    ifNot { <> isMap(&dataOf(mod)) }
        { return };

    ifNot { <> isString(&dataGet(mod, "version")) }
        { return };

    ifIs { <> isMap(&dataGet(mod, "exports")) }
        {
            ifNot { <> eq(dataSize(mod), 2) }
                { return }
        }
        {
            ifNot { <> isMap(&dataGet(mod, "imports")) }
                { return };
            ifNot { <> isUniqlet(&dataGet(mod, "init")) }
                { return };
            ifNot { <> eq(dataSize(mod), 3) }
                { return }
        };

    return mod
};

# Asserts that the given value is a module.
fn assertModule(mod) {
    <> ifIs { <> isModule(mod) }
        { <> mod }
        { io0Die(stringAdd("Not a module: ", sourceString(mod))) }
};

# Returns `mod` if the given module has any dependencies, or void if not.
fn hasDependencies(mod) {
    <> ifIs { <> ne([], &dataGet(mod, "imports")) }
        { <> mod }
};

# Performs topological sort on a list of modules, returning the names
# of the modules in a valid dependency order (not guaranteed to be unique).
#
# This uses the traditional "edge removal" algorithm. See
# <http://en.wikipedia.org/wiki/Topological_sorting> for details.
fn sortModules(modules) {
    # Easy out if there are no modules.
    ifIs { <> eq(modules, []) }
        { return [] };

    # Split the list of modules into those that do and don't have
    # dependencies. Remove from the dependent modules any dependencies from
    # the independent list.

    def independentNames = collectFilter(modules)
        { mod ::
            <> ifNot { <> hasDependencies(mod) } { <> dataGet(mod, "name") }
        };

    def dependentModules = collectFilter(modules)
        { mod ::
            <> ifIs { <> hasDependencies(mod) }
                {
                    def importMap =
                        mapDel([dataGet(mod, "imports")*: true],
                            independentNames*);
                    <> @[mod: [dataOf(mod)*, imports: mapKeys(importMap)]]
                }
        };

    # If there are no independent modules, there's a cycle.
    ifIs { <> eq(independentModules, []) }
        {
            def allNames = collectFilter(modules)
                { mod <> dataGet(mod, "name") };
            io0Die(stringAdd("Module cycle among: ",
                sourceStringUnadorned(allNames)));
        };

    # Recursively sort the dependent modules.
    def dependentNames = sortModules(dependentModules);

    # Combine for the final result.
    <> [independentNames*, dependentNames*]
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn methodGet(dispatch, value, name) {
    def function = mapGet(mapGet(dispatch, typeOf(value)), name);
    <> { args* <> function(value, args*) }
};

# Documented in Samizdat Layer 0 spec.
fn methodCall(dispatch, value, name, args*) {
    <> mapGet(mapGet(dispatch, typeOf(value)), name)(value, args*)
};

# Documented in Samizdat Layer 0 spec.
fn moduleInit(context) {
    # Get a list of just the uninitialized modules, each with its name added
    # to the payload.
    def unsortedModules = collectFilter(context)
        { mapping ::
            def name = mappingKey(mapping);
            def mod = mappingValue(mapping);
            <> ifValue { <> moduleNameFromString(name) }
                { modName ::
                    assertModule(mod);
                    <> @[module: [dataOf(mod)*, name: modName]]
                }
        };

    # Make a map from names to modules.
    def moduleMap = mapFromGenerator(
        filterGenerator(unsortedModules)
            { mod :: <> [dataGet(mod, "name"): mod] });

    # Do a topological sort of the modules, to get them in dependency
    # order (dependencies before dependents).
    def sortedModuleNames = sortModules(unsortedModules);

    # Iterate over the modules in sorted order, calling the initializer on
    # each (if any), passing it the set of already-initialized modules.
    <> doReduce1(sortedModuleNames, [:])
        { name, initted ::
            def mod = mapGet(moduleMap, name);
            def newMod = ifValue { <> dataGet(mod, "init") }
                { init ::
                    <> @[module: [
                        exports: init(initted),
                        name: dataGet(mod, "name"),
                        version: dataGet(mod, "version")
                    ]]
                }
                {
                    # It's a pre-initialized module.
                    <> mod
                };
            <> [initted*, (name): newMod]
        }
};


<> [
    methodCall: methodCall,
    methodGet:  methodGet,
    moduleInit: moduleInit
]
