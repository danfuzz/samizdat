# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Text formatting functions
#

#
# `sourceStringlet` and `sourceStringletUnadorned` functions
#

# Single-character stringlets `@"\0"` `@"\x7f;"` and `@"\x9f;"`.
CHAR_0 = stringletFromIntlet @0;
CHAR_127 = stringletFromIntlet @127;
CHAR_159 = stringletFromIntlet @159;

# Helper for optionally adorning results.
adornIf = { adorn before value after ::
    <> ifTrue { <> adorn }
        { <> stringletAdd before value after }
        { <> value }
};

# Helper for stringifying intlets, which does most of the conversion,
# as well as prepending the given prefix.
intletBody = { start value <out> ::
    loopReduce @[@"" value] { result ::
        text = listletNth result @0;
        value = listletNth result @1;
        <> ifTrue { <> ne value @0 }
            {
                # Note: 48 == "0"
                digit = stringletFromIntlet (iadd (imod value @10) @48);
                <> @[(stringletAdd digit text) (idiv value @10)];
            }
            { <out> stringletAdd start text }
    }
};

# Maplet from intlet sign values to the appropriate stringifier for each.
INTLET_SIGNS = @[
    @-1 = { intlet :: <> intletBody @"-" (ineg intlet) }
    @0  = { <> @"0" }
    @1  = { intlet :: <> intletBody @"" intlet }
];

# Stringifies an intlet.
doIntlet = { recurse intlet adorn ::
    result = (mapletGet INTLET_SIGNS (intletSign intlet)) intlet;
    <> adornIf adorn @"@" result @""
};

# Helper for stringifying stringlets: Returns the hex form for the given
# character. Assumes it's not passed `@0`.
stringletHexEscape = { ch ::
    intletHex = { value ::
        <> ifTrue { <> eq value @0 }
            { <> @"" }
            {
                digit = stringletNth @"0123456789abcdef" (imod value @16);
                more = idiv value @16;
                <> stringletAdd (intletHex more) digit
            }
    };

    <> stringletAdd @"\\x" (intletHex (intletFromStringlet ch)) @";"
};

# Maplet of special-case characters to their stringified forms.
SPECIAL_CHARS = @[
    CHAR_0 = @"\\0"
    @"\n"  = @"\\n"
    @"\""  = @"\\\""
    @"\\"  = @"\\\\"
];

# Helper for stringifying stringlets: Returns the converted form of the
# given character.
stringletChar = { ch ::
    <> ifValue { <> mapletGet SPECIAL_CHARS ch }
        { special :: <> special }
        {
            # This checks for the ranges of nonprinting control characters.
            <> ifTrue { <> or { <> lt ch @" " }
                              { <> and { <> ge ch CHAR_127 }
                                       { <> le ch CHAR_159 } } }
                { <> stringletHexEscape ch }
                { <> ch }
        }
};

# Stringifies a stringlet.
doStringlet = { recurse stringlet adorn ::
    body = stringletReduce @"" stringlet
        { reduction ch :: <> stringletAdd reduction (stringletChar ch) };
    <> adornIf adorn @"@\"" body @"\""
};

# Stringifies a listlet.
doListlet = { recurse listlet adorn ::
    body = listletReduce @"" listlet
        { reduction elem ::
            <> stringletAdd
                reduction
                (ifTrue { <> eq reduction @"" } { <> @"" } { <> @" " })
                (recurse elem)
        };

    <> adornIf adorn @"@[" body @"]"
};

# Stringifies a maplet.
doMaplet = { recurse maplet adorn ::
    body = mapletReduce @"" maplet
        { reduction value key ::
            <> stringletAdd
                reduction
                (ifTrue { <> eq reduction @"" } { <> @"" } { <> @" " })
                (recurse key)
                @"="
                (recurse value)
        };

    <> adornIf adorn
        @"@["
        (ifTrue { <> eq body @"" } { <> @"=" } { <> body })
        @"]"
};

# Stringifies a highlet.
doHighlet = { recurse highlet adorn ::
    type = highletType highlet;
    result = stringletAdd
        (recurse type)
        (ifValue { <> highletValue highlet }
            { value :: <> stringletAdd @" " (recurse value) }
            { <> @"" });

    <> adornIf adorn @"[:" result @":]"
};

# Stringifies a uniqlet.
doUniqlet = { recurse uniqlet ::
    <> @"@@"
};

# Stringifies an unknown value type.
doUnknown = { recurse unknown ::
    <> stringletAdd
        @"@[(unknown) "
        (recurse (lowType value))
        @" "
        (recurse (lowSize value))
        @"]"
};

# Mapping from low-layer type names to stringifiers.
STRINGIFIERS = @[
    @highlet   = doHighlet
    @intlet    = doIntlet
    @listlet   = doListlet
    @maplet    = doMaplet
    @stringlet = doStringlet
    @uniqlet   = doUniqlet
];

# Common handler for the two exported variants.
sourceStringletGeneral = { selfRef value adorn ::
    # The `selfRef` and `recurse` definitions here are effectively a
    # "manual inlining" of the Y combinator, necessitated by the fact that
    # *Samizdat Layer 0* doesn't allow use-before-def.
    recurse = { value :: <> selfRef selfRef value true };

    stringifier = mapletGet STRINGIFIERS (lowType value) doUnknown;
    <> stringifier recurse value adorn
};

# Documented in Samizdat Layer 0 spec.
sourceStringlet = { value ::
    <> sourceStringletGeneral sourceStringletGeneral value true
};

# Documented in Samizdat Layer 0 spec.
sourceStringletUnadorned = { value ::
    <> sourceStringletGeneral sourceStringletGeneral value false
};


#
# `format` function
#

# Gets the current format string position.
xFmtAt = { state ::
    <> (mapletGet state @fmtAt)
};

# Peeks at the current format string character.
xPeek = { state ::
    <> stringletNth (mapletGet state @fmt) (xFmtAt state)
};

# Peeks at the next format string character.
xPeek1 = { state ::
    at = iadd @1 (xFmtAt state);
    <> stringletNth (mapletGet state @fmt) at;
};

# Gets the current argument consumption position.
xArgsAt = { state ::
    <> (mapletGet state @argsAt)
};

# Gets the current argument.
xArg = { state ::
    <> ifValue { <> listletNth (mapletGet state @args) (xArgsAt state) }
        { value :: <> value }
        { <> @"(missing argument)" }
};

# Formats a literal percent.
doPercent = { yield state ::
    yield @"%";

    fmtAt = iadd @2 (mapletGet state @fmtAt);
    <> mapletPut state @fmtAt fmtAt;
};

# Formats a literal quoted argument.
doLiteral = { yield state ::
    yield (sourceStringlet (xArg state));

    argsAt = iadd @1 (xArgsAt state);
    fmtAt = iadd @2 (xFmtAt state);
    <> mapletAdd state @[@fmtAt=fmtAt @argsAt=argsAt];
};

# Formats a literal quoted argument, without top-level adornment.
doUnadornedLiteral = { yield state ::
    yield (sourceStringletUnadorned (xArg state));

    argsAt = iadd @1 (xArgsAt state);
    fmtAt = iadd @2 (xFmtAt state);
    <> mapletAdd state @[@fmtAt=fmtAt @argsAt=argsAt];
};

# Formats a stringlet argument.
doStringlet = { yield state ::
    yield (xArg state);

    argsAt = iadd @1 (xArgsAt state);
    fmtAt = iadd @2 (xFmtAt state);
    <> mapletAdd state @[@fmtAt=fmtAt @argsAt=argsAt];
};

# Mapping from format escape characters to their respective handler functions.
FORMATTERS = @[
    @"%" = doPercent
    @"q" = doLiteral
    @"Q" = doUnadornedLiteral
    @"s" = doStringlet
];

# Formats a plain character (that is, returns it as-is).
doPlain = { yield state ch ::
    yield ch;

    fmtAt = iadd @1 (mapletGet state @fmtAt);
    <> mapletPut state @fmtAt fmtAt;
};

# Formats an arbitrary escape.
doEscape = { yield state ::
    <> ifValue { <> xPeek1 state }
        { ch ::
            <> ifValue { <> mapletGet FORMATTERS ch }
                { formatter :: <> formatter yield state ch }
                { <> doPercent yield state }
        }
        { <> doPercent yield state }
};

# Formats a single character out of the format string.
formatOne = { yield state ::
    <> ifValue { <> xPeek state }
        { ch ::
            <> ifTrue { <> eq ch @"%" }
                { <> doEscape yield state }
                { <> doPlain yield state ch }
        }
        { yield() }
};

# Documented in Samizdat Layer 0 spec.
format = { formatString rest* <out> ::
    formatter = object formatOne @[
        @fmt    = formatString
        @fmtAt  = @0
        @args   = rest
        @argsAt = @0
    ];

    loopReduce @"" { result ::
        <> ifValue { <> formatter() }
            { s :: <> stringletAdd result s }
            { <out> result }
    }
};


#
# Export mechanics
#

<> @[
    @format = format
    @sourceStringlet = sourceStringlet
    @sourceStringletUnadorned = sourceStringletUnadorned
]
