# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Value stringification
#

#
# Private Definitions
#

#
# Int formatting
#

# This is int digits for bases up to 36, in order.
def DIGIT_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";

# Helper for stringifying ints, which does most of the conversion,
# as well as prepending the given prefix.
fn intBody(start, value, base) {
    loopReduce("", value) { text, value ->
        <> ifIs { <> ne(value, 0) }
            {
                def digit = nth(DIGIT_CHARS, mod(value, base));
                <> [cat(digit, text), div(value, base)];
            }
            { return cat(start, text) }
    }
};

# Map from int sign values to the appropriate stringifier for each.
def INT_SIGNS = {
    -1: { int, base <> intBody("-", neg(int), base) },
    0:  { int, base <> "0" },
    1:  { int, base <> intBody("", int, base) }
};

# Stringifies an int using the given base.
fn formatIntWithBase(int, base) {
    <> get(INT_SIGNS, sign(int))(int, base)
};

# Formats a hex int argument.
fn formatIntHex(arg) {
    <> formatIntWithBase(arg, 16)
};


#
# `sourceStringGeneral` and helpers
#

# Common generic for the two `sourceString*` variants, which takes an
# `adorn` flag.
def sourceStringGeneral = makeRegularGeneric("sourceStringGeneral", 2, 2);

# Helper for optionally adorning results.
fn adornIf(adorn, before, value, after) {
    <> ifIs { <> totEq(adorn, true) }
        { <> cat(before, value, after) }
        { <> value }
};

# Helper which concatenates a list of list or map element stringifications.
# It assumes that every element is a string that starts with `", "`, and it
# removes that prefix from the first element. As a special case, returns
# the given `ifEmpty` if `elems` is empty.
fn collectionBody(elems, ifEmpty) {
    ifIs { <> eq(elems, []) }
        { return ifEmpty };

    def one = slice(first(elems), 2);
    <> cat(one, butFirst(elems)*)
};

# These are all the characters which are allowed to start an identifier.
def IDENTIFIER_STARTS = {
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"*: true
};

# These are all the characters which are allowed to be in an identifier.
def IDENTIFIER_CHARS = {
    IDENTIFIER_STARTS*,
    "0123456789"*: true
};

# Values with special conversions.
def SPECIAL_VALUES = {
    (Int):      "Int",
    (List):     "List",
    (Map):      "Map",
    (String):   "String",
    (Type):     "Type",
    (Uniqlet):  "Uniqlet",
    (false):    "false",
    (null):     "null",
    (nullBox):  "nullBox",
    (true):     "true"
};

# Checks to see if the given value is a string with the form of an
# in-language identifier.
fn isIdentifier(string) {
    ifNot { <> isString(string) }
        { return };

    ifIs { <> eq(string, "") }
        { return };

    ifNot { <> get(IDENTIFIER_STARTS, nth(string, 0)) }
        { return };

    filterPump(string) { ch ->
        ifNot { <> get(IDENTIFIER_CHARS, ch) }
            { return }
    };

    <> true
};

# Stringifies a key (or derived value type).
fn keyString(key) {
    ifIs { <> isIdentifier(key) }
        { return key };

    ifValue { <> get(SPECIAL_VALUES, key) }
        { string -> return cat("(", string, ")") };

    <> sourceStringGeneral(key, true)
};

# The first Unicode surrogate code point.
def CHAR_SURROGATE_START = toString(55296); # U+D800

# The last Unicode surrogate code point.
def CHAR_SURROGATE_END = toString(57343); # U+DFFF

# The last Unicode code point.
def CHAR_UNICODE_END = toString(1114111); # U+10FFFF

# Map of special-case characters to either their stringified forms or
# to `"x"` to indicate a need to convert as hex.
def SPECIAL_CHARS = {
    (makeInclusiveRange(toString(1), 1, toString(31)))*: "x",
    (makeInclusiveRange(toString(127), 1, toString(159)))*: "x",
    (toString(65534)): "x",
    (toString(65535)): "x",
    "\0": "\\0",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t",
    "\"": "\\\"",
    "\\": "\\\\"
};

# Does hex character conversion.
fn hexStringChar(ch) {
    <> cat(
        "\\x",
        formatIntWithBase(toInt(ch), 16),
        ";")
};

# Helper for stringifying strings: Returns the converted form of the
# given character.
fn stringChar(ch) {
    ifValue { <> get(SPECIAL_CHARS, ch) }
        { special ->
            ifIs { <> eq(special, "x") }
                { return hexStringChar(ch) }
                { return special }
        };

    ifIs { <> lt(ch, CHAR_SURROGATE_START) }
        { return ch };

    ifIs { <> le(ch, CHAR_SURROGATE_END) }
        { return hexStringChar(ch) };

    <> ifIs { <> le(ch, CHAR_UNICODE_END) }
        { <> ch }
        { <> hexStringChar(ch) }
};

# Stringifies an int.
fn Int_sourceStringGeneral(int, adorn) {
    <> formatIntWithBase(int, 10)
};
genericBind(sourceStringGeneral, Int, Int_sourceStringGeneral);

# Stringifies a list.
fn List_sourceStringGeneral(list, adorn) {
    def listElems = filterAll(list)
        { elem <> cat(", ", sourceStringGeneral(elem, true)) };

    <> adornIf(adorn, "[", collectionBody(listElems, ""), "]")
};
genericBind(sourceStringGeneral, List, List_sourceStringGeneral);

# Stringifies a map.
fn Map_sourceStringGeneral(map, adorn) {
    def mapElems = filterAll(map)
        { mapping ->
            def key = keyString(keyOf(mapping));
            def value = sourceStringGeneral(valueOf(mapping), true);
            <> cat(", ", key, ": ", value)
        };

    <> adornIf(adorn, "[", collectionBody(mapElems, ":"), "]");
};
genericBind(sourceStringGeneral, Map, Map_sourceStringGeneral);

# Stringifies a string.
fn String_sourceStringGeneral(string, adorn) {
    def bodyChars = makeFilterGenerator(string) { ch <> stringChar(ch) };
    <> adornIf(adorn, "\"", cat("", bodyChars*), "\"")
};
genericBind(sourceStringGeneral, String, String_sourceStringGeneral);

# Stringifies a type.
fn Type_sourceStringGeneral(type, adorn) {
    def name = sourceStringGeneral(nameOf(type), true);

    <> adornIf(adorn, "@(Type ", name, ")");
};
genericBind(sourceStringGeneral, Type, Type_sourceStringGeneral);

# Stringifies a derived value or an opaque core value.
fn Value_sourceStringGeneral(value, adorn) {
    ifValue { <> get(SPECIAL_VALUES, value) }
        { string -> return string };

    def type = typeOf(value);
    def typeString = keyString(type);

    def nameString = ifIs { <> canCall(nameOf, value) }
        {
            # It binds `nameOf` but might not have a name.
            <> ifValue { <> nameOf(value) }
                { name <> cat(" ", sourceStringGeneral(name, true)) }
                { <> "" }
        }
        { <> "" };

    def dataString = ifIs { <> isOpaqueValue(value) }
        { <> " /*opaque*/" }
        {
            <> ifValue { <> dataOf(value) }
                { data ->
                    # Transparent derived value with payload.
                    <> cat(" ", sourceStringGeneral(data, true))
                }
                {
                    # Type-only transparent derived value.
                    ifIs { <> isString(type) }
                        { return adornIf(adorn, "@", typeString, "") };
                    <> ""
                }
        };

    def extraString = ifValue { <> ne("", cat(nameString, dataString))  }
        { s <> cat(":", s) }
        { <> "" };

    def body = cat(typeString, extraString);

    <> adornIf(adorn, "@[", body, "]");
};
genericBind(sourceStringGeneral, Value, Value_sourceStringGeneral);


#
# `humanString`
#

# `humanString(value)`: Produces a human-oriented string of the argument.
def humanString = makeRegularGeneric("humanString", 1, 1);

# Human-stringifies a list, which recursively flattens it using
# `humanString`.
fn List_humanString(list) {
    def elems = makeFilterGenerator(humanString, list);
    <> cat("", elems*)
};
genericBind(humanString, List, List_humanString);

# Human-stringifies a string, which just returns the string as-is.
fn String_humanString(string) {
    <> string
};
genericBind(humanString, String, String_humanString);

# Default human-stringifier, which just calls through to
# `sourceStringGeneral`.
fn Value_humanString(value) {
    <> sourceStringGeneral(value, true)
};
genericBind(humanString, Value, Value_humanString);


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn sourceString(value?) {
    <> ifValue { <> value* }
        { value <> sourceStringGeneral(value, true) }
        { <> "void" }
};

# Documented in Samizdat Layer 0 spec.
fn sourceStringUnadorned(value?) {
    <> ifValue { <> value* }
        { value <> sourceStringGeneral(value, false) }
        { <> "void" }
};

# Documented in Samizdat Layer 0 spec.
fn formatInt(value, optBase?) {
    def base = ifValueOr { <> optBase* } { <> 10 };

    <> ifIs { <> le(&le(2, base), 36) }
        { <> formatIntWithBase(value, base) }
        { io0Die("Invalid base for formatInt.") }
};

# Documented in Samizdat Layer 0 spec.
fn formatValue(value?) {
    <> ifValue { <> value* }
        { value <> humanString(value) }
        { <> "" }
};

# Mapping from format escape characters to their respective handler functions.
def FORMATTERS = {
    q: sourceString,
    Q: sourceStringUnadorned,
    s: formatValue,
    x: formatIntHex
};

# Documented in Samizdat Layer 0 spec.
#
# This is listed out of (alphabetical) order, as it uses `FORMATTERS`, which
# is defined in terms of other exported functions.
fn formatterFromString(formatSpec) {
    <> ifValueOr { <> get(FORMATTERS, formatSpec) }
        { io0Die(cat("Unrecognized format spec: ", sourceString(formatSpec))) }
};


<> {
    formatInt:             formatInt,
    formatValue:           formatValue,
    formatterFromString:   formatterFromString,
    sourceString:          sourceString,
    sourceStringUnadorned: sourceStringUnadorned
}
