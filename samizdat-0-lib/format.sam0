# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Text formatting functions
#

#
# `sourceString` and `sourceStringUnadorned` functions
#

# Single-character strings `@"\0"` `@"\x7f;"` and `@"\x9f;"`.
CHAR_0 = stringFromInteger @0;
CHAR_127 = stringFromInteger @127;
CHAR_159 = stringFromInteger @159;

# Helper for optionally adorning results.
adornIf = { adorn before value after ::
    <> ifTrue { <> adorn }
        { <> stringAdd before value after }
        { <> value }
};

# These are all the integer digits, as a map from digit values to
# strings.
INTEGER_CHARS =
    @[ @0=@"0" @1=@"1" @2=@"2" @3=@"3" @4=@"4"
       @5=@"5" @6=@"6" @7=@"7" @8=@"8" @9=@"9" ];

# Helper for stringifying integers, which does most of the conversion,
# as well as prepending the given prefix.
integerBody = { start value <out> ::
    loopReduce @[@"" value] { result ::
        text = listNth result @0;
        value = listNth result @1;
        <> ifTrue { <> ne value @0 }
            {
                digit = mapGet INTEGER_CHARS (imod value @10);
                <> @[(stringAdd digit text) (idiv value @10)];
            }
            { <out> stringAdd start text }
    }
};

# Map from integer sign values to the appropriate stringifier for each.
INTEGER_SIGNS = @[
    @-1 = { integer :: <> integerBody @"-" (ineg integer) }
    @0  = { <> @"0" }
    @1  = { integer :: <> integerBody @"" integer }
];

# Stringifies an integer.
doInteger = { recurse integer adorn ::
    result = (mapGet INTEGER_SIGNS (integerSign integer)) integer;
    <> adornIf adorn @"@" result @""
};

# Helper for stringifying strings: Returns the hex form for the given
# character. Assumes it's not passed `@0`.
stringHexEscape = { ch ::
    integerHex = { value ::
        <> ifTrue { <> eq value @0 }
            { <> @"" }
            {
                digit = stringNth @"0123456789abcdef" (imod value @16);
                more = idiv value @16;
                <> stringAdd (integerHex more) digit
            }
    };

    <> stringAdd @"\\x" (integerHex (integerFromString ch)) @";"
};

# Map of special-case characters to their stringified forms.
SPECIAL_CHARS = @[
    CHAR_0 = @"\\0"
    @"\n"  = @"\\n"
    @"\""  = @"\\\""
    @"\\"  = @"\\\\"
];

# Helper for stringifying strings: Returns the converted form of the
# given character.
stringChar = { ch ::
    <> ifValue { <> mapGet SPECIAL_CHARS ch }
        { special :: <> special }
        {
            # This checks for the ranges of nonprinting control characters.
            <> ifTrue { <> or { <> lt ch @" " }
                              { <> and { <> ge ch CHAR_127 }
                                       { <> le ch CHAR_159 } } }
                { <> stringHexEscape ch }
                { <> ch }
        }
};

# These are all the characters which are allowed to start an identifier.
IDENTIFIER_STARTS = stringReduce @[=]
    @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    { result ch :: <> mapPut result ch true };

# These are all the characters which are allowed to be in an identifier.
IDENTIFIER_CHARS = mapAdd IDENTIFIER_STARTS
    @[ @"0"=true @"1"=true @"2"=true @"3"=true @"4"=true
       @"5"=true @"6"=true @"7"=true @"8"=true @"9"=true ];

# Checks to see if the given string has the form of an in-language
# identifier.
isIdentifier = { string <out> ::
    <> and
        { <> gt (lowSize string) @0 }
        { <> mapGet IDENTIFIER_STARTS (stringNth string @0) false }
        {
            stringForEach string
                { ch ::
                    ifFalse { <> mapGet IDENTIFIER_CHARS ch false }
                        { <out> false }
                };
            <> true
        }
};

# Stringifies a string.
doString = { recurse string adorn ::
    <> ifTrue { <> isIdentifier string }
        { <> adornIf adorn @"@" string @"" }
        {
            body = stringReduce @"" string
                { result ch :: <> stringAdd result (stringChar ch) };
            <> adornIf adorn @"@\"" body @"\""
        }
};

# Stringifies a list.
doList = { recurse list adorn ::
    body = listReduce @"" list
        { reduction elem ::
            <> stringAdd
                reduction
                (ifTrue { <> eq reduction @"" } { <> @"" } { <> @" " })
                (recurse elem)
        };

    <> adornIf adorn @"@[" body @"]"
};

# Stringifies a map.
doMap = { recurse map adorn ::
    body = mapReduce @"" map
        { reduction value key ::
            <> stringAdd
                reduction
                (ifTrue { <> eq reduction @"" } { <> @"" } { <> @" " })
                (recurse key)
                @"="
                (recurse value)
        };

    <> adornIf adorn
        @"@["
        (ifTrue { <> eq body @"" } { <> @"=" } { <> body })
        @"]"
};

# Stringifies a highlet.
doHighlet = { recurse highlet adorn ::
    type = highletType highlet;
    result = stringAdd
        (recurse type)
        (ifValue { <> highletValue highlet }
            { value :: <> stringAdd @" " (recurse value) }
            { <> @"" });

    <> adornIf adorn @"[:" result @":]"
};

# Stringifies a uniqlet.
doUniqlet = { recurse uniqlet ::
    <> @"@@"
};

# Stringifies an unknown value type.
doUnknown = { recurse unknown ::
    <> stringAdd
        @"@[(unknown) "
        (recurse (lowType value))
        @" "
        (recurse (lowSize value))
        @"]"
};

# Mapping from low-layer type names to stringifiers.
STRINGIFIERS = @[
    @highlet = doHighlet
    @integer = doInteger
    @list    = doList
    @map     = doMap
    @string  = doString
    @uniqlet = doUniqlet
];

# Common handler for the two exported variants.
sourceStringGeneral = { selfRef value adorn ::
    # The `selfRef` and `recurse` definitions here are effectively a
    # "manual inlining" of the Y combinator, necessitated by the fact that
    # *Samizdat Layer 0* doesn't allow use-before-def.
    recurse = { value :: <> selfRef selfRef value true };

    stringifier = mapGet STRINGIFIERS (lowType value) doUnknown;
    <> stringifier recurse value adorn
};

# Documented in Samizdat Layer 0 spec.
sourceString = { value ::
    <> sourceStringGeneral sourceStringGeneral value true
};

# Documented in Samizdat Layer 0 spec.
sourceStringUnadorned = { value ::
    <> sourceStringGeneral sourceStringGeneral value false
};


#
# `format` function
#

# Gets the current format string position.
xFmtAt = { state ::
    <> (mapGet state @fmtAt)
};

# Peeks at the current format string character.
xPeek = { state ::
    <> stringNth (mapGet state @fmt) (xFmtAt state)
};

# Peeks at the next format string character.
xPeek1 = { state ::
    at = iadd @1 (xFmtAt state);
    <> stringNth (mapGet state @fmt) at;
};

# Gets the current argument consumption position.
xArgsAt = { state ::
    <> (mapGet state @argsAt)
};

# Gets the current argument.
xArg = { state ::
    <> ifValue { <> listNth (mapGet state @args) (xArgsAt state) }
        { value :: <> value }
        { <> @"(missing argument)" }
};

# Formats a literal percent.
doPercent = { yield state ::
    yield @"%";

    fmtAt = iadd @2 (mapGet state @fmtAt);
    <> mapPut state @fmtAt fmtAt;
};

# Formats a literal quoted argument.
doLiteral = { yield state ::
    yield (sourceString (xArg state));

    argsAt = iadd @1 (xArgsAt state);
    fmtAt = iadd @2 (xFmtAt state);
    <> mapAdd state @[@fmtAt=fmtAt @argsAt=argsAt];
};

# Formats a literal quoted argument, without top-level adornment.
doUnadornedLiteral = { yield state ::
    yield (sourceStringUnadorned (xArg state));

    argsAt = iadd @1 (xArgsAt state);
    fmtAt = iadd @2 (xFmtAt state);
    <> mapAdd state @[@fmtAt=fmtAt @argsAt=argsAt];
};

# Formats a string argument.
doString = { yield state ::
    yield (xArg state);

    argsAt = iadd @1 (xArgsAt state);
    fmtAt = iadd @2 (xFmtAt state);
    <> mapAdd state @[@fmtAt=fmtAt @argsAt=argsAt];
};

# Mapping from format escape characters to their respective handler functions.
FORMATTERS = @[
    @"%" = doPercent
    @"q" = doLiteral
    @"Q" = doUnadornedLiteral
    @"s" = doString
];

# Formats a plain character (that is, returns it as-is).
doPlain = { yield state ch ::
    yield ch;

    fmtAt = iadd @1 (mapGet state @fmtAt);
    <> mapPut state @fmtAt fmtAt;
};

# Formats an arbitrary escape.
doEscape = { yield state ::
    <> ifValue { <> xPeek1 state }
        { ch ::
            <> ifValue { <> mapGet FORMATTERS ch }
                { formatter :: <> formatter yield state ch }
                { <> doPercent yield state }
        }
        { <> doPercent yield state }
};

# Formats a single character out of the format string.
formatOne = { yield state ::
    <> ifValue { <> xPeek state }
        { ch ::
            <> ifTrue { <> eq ch @"%" }
                { <> doEscape yield state }
                { <> doPlain yield state ch }
        }
        { yield() }
};

# Documented in Samizdat Layer 0 spec.
format = { formatString rest* <out> ::
    formatter = object formatOne @[
        @fmt    = formatString
        @fmtAt  = @0
        @args   = rest
        @argsAt = @0
    ];

    loopReduce @"" { result ::
        <> ifValue { <> formatter() }
            { s :: <> stringAdd result s }
            { <out> result }
    }
};


#
# Export mechanics
#

<> @[
    @format = format
    @sourceString = sourceString
    @sourceStringUnadorned = sourceStringUnadorned
]
