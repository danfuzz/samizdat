# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Text formatting functions
#

#
# Helper definitions
#

# Single-character stringlets `@"\0"` `@"\x7f;"` and `@"\x9f;"`.
CHAR_0 = stringletFromIntlet @0;
CHAR_127 = stringletFromIntlet @127;
CHAR_159 = stringletFromIntlet @159;

# Helper for stringifying intlets, which does most of the conversion,
# as well as prepending the given prefix.
intletBody = { start value ::
    <> ifTrue { <> eq value @0 }
        { <> start }
        {
            digit = iadd (imod value @10) @48;   # 48 == "0"
            <> stringletAdd
                (intletBody start (idiv value @10))
                (stringletFromIntlet digit)
        }
};

# Maplet from intlet sign values to the appropriate stringifier for each.
INTLET_SIGNS = @[
    @-1 = { intlet :: <> intletBody @"@-" (ineg intlet) }
    @0  = { <> @"@0" }
    @1  = { intlet :: <> intletBody @"@" intlet }
];

# Stringifies an intlet.
doIntlet = { intlet ::
    <> (mapletGet INTLET_SIGNS (intletSign intlet)) intlet
};

# Helper for stringifying stringlets: Returns the hex form for the given
# character. Assumes it's not passed `@0`.
stringletHexEscape = { ch ::
    intletHex = { value ::
        <> ifTrue { <> eq value @0 }
            { <> @"" }
            {
                digit = stringletNth @"0123456789abcdef" (imod value @16);
                more = idiv value @16;
                <> stringletAdd (intletHex more) digit
            }
    };

    <> stringletCat @"\\x" (intletHex (intletFromStringlet ch)) @";"
};

# Maplet of special-case characters to their stringified forms.
SPECIAL_CHARS = @[
    CHAR_0 = @"\\0"
    @"\n"  = @"\\n"
    @"\""  = @"\\\""
    @"\\"  = @"\\\\"
];

# Helper for stringifying stringlets: Returns the converted form of the
# given character.
stringletChar = { ch ::
    <> ifValue { <> mapletGet SPECIAL_CHARS ch }
        { special :: <> special }
        {
            # This checks for the ranges of nonprinting control characters.
            <> ifTrue { <> or { <> lt ch @" " }
                              { <> and { <> ge ch CHAR_127 }
                                       { <> le ch CHAR_159 } } }
                { <> stringletHexEscape ch }
                { <> ch }
        }
};

# Stringifies a stringlet.
doStringlet = { stringlet ::
    body = stringletReduce @"" stringlet
        { reduction ch :: <> stringletAdd reduction (stringletChar ch) };
    <> stringletCat @"@\"" body @"\""
};

# Stringifies a listlet.
doListlet = { listlet ::
    body = listletReduce @"" listlet
        { reduction elem ::
            <> stringletCat
                reduction
                (if { <> eq reduction @"" } { <> @"" } else { <> @" " })
                (sourceStringlet elem)
        };

    <> stringletCat @"@[" body @"]"
};

# Stringifies a maplet.
doMaplet = { maplet ::
    body = mapletReduce @"" maplet
        { reduction value key ::
            <> stringletCat
                reduction
                (if { <> eq reduction @"" } { <> @"" } else { <> @" " })
                (sourceStringlet key)
                @"="
                (sourceStringlet value)
        };

    <> ifTrue { <> eq maplet @[=] }
        { <> @"@[=]" }
        { <> stringletCat @"@[" body @"]" }
};

# Stringifies a highlet.
doHighlet = { highlet ::
    type = highletType highlet;
    <> stringletCat
        @"[:"
        (sourceStringlet type)
        (ifValue { <> highletValue highlet }
            { value :: <> stringletAdd @" " (sourceStringlet value) }
            { <> @"" })
        @":]"
};

# Stringifies a uniqlet.
doUniqlet = { uniqlet ::
    <> @"@@"
};

# Stringifies an unknown value type.
doUnknown = { unknown ::
    <> stringletCat
        @"@[(unknown) "
        (sourceStringlet (lowType value))
        @" "
        (sourceStringlet (lowSize value))
        @"]"
};

# Mapping from low-layer type names to stringifiers.
STRINGIFIERS = @[
    @highlet   = doHighlet
    @intlet    = doIntlet
    @listlet   = doListlet
    @maplet    = doMaplet
    @stringlet = doStringlet
    @uniqlet   = doUniqlet
];


#
# Exported definitions
#

# Documented in Samizdat Layer 0 spec.
sourceStringlet = { value ::
    stringifier = mapletGet STRINGIFIERS (lowType value) doUnknown;
    <> stringifier value
};

<> @[
    @sourceStringlet = sourceStringlet
]
