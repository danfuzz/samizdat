# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Value stringification
#

#
# Private Definitions
#

# Forward declarations.
def callSourceString = forwardFunction();
def callStringFromValue = forwardFunction();

# This is int digits for bases up to 36, in order.
def DIGIT_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";

# The first Unicode surrogate code point.
def CHAR_SURROGATE_START = charFromInt(55296); # U+D800

# The last Unicode surrogate code point.
def CHAR_SURROGATE_END = charFromInt(57343); # U+DFFF

# The last Unicode code point.
def CHAR_UNICODE_END = charFromInt(1114111); # U+10FFFF

# Helper for stringifying ints, which does most of the conversion,
# as well as prepending the given prefix.
fn intBody(start, value, base) {
    loopReduce("", value) { text, value ::
        <> ifIs { <> ne(value, 0) }
            {
                def digit = stringNth(DIGIT_CHARS, mod(value, base));
                <> [stringCat(digit, text), div(value, base)];
            }
            { return stringCat(start, text) }
    }
};

# Map from int sign values to the appropriate stringifier for each.
def INT_SIGNS = [
    -1: { int, base <> intBody("-", neg(int), base) },
    0:  { int, base <> "0" },
    1:  { int, base <> intBody("", int, base) }
];

# Stringifies an int using the given base.
fn stringFromIntBase(int, base) {
    <> mapGet(INT_SIGNS, sign(int))(int, base)
};

# Helper for optionally adorning results.
fn adornIf(adorn, before, value, after) {
    <> ifIs { <> logicFromBoolean(adorn) }
        { <> stringCat(before, value, after) }
        { <> value }
};

# Helper which concatenates a list of list or map element stringifications.
# It assumes that every element is a string that starts with `", "`, and it
# removes that prefix from the first element. As a special case, returns
# the given `ifEmpty` if `elems` is empty.
fn collectionBody(elems, ifEmpty) {
    ifIs { <> eq(elems, []) }
        { return ifEmpty };

    def first = stringSlice(listFirst(elems), 2);
    <> stringCat(first, listButFirst(elems)*)
};

# Stringifies an int.
fn doInt(int, adorn) {
    <> stringFromIntBase(int, 10)
};

# Map of special-case characters to either their stringified forms or
# to `"x"` to indicate a need to convert as hex.
def SPECIAL_CHARS = [
    inclusiveRange(charFromInt(1), 1, charFromInt(31))*: "x",
    inclusiveRange(charFromInt(127), 1, charFromInt(159))*: "x",
    charFromInt(65534): "x",
    charFromInt(65535): "x",
    "\0": "\\0",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t",
    "\"": "\\\"",
    "\\": "\\\\"
];

# Does hex character conversion.
fn hexStringChar(ch) {
    <> stringCat(
        "\\x",
        stringFromIntBase(intFromChar(ch), 16),
        ";")
};

# Helper for stringifying strings: Returns the converted form of the
# given character.
fn stringChar(ch) {
    ifValue { <> mapGet(SPECIAL_CHARS, ch) }
        { special ::
            ifIs { <> eq(special, "x") }
                { return hexStringChar(ch) }
                { return special }
        };

    ifIs { <> lt(ch, CHAR_SURROGATE_START) }
        { return ch };

    ifIs { <> le(ch, CHAR_SURROGATE_END) }
        { return hexStringChar(ch) };

    <> ifIs { <> le(ch, CHAR_UNICODE_END) }
        { <> ch }
        { <> hexStringChar(ch) }
};

# These are all the characters which are allowed to start an identifier.
def IDENTIFIER_STARTS = [
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"*: true
];

# These are all the characters which are allowed to be in an identifier.
def IDENTIFIER_CHARS = [
    IDENTIFIER_STARTS*,
    "0123456789"*: true
];

# Values with special conversions.
def SPECIAL_VALUES = [
    (Box):      "Box",
    (Function): "Function",
    (Generic):  "Generic",
    (Int):      "Int",
    (List):     "List",
    (Map):      "Map",
    (String):   "String",
    (Type):     "Type",
    (Uniqlet):  "Uniqlet",
    (false):    "false",
    (null):     "null",
    (nullBox):  "nullBox",
    (true):     "true"
];

# Checks to see if the given value is a string with the form of an
# in-language identifier.
fn isIdentifier(string) {
    ifNot { <> isString(string) }
        { return };

    ifIs { <> eq(string, "") }
        { return };

    ifNot { <> mapGet(IDENTIFIER_STARTS, stringNth(string, 0)) }
        { return };

    doFilter(string) { ch ::
        ifNot { <> mapGet(IDENTIFIER_CHARS, ch) }
            { return }
    };

    <> true
};

# Stringifies a key (or derived value type).
fn keyString(key) {
    ifIs { <> isIdentifier(key) }
        { return key };

    ifValue { <> mapGet(SPECIAL_VALUES, key) }
        { string :: return stringCat("(", string, ")") };

    <> callSourceString(key)
};

# Stringifies a string.
fn doString(string, adorn) {
    def bodyChars = filterGenerator(string) { ch <> stringChar(ch) };
    <> adornIf(adorn, "\"", stringCat(bodyChars*), "\"")
};

# Stringifies a list.
fn doList(list, adorn) {
    def listElems = collectFilter(list)
        { elem <> stringCat(", ", callSourceString(elem)) };

    <> adornIf(adorn, "[", collectionBody(listElems, ""), "]")
};

# Stringifies a map.
fn doMap(map, adorn) {
    def mapElems = collectFilter(map)
        { mapping ::
            def key = keyString(mappingKey(mapping));
            def value = callSourceString(mappingValue(mapping));
            <> stringCat(", ", key, ": ", value)
        };

    <> adornIf(adorn, "[", collectionBody(mapElems, ":"), "]");
};

# Stringifies a type.
fn doType(type, adorn) {
    def name = callSourceString(typeName(type));

    <> adornIf(adorn, "@[(Type): ", name, "]");
};

# Stringifies a derived value or an opaque core value.
fn doDerivOrOpaque(value, adorn) {
    ifValue { <> mapGet(SPECIAL_VALUES, value) }
        { string :: return string };

    def type = typeOf(value);
    def typeString = keyString(type);

    def dataString = ifIs { <> isOpaqueValue(value) }
        { <> ": /*opaque*/" }
        {
            <> ifValue { <> dataOf(value) }
                { data ::
                    # Transparent derived value with payload.
                    <> stringCat(": ", callSourceString(data))
                }
                {
                    # Type-only transparent derived value.
                    ifIs { <> isString(type) }
                        { return adornIf(adorn, "@", typeString, "") };
                    <> ""
                }
        };

    def body = stringCat(typeString, dataString);

    <> adornIf(adorn, "@[", body, "]");
};

# Stringifies a string as-is. That is, it just returns the argument. The
# extra argument is the general `adorn` argument, which is degenerate and
# ignored in this case.
fn doStringAsIs(string, .) {
    <> string
};

# Stringifies a list by recursive flattening. The extra argument is the
# general `adorn` argument, which is degenerate and ignored in this case.
fn doListFlatten(list, .) {
    def elems = filterGenerator(list) { e <> callStringFromValue(e) };
    <> stringCat(elems*)
};

# Mapping from low-layer type names to stringifiers to use for `%q`-style
# source-stringification.
def SOURCE_STRINGIFIERS = [
    (Int):    doInt,
    (List):   doList,
    (Map):    doMap,
    (String): doString,
    (Type):   doType
];

# Mapping from low-layer type names to stringifiers to use for `%s`-style
# human-stringification.
def HUMAN_STRINGIFIERS = [
    (Int):    doInt,
    (List):   doListFlatten,
    (Map):    doMap,
    (String): doStringAsIs,
    (Type):   doType
];

# Common handler for the two exported functions.
fn sourceStringGeneral(value, adorn) {
    def stringifier = ifValueOr
        { <> mapGet(SOURCE_STRINGIFIERS, typeOf(value)) }
        { <> doDerivOrOpaque };

    <> stringifier(value, adorn)
};

# Formats a hex int argument.
fn convertHex(arg) {
    <> stringFromIntBase(arg, 16)
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn sourceString(value?) {
    <> ifValue { <> value* }
        { value <> sourceStringGeneral(value, true) }
        { <> "void" }
};
callSourceString(sourceString);

# Documented in Samizdat Layer 0 spec.
fn sourceStringUnadorned(value?) {
    <> ifValue { <> value* }
        { value <> sourceStringGeneral(value, false) }
        { <> "void" }
};

# Documented in Samizdat Layer 0 spec.
fn stringFromInt(value, optBase?) {
    def base = ifValueOr { <> optBase* } { <> 10 };

    <> ifIs { <> le(&le(2, base), 36) }
        { <> stringFromIntBase(value, base) }
        { io0Die("Invalid base for stringFromInt.") }
};

# Documented in Samizdat Layer 0 spec.
fn stringFromValue(value?) {
    <> ifValue { <> value* }
        { value ::
            def stringifier = ifValueOr
                { <> mapGet(HUMAN_STRINGIFIERS, typeOf(value)) }
                { <> doDerivOrOpaque };
            <> stringifier(value, true)
        }
        { <> "" }
};
callStringFromValue(stringFromValue);

# Mapping from format escape characters to their respective handler functions.
def FORMATTERS = [
    q: sourceString,
    Q: sourceStringUnadorned,
    s: stringFromValue,
    x: convertHex
];

# Documented in Samizdat Layer 0 spec.
#
# This is listed out of (alphabetical) order, as it uses `FORMATTERS`, which
# is defined in terms of other exported functions.
fn formatterFromString(formatSpec) {
    <> ifValueOr { <> mapGet(FORMATTERS, formatSpec) }
        {
            io0Die(stringCat(
                "Unrecognized format spec: ",
                sourceString(formatSpec)))
        }
};


<> [
    formatterFromString:   formatterFromString,
    sourceString:          sourceString,
    sourceStringUnadorned: sourceStringUnadorned,
    stringFromInt:         stringFromInt,
    stringFromValue:       stringFromValue
]
