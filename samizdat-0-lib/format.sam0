# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Text formatting functions
#

#
# Helper definitions
#

# These are all the hexadecimal int digits, as a map from digit values to
# single-character strings.
INT_CHARS = [
    0: "0", 1: "1", 2: "2", 3: "3", 4: "4",
    5: "5", 6: "6", 7: "7", 8: "8", 9: "9",
    10: "a", 11: "b", 12: "c", 13: "d", 14: "e", 15: "f"
];

# Helper for stringifying ints, which does most of the conversion,
# as well as prepending the given prefix.
intBody = { <out> start, value, base ::
    loopReduce(["", value]) { result ::
        text = listNth(result, 0);
        value = listNth(result, 1);
        <> ifTrue { <> ne(value, 0) }
            {
                digit = mapGet(INT_CHARS, imod(value, base));
                <> [stringAdd(digit, text), idiv(value, base)];
            }
            { <out> stringAdd(start, text) }
    }
};

# Map from int sign values to the appropriate stringifier for each.
INT_SIGNS = [
    -1: { int, base :: <> intBody("-", ineg(int), base) },
    0:  { int, base :: <> "0" },
    1:  { int, base :: <> intBody("", int, base) }
];

# Stringifies an int using the given base.
stringFromIntBase = { int, base ::
    <> mapGet(INT_SIGNS, intSign(int))(int, base)
};


#
# `sourceString` and `sourceStringUnadorned` functions
#

# Forward declaration of `sourceString`
callSourceString = forwardFunction();

# Single-character strings `"\x7f;"` and `"\x9f;"`.
CHAR_127 = stringFromInt(127);
CHAR_159 = stringFromInt(159);

# Helper for optionally adorning results.
adornIf = { adorn, before, value, after ::
    <> ifTrue { <> adorn }
        { <> stringAdd(before, value, after) }
        { <> value }
};

# Stringifies an int.
doInt = { int, adorn ::
    <> stringFromIntBase(int, 10)
};

# Helper for stringifying strings: Returns the hex form for the given
# character. Assumes it's not passed `0`.
stringHexEscape = { ch ::
    intHex = { value ::
        <> ifTrue { <> eq(value, 0) }
            { <> "" }
            {
                digit = stringNth("0123456789abcdef", imod(value, 16));
                more = idiv(value, 16);
                <> stringAdd(intHex(more), digit)
            }
    };

    <> stringAdd("\\x", intHex(intFromString(ch)), ";")
};

# Map of special-case characters to their stringified forms.
SPECIAL_CHARS = [
    "\0": "\\0",
    "\n": "\\n",
    "\"": "\\\"",
    "\\": "\\\\"
];

# Helper for stringifying strings: Returns the converted form of the
# given character.
stringChar = { ch ::
    <> ifValue { <> mapGet(SPECIAL_CHARS, ch) }
        { special :: <> special }
        {
            # This checks for the ranges of nonprinting control characters.
            <> ifTrue { <> or { <> lt(ch, " ") }
                              { <> and { <> ge(ch, CHAR_127) }
                                       { <> le(ch, CHAR_159) } } }
                { <> stringHexEscape(ch) }
                { <> ch }
        }
};

# These are all the characters which are allowed to start an identifier.
IDENTIFIER_STARTS = ["a".."z": true, "A".."Z": true, "_": true ];

# These are all the characters which are allowed to be in an identifier.
IDENTIFIER_CHARS = [IDENTIFIER_STARTS*, "0".."9": true];

# Checks to see if the given string has the form of an in-language
# identifier.
isIdentifier = { <out> string ::
    <> and
        { <> gt(lowSize(string), 0) }
        { <> mapGet(IDENTIFIER_STARTS, stringNth(string, 0), false) }
        {
            stringForEach(string)
                { ., ch ::
                    ifFalse { <> mapGet(IDENTIFIER_CHARS, ch, false) }
                        { <out> false }
                };
            <> true
        }
};

# Stringifies a string.
doString = { string, adorn ::
    body = stringReduce("", string)
        { result, ., ch :: <> stringAdd(result, stringChar(ch)) };
    <> adornIf(adorn, "\"", body, "\"")
};

# Stringifies a list.
doList = { list, adorn ::
    body = listReduce("", list)
        { reduction, ., elem ::
            <> stringAdd(
                reduction,
                ifTrue { <> eq(reduction, "") } { <> "" } { <> ", " },
                callSourceString(elem))
        };

    <> adornIf(adorn, "[", body, "]")
};

# Stringifies a map.
doMap = { map, adorn ::
    body = mapReduce("", map)
        { reduction, key, value ::
            <> stringAdd(
                reduction,
                ifTrue { <> eq(reduction, "") } { <> "" } { <> ", " },
                callSourceString(key),
                ": ",
                callSourceString(value))
        };

    <> adornIf(adorn,
        "[",
        ifTrue { <> eq(body, "") } { <> ":" } { <> body },
        "]")
};

# Tokens with special conversions
TOKEN_SPECIALS = [
    false: "false",
    null:  "null",
    true:  "true"
];

# Stringifies a token.
doToken = { <out> token, adorn ::
    ifValue { <> mapGet(TOKEN_SPECIALS, token) }
        { string :: <out> string };

    type = tokenType(token);
    valueString = ifValue { <> tokenValue(token) }
        { value :: <> stringAdd(": ", callSourceString(value)) }
        { <> "" };

    ifTrue { <> and { <> isString(type) } { <> eq(valueString, "") } }
        {
            typeString = ifTrue { <> isIdentifier(type) }
                { <> type }
                { <> callSourceString(type) };
            <out> adornIf(adorn, "@", typeString, "")
        };

    result = stringAdd(callSourceString(type), valueString);
    <> adornIf(adorn, "@[", result, "]")
};

# Stringifies a uniqlet.
doUniqlet = { uniqlet, . ::
    <> "@@"
};

# Stringifies an unknown value type.
doUnknown = { unknown, . ::
    <> stringAdd(
        "[(unknown) ",
        callSourceString(lowType(value)),
        " ",
        callSourceString(lowSize(value)),
        "]")
};

# Mapping from low-layer type names to stringifiers.
STRINGIFIERS = [
    "token":   doToken,
    "int":     doInt,
    "list":    doList,
    "map":     doMap,
    "string":  doString,
    "uniqlet": doUniqlet
];

# Common handler for the two exported variants.
sourceStringGeneral = { value, adorn ::
    stringifier = mapGet(STRINGIFIERS, lowType(value), doUnknown);
    <> stringifier(value, adorn)
};

# Documented in Samizdat Layer 0 spec.
sourceString = { value ::
    <> sourceStringGeneral(value, true)
};
callSourceString(sourceString);

# Documented in Samizdat Layer 0 spec.
sourceStringUnadorned = { value ::
    <> sourceStringGeneral(value, false)
};


#
# `format` function
#

# Gets the current format string position.
xFmtAt = { state ::
    <> mapGet(state, "fmtAt")
};

# Peeks at the current format string character.
xPeek = { state ::
    <> stringNth(mapGet(state, "fmt"), xFmtAt(state))
};

# Peeks at the next format string character.
xPeek1 = { state ::
    at = iadd(1, xFmtAt(state));
    <> stringNth(mapGet(state, "fmt"), at)
};

# Gets the current argument consumption position.
xArgsAt = { state ::
    <> mapGet(state, "argsAt")
};

# Gets the current argument.
xArg = { state ::
    <> ifValue { <> listNth(mapGet(state, "args"), xArgsAt(state)) }
        { value :: <> value }
        { <> "(missing argument)" }
};

# Performs the standard update of state after processing a `%`,
# consuming one argument and two format characters.
xUsualUpdate = { state ::
    argsAt = iadd(1, xArgsAt(state));
    fmtAt = iadd(2, xFmtAt(state));

    <> [state*, "fmtAt": fmtAt, "argsAt": argsAt]
};

# Formats a literal percent.
doPercent = { yield, state ::
    yield("%");

    fmtAt = iadd(2, mapGet(state, "fmtAt"));
    <> [state*, "fmtAt": fmtAt]
};

# Formats a literal quoted argument.
doLiteral = { yield, state ::
    yield(sourceString(xArg(state)));
    <> xUsualUpdate(state)
};

# Formats a literal quoted argument, without top-level adornment.
doUnadornedLiteral = { yield, state ::
    yield(sourceStringUnadorned(xArg(state)));
    <> xUsualUpdate(state)
};

# Formats a string argument.
doPlainString = { yield, state ::
    yield(xArg(state));
    <> xUsualUpdate(state)
};

# Formats a hex int argument.
doHex = { yield, state ::
    yield(stringFromIntBase(xArg(state), 16));
    <> xUsualUpdate(state)
};

# Mapping from format escape characters to their respective handler functions.
FORMATTERS = [
    "%": doPercent,
    "q": doLiteral,
    "Q": doUnadornedLiteral,
    "s": doPlainString,
    "x": doHex
];

# Formats a plain character (that is, returns it as-is).
doPlain = { yield, state, ch ::
    yield(ch);

    fmtAt = iadd(1, mapGet(state, "fmtAt"));
    <> [state*, "fmtAt": fmtAt]
};

# Formats an arbitrary escape.
doEscape = { yield, state ::
    <> ifValue { <> xPeek1(state) }
        { ch ::
            <> ifValue { <> mapGet(FORMATTERS, ch) }
                { formatter :: <> formatter(yield, state) }
                { <> doPercent(yield, state) }
        }
        { <> doPercent(yield, state) }
};

# Formats a single character out of the format string.
formatOne = { yield, state ::
    <> ifValue { <> xPeek(state) }
        { ch ::
            <> ifTrue { <> eq(ch, "%") }
                { <> doEscape(yield, state) }
                { <> doPlain(yield, state, ch) }
        }
        { yield() }
};

# Documented in Samizdat Layer 0 spec.
format = { <out> formatString, rest* ::
    formatter = object(formatOne, [
        "fmt":    formatString,
        "fmtAt":  0,
        "args":   rest,
        "argsAt": 0
    ]);

    loopReduce("") { result ::
        <> ifValue { <> formatter() }
            { s :: <> stringAdd(result, s) }
            { <out> result }
    }
};


#
# Export mechanics
#

<> [
    "format": format,
    "sourceString": sourceString,
    "sourceStringUnadorned": sourceStringUnadorned
]
