# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Generator functions
#


# `ValueGenerator` Type
#
# A `ValueGenerator` is a generator that just generates a particular value,
# repeatedly, ad infinitum.

fn ValueGenerator_collect(vgen) {
    io0Die("Unbounded generator.");
};

fn ValueGenerator_nextValue(vgen, box) {
    store(box, dataOf(vgen));
    <> vgen
};

genericBind(collect,   "ValueGenerator", ValueGenerator_collect);
genericBind(nextValue, "ValueGenerator", ValueGenerator_nextValue);

fn makeValueGenerator(value) {
    <> @[ValueGenerator: value]
};


#
# Private Definitions
#

# A "voided" generator, that is, one that just stores void in its given
# box. This is defined to make the intent of the code that uses it clearer.
def VOIDED_GENERATOR = [];

# An empty list generator, that is, a generator that always generates
# the empty list.
def EMPTY_LIST_GENERATOR = makeValueGenerator([]);

# General sequential-incrementing-value generator. Takes a "filter" function
# (function from int to the proper actual value, returns void for
# out-of-range int), an int starting value, and an int increment.
fn makeIncrementGenerator(filterFunction, firstValue, increment) {
    # Main generator maker.
    fn makeIncrementGenerator1(value) {
        <> { box ::
            <> ifValue { <> filterFunction(value) }
                { result ::
                    store(box, result);
                    <> makeIncrementGenerator1(add(value, increment));
                }
                {
                    # The filter indicated that the generator is voided.
                    store(box);
                }
        }
    };

    <> makeIncrementGenerator1(firstValue)
};

# Makes a generator for an arbitrary collection.
fn makeCollectionGenerator(coll) {
    def sz = size(coll);

    <> makeIncrementGenerator(0, 1)
        { index <> nth(coll, index) }
};

# Degenerate generator maker for functions, which are tacitly assumed to
# already be generators.
fn makeFunctionGenerator(function) {
    <> function
};

# Map from low-layer value types to corresponding appropriate generator
# maker functions.
def GENERATOR_MAKERS = [
    (Function): makeFunctionGenerator,
    (Generic):  makeFunctionGenerator,
    (List):     makeCollectionGenerator,
    (Map):      makeCollectionGenerator,
    (String):   makeCollectionGenerator
];

# Map from `[direction, inclusive]` pairs to appropriate test functions.
# Note that in order to have the right pass-through test result, the test
# is called as `test(limit, value)` and not with the arguments the other
# way around.
def INT_RANGE_TESTS = [
    [-1, false]: lt,
    [-1, true]:  le,
    [1,  false]: gt,
    [1,  true]:  ge
];

# Generic generator maker for int and single-character string ranges. If
# `optLimit` is passed, then `optInclusive` needs to be as well.
fn makeRangeGenerator(firstValue, increment, optLimit?, optInclusive?) {
    # This test also ends up guaranteeing that `firstValue` is either an int
    # or a single-character string, which is why it goes before the
    # zero-increment special case.
    def firstInt = ifIs { <> isInt(firstValue) }
        { <> firstValue }
        { <> intFromChar(firstValue) };

    ifIs { <> eq(increment, 0) }
        {
            # Special case: A range with increment of zero always just
            # yields the `firstValue` and then becomes voided.
            return makeCollectionGenerator([firstValue])
        };

    def limitFunction = ifValue { <> optLimit* }
        { limit ::
            def limitInt = ifIs { <> isInt(limit) }
                {
                    <> ifIs { <> isInt(firstValue) }
                        { <> limit }
                        { io0Die("Type mismatch between firstValue and limit.") };
                }
                { <> intFromChar(limit) };
            def testFunction =
                get(INT_RANGE_TESTS, [sign(increment), (optInclusive*)]);
            <> { x <> testFunction(limitInt, x) }
        }
        {
            # Open range; no limit test.
            <> { x <> x }
        };

    def filterFunction = ifIs { <> isInt(firstValue) }
        { <> limitFunction }
        { <> { x <> charFromInt(&limitFunction(x)) } };

    <> makeIncrementGenerator(filterFunction, firstInt, increment)
};

# Helper for `paraGenerator`, which implements the degenerate case of
# a single inner generator. This can end up being usefully used in a few
# cases, e.g. by virtue of `filterGenerator` always calling `paraGenerator`.
fn oneItemParaGenerator(generator) {
    <> { <out> box ::
        def innerBox = makeYieldBox();
        <> ifValue { <> generator(innerBox) }
            { nextGenerator ::
                store(box, [fetch(innerBox)]);
                <> oneItemParaGenerator(nextGenerator)
            }
    }
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn collectFilter(filterFunction, generators*) {
    ifIs { <> eq(size(generators), 1) }
        {
            def generator = generators*;
            ifIs { <> isList(generator) } {
                # We are filtering a single list, so just use the
                # special-case (and more efficient) `listFilter`.
                return listFilter(filterFunction, generator)
            }
        };

    <> [filterGenerator(filterFunction, generators*)*]
};

# Documented in Samizdat Layer 0 spec.
fn collectGenerator(generator) {
    # Avoid pointless list->generator->list conversion.
    ifIs { <> isList(generator) }
        { return generator };

    <> [generatorFromValue(generator)*]
};

# Documented in Samizdat Layer 0 spec.
fn doFilter(filterFunction, generators*) {
    loopReduce(paraGenerator(generators*))
        { gen ::
            def box = makeYieldBox();
            <> ifValue { <> gen(box) }
                { nextGenerator ::
                    filterFunction(fetch(box)*);
                    <> [nextGenerator]
                }
                {
                    # The inner generator was voided.
                    return
                }
        }
};

# Documented in Samizdat Layer 0 spec.
fn doGenerator(generator) {
    loopReduce(generatorFromValue(generator)) { gen ::
        <> ifValue { <> gen(nullBox) }
            { nextGen <> [nextGen] }
            { return }
    }
};

# Documented in Samizdat Layer 0 spec.
fn doReduce(reduceFunction, generators, baseValues) {
    def gen = paraGenerator(generators*);

    loopReduce(gen, baseValues)
        { gen, values ::
            def box = makeYieldBox();
            <> ifValue { <> gen(box) }
                { nextGenerator ::
                    <> ifValue { <> reduceFunction(fetch(box)*, values*) }
                        { nextVals <> [nextGenerator, nextVals] }
                        {
                            # The reduce function discarded the values.
                            <> [nextGenerator, values]
                        }
                }
                {
                    # The inner generator was voided.
                    return values
                }
        }
};

# Documented in Samizdat Layer 0 spec.
fn doReduce1(reduceFunction, generator, baseValue) {
    loopReduce(generatorFromValue(generator), baseValue)
        { gen, value ::
            def box = makeYieldBox();
            <> ifValue { <> gen(box) }
                { nextGenerator ::
                    <> ifValue { <> reduceFunction(fetch(box), value) }
                        { nextVal <> [nextGenerator, nextVal] }
                        {
                            # The reduce function discarded the value.
                            <> [nextGenerator, value]
                        }
                }
                {
                    # The inner generator was voided.
                    return value
                }
        }
};

# Documented in Samizdat Layer 0 spec.
fn exclusiveRange(firstValue, increment, limit) {
    <> makeRangeGenerator(firstValue, increment, limit, false)
};

# Documented in Samizdat Layer 0 spec.
fn filterGenerator(filterFunction, generators*) {
    # Main generator maker, which takes a generator (per se) as its argument.
    fn filterGenerator1(gen) {
        <> { <out> box ::
            # This loop handles the fact that the filter function is
            # allowed to yield void to indicate a generated value is to
            # be discarded.
            loopReduce(gen) { <next> gen ::
                def innerBox = makeYieldBox();
                ifValue { <> gen(innerBox) }
                    { nextGenerator ::
                        ifValue { <> filterFunction(fetch(innerBox)*) }
                            { value ::
                                store(box, value);
                                <out> filterGenerator1(nextGenerator)
                            }
                            {
                                # The filter discarded the value. Iterate!
                                <next> [nextGenerator]
                            }
                    };

                # The inner generator was voided.
                store(box);
                <out>
            }
        }
    };

    <> filterGenerator1(paraGenerator(generators*))
};

# Documented in Samizdat Layer 0 spec.
fn generatorFromValue(value) {
    <> ifValue { <> get(GENERATOR_MAKERS, typeOf(value)) }
        { maker <> maker(value) }
        {
            # Catch-all. If you can call `call` on it, treat it as a
            # generator.
            <> ifIs { <> canCall(call, value) }
                { <> value }
                { io0Die("Invalid generator source.") }
        }
};

# Documented in Samizdat Layer 0 spec.
fn inclusiveRange(firstValue, increment, limit) {
    <> makeRangeGenerator(firstValue, increment, limit, true)
};

# Documented in Samizdat Layer 0 spec.
fn mapFromGenerator(generator) {
    # Avoid pointless map->generator->map conversion.
    ifIs { <> isMap(generator) }
        { return generator };

    <> cat([:], generatorFromValue(generator)*)
};

# Documented in Samizdat Layer 0 spec.
fn openRange(firstValue, increment) {
    <> makeRangeGenerator(firstValue, increment)
};

# Documented in Samizdat Layer 0 spec.
fn optGenerator(generator) {
    # Main generator maker, which takes a generator (per se) as its argument.
    fn optGenerator1(gen) {
        <> { box ::
            def innerBox = makeYieldBox();
            <> ifValue { <> gen(innerBox) }
                { nextGenerator ::
                    store(box, [fetch(innerBox)]);
                    <> optGenerator1(nextGenerator)
                }
                { <> nextValue(EMPTY_LIST_GENERATOR, box) }
        }
    };

    <> optGenerator1(generatorFromValue(generator))
};

# Documented in Samizdat Layer 0 spec.
fn paraGenerator(generators*) {
    # Main generator maker, which takes a list (per se) of generators
    # as a single argument.
    fn paraGenerator1(generators) {
        <> { <out> box ::
            def generatorCalls = listFilter(generators)
                { gen ::
                    def innerBox = makeYieldBox();
                    <> ifValue { <> gen(innerBox) }
                        { nextGenerator ::
                            <> [fetch(innerBox), nextGenerator]
                        }
                        {
                            store(box); # Void result.
                            <out>
                        }
                };
            def yields = listFilter(generatorCalls)
                { one <> nth(one, 0) };
            def nexts = listFilter(generatorCalls)
                { one <> nth(one, 1) };

            store(box, yields);
            <> paraGenerator1(nexts);
        }
    };

    # Handle the degenerate case of no arguments.
    ifIs { <> eq(generators, []) }
        { return VOIDED_GENERATOR };

    # Handle the degenerate case of a signle argument.
    ifIs { <> eq(size(generators), 1) }
        { return oneItemParaGenerator(generatorFromValue(generators*)) };

    # Coerce all the original arguments to generators.
    def generatorsPerSe = listFilter(generators)
        { gen <> generatorFromValue(gen) };

    # Make the initial inner call (to the function defined above).
    <> paraGenerator1(generatorsPerSe)
};

# Documented in Samizdat Layer 0 spec.
fn reduceGenerator(reduceFunction, generators, baseValues) {
    # Main generator maker, which takes a generator (per se) and the
    # current reduction result (list) as its arguments.
    fn reduceGenerator1(gen, values) {
        <> { <out> box ::
            # This loop handles the fact that the reduce function is
            # allowed to yield void to indicate a generated value is to
            # be discarded.
            loopReduce(gen) { <next> gen ::
                def innerBox = makeYieldBox();
                ifValue { <> gen(innerBox) }
                    { nextGenerator ::
                        ifValue
                            { <> reduceFunction(fetch(innerBox)*, values*) }
                            { nextVals ::
                                store(box, nextVals);
                                <out> reduceGenerator1(
                                    nextGenerator, nextVals)
                            }
                            {
                                # The reducer discarded the values. Iterate!
                                <next> [nextGenerator]
                            }
                    };

                # The inner generator was voided.
                store(box);
                <out>
            }
        }
    };

    <> reduceGenerator1(paraGenerator(generators*), baseValues)
};

# Documented in Samizdat Layer 0 spec.
fn seqGenerator(generators*) {
    # Return a voided generator if we weren't passed any arguments.
    ifIs { <> eq(generators, []) }
        { return VOIDED_GENERATOR };

    # Return a plain (unwrapped) generator if we were only passed one
    # argument. (This saves some gratuitous call wrapping / double yields.)
    ifIs { <> eq(size(generators), 1) }
        { return generatorFromValue(generators*) };

    fn seqGenerator1(gen) {
        <> { box ::
            def innerBox = makeYieldBox();
            <> ifValue { <> gen(innerBox) }
                { nextGenerator ::
                    store(box, fetch(innerBox));
                    <> seqGenerator1(nextGenerator)
                }
                {
                    def nextGenerator =
                        seqGenerator(butFirst(generators)*);
                    <> nextGenerator(box)
                }
        }
    };

    <> seqGenerator1(generatorFromValue(first(generators)));
};

# Documented in Samizdat Layer 0 spec.
fn stringFromGenerator(generator) {
    # Avoid pointless string->generator->string conversion.
    ifIs { <> isString(generator) }
        { return generator };

    <> cat("", generatorFromValue(generator)*)
};

# Documented in Samizdat Layer 0 spec.
fn tokenGenerator(generator) {
    <> filterGenerator(generator)
        { elem <> @[(elem)] }
};

<> [
    collectFilter:       collectFilter,
    collectGenerator:    collectGenerator,
    doFilter:            doFilter,
    doGenerator:         doGenerator,
    doReduce:            doReduce,
    doReduce1:           doReduce1,
    exclusiveRange:      exclusiveRange,
    filterGenerator:     filterGenerator,
    generatorFromValue:  generatorFromValue,
    inclusiveRange:      inclusiveRange,
    mapFromGenerator:    mapFromGenerator,
    openRange:           openRange,
    optGenerator:        optGenerator,
    paraGenerator:       paraGenerator,
    reduceGenerator:     reduceGenerator,
    seqGenerator:        seqGenerator,
    stringFromGenerator: stringFromGenerator,
    tokenGenerator:      tokenGenerator
]
