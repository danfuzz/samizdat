# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Generator functions
#


#
# Helper definitions
#

# Standard "voided" generator. This is a generator, not a generator
# constructor.
fn voidedGenerator(box) {
    boxSet(box)
};

# Empty list generator. It always yields the empty list and returns
# itself. This is a generator, not a generator constructor.
fn emptyListGenerator(box) {
    boxSet(box, []);
    <> emptyListGenerator
};

# General sequential-value generator. Takes an int starting value, an int
# increment, a "filter" function (function from int to the proper actual
# value, returns void for out-of-range int).
fn makeSeqGenerator(first, increment, filterFunction) {
    # Main generator maker.
    fn makeSeqGenerator1(value) {
        <> ifValue { <> filterFunction(value) }
            { result ::
                <> { box ::
                    boxSet(box, result);
                    <> makeSeqGenerator1(iadd(value, increment));
                }
            }
            { <> voidedGenerator }
    };

    <> makeSeqGenerator1(first)
};

# Makes a generator for a list.
fn makeListGenerator(list) {
    <> makeSeqGenerator(0, 1)
        { index :: <> listNth(list, index) }
};

# Makes a generator for a map.
fn makeMapGenerator(map) {
    <> makeSeqGenerator(0, 1)
        { index :: <> mapNth(map, index) }
};

# Makes a generator for a string.
fn makeStringGenerator(string) {
    <> makeSeqGenerator(0, 1)
        { index :: <> stringNth(string, index) }
};

# Degenerate generator maker for uniqlets, which are tacitly assumed to
# already be generators.
fn makeUniqletGenerator(uniqlet) {
    <> uniqlet
};

# Map from low-layer value types to corresponding appropriate generator
# maker functions.
def GENERATOR_MAKERS = [
    list:    makeListGenerator,
    map:     makeMapGenerator,
    string:  makeStringGenerator,
    uniqlet: makeUniqletGenerator
];

# Map from `[direction, inclusive]` pairs to appropriate test functions.
# Note that in order to have the right pass-through test result, the test
# is called as `test(limit, value)` and not with the arguments the other
# way around.
def INT_RANGE_TESTS = [
    [-1, false]: lt,
    [-1, true]:  le,
    [1,  false]: gt,
    [1,  true]:  ge
];

# Generic generator maker for int and single-character string ranges. If
# `optLimit` is passed, then `optInclusive` needs to be as well.
fn makeRangeGenerator(first, increment, optLimit?, optInclusive?) {
    # This test also ends up guaranteeing that `first` is either an int
    # or a single-character string, which is why it goes before the
    # zero-increment special case.
    def firstInt = ifIs { <> isInt(first) }
        { <> first }
        { <> intFromString(first) };

    ifIs { <> eq(increment, 0) }
        {
            # Special case: A range with increment of zero always just
            # yields the `first` value and then becomes voided.
            return makeListGenerator([first])
        };

    def limitFunction = ifValue { <> optLimit* }
        { limit ::
            def limitInt = ifIs { <> isInt(limit) }
                {
                    <> ifIs { <> isInt(first) }
                        { <> limit }
                        { io0Die("Type mismatch between first and limit.") };
                }
                { <> intFromString(limit) };
            def testFunction =
                mapGet(INT_RANGE_TESTS, [isign(increment), (optInclusive*)]);
            <> { x :: <> testFunction(limitInt, x) }
        }
        {
            # Open range; no limit test.
            <> { x :: <> x }
        };

    def filterFunction = ifIs { <> isInt(first) }
        { <> limitFunction }
        { <> { x :: <> stringFromInt(limitFunction(x)) } };

    <> makeSeqGenerator(firstInt, increment, filterFunction)
};


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
fn filterGenerator(value, filterFunction) {
    # Main generator maker, which takes a generator (per se) as its argument.
    fn filterGenerator1(gen) {
        <> { <out> box ::
            # This loop handles the fact that the filter function is
            # allowed to yield void to indicate a generated value is to
            # be discarded.
            loopReduce(gen) { <next> gen ::
                def innerBox = yieldBox();
                ifValue { <> gen(innerBox) }
                    { nextGenerator ::
                        ifValue { <> filterFunction(boxGet(innerBox)) }
                            { value ::
                                boxSet(box, value);
                                <out> filterGenerator1(nextGenerator)
                            }
                            {
                                # The filter discarded the value. Iterate!
                                <next> nextGenerator
                            }
                    };

                # The inner generator was voided.
                boxSet(box);
                <out>
            }
        }
    };

    <> filterGenerator1(generatorFromValue(value));
};

# Documented in Samizdat Layer 0 spec.
fn generatorForExclusiveRange(first, increment, limit) {
    <> makeRangeGenerator(first, increment, limit, false)
};

# Documented in Samizdat Layer 0 spec.
fn generatorForInclusiveRange(first, increment, limit) {
    <> makeRangeGenerator(first, increment, limit, true)
};

# Documented in Samizdat Layer 0 spec.
fn generatorForOpenRange(first, increment) {
    <> makeRangeGenerator(first, increment)
};

# Documented in Samizdat Layer 0 spec.
fn generatorFromValue(value) {
    <> ifValue { <> mapGet(GENERATOR_MAKERS, lowType(value)) }
        { maker :: <> maker(value) }
        { io0Die("Invalid generator source.") }
};

# Documented in Samizdat Layer 0 spec.
fn listFromGenerator(value) {
    # Avoid pointless list->generator->list conversion.
    ifIs { <> isList(value) }
        { return value };

    loopReduce([generatorFromValue(value), []]) { result ::
        def gen = listNth(result, 0);
        def list = listNth(result, 1);
        def box = yieldBox();
        <> ifValue { <> gen(box) }
            { nextGenerator :: <> [nextGenerator, [list*, boxGet(box)]] }
            { return list }
    }
};

# Documented in Samizdat Layer 0 spec.
fn listForExclusiveRange(first, increment, limit) {
    <> listFromGenerator(generatorForExclusiveRange(first, increment, limit))
};

# Documented in Samizdat Layer 0 spec.
fn listForInclusiveRange(first, increment, limit) {
    <> listFromGenerator(generatorForInclusiveRange(first, increment, limit))
};

# Documented in Samizdat Layer 0 spec.
fn optGenerator(value) {
    # Main generator maker, which takes a generator (per se) as its argument.
    fn optGenerator1(gen) {
        <> { box ::
            def innerBox = yieldBox();
            <> ifValue { <> gen(innerBox) }
                { nextGenerator ::
                    boxSet(box, [boxGet(innerBox)]);
                    <> optGenerator1(nextGenerator)
                }
                { <> emptyListGenerator(box) }
        }
    };

    <> optGenerator1(generatorFromValue(value));
};

# Documented in Samizdat Layer 0 spec.
fn paraGeneratorFromValues(values*) {
    # Main generator maker, which takes a list (per se) of generators
    # as a single argument.
    fn paraGeneratorFromValues1(generators) {
        <> { <out> box ::
            def generatorCalls = listMap(generators)
                { ., gen ::
                    def innerBox = yieldBox();
                    <> ifValue { <> gen(innerBox) }
                        { nextGenerator ::
                            <> [boxGet(innerBox), nextGenerator]
                        }
                        {
                            boxSet(box); # Void result.
                            <out>
                        }
                };
            def yields = listMap(generatorCalls)
                { ., one :: <> listNth(one, 0) };
            def nexts = listMap(generatorCalls)
                { ., one :: <> listNth(one, 1) };

            boxSet(box, yields);
            <> paraGeneratorFromValues1(nexts);
        }
    };

    # Handle the degenerate case of no arguments.
    ifValue { <> eq(values, []) }
        { . :: return voidedGenerator };

    # Coerce all the original arguments to generators.
    def generators = listMap(values)
        { ., value :: <> generatorFromValue(value) };

    # Make the initial inner call (to the function defined above).
    <> paraGeneratorFromValues1(generators)
};

# Documented in Samizdat Layer 0 spec.
fn seqGeneratorFromValues(values*) {
    # Return a voided generator if we weren't passed any arguments.
    ifIs { <> eq(values, []) }
        { return voidedGenerator };

    # Return a plain (unwrapped) generator if we were only passed one
    # argument. (This saves some gratuitous call wrapping / double yields.)
    ifIs { <> eq(lowSize(values), 1) }
        { return generatorFromValue(values*) };

    fn seqGenerator1(gen) {
        <> { box ::
            def innerBox = yieldBox();
            <> ifValue { <> gen(innerBox) }
                { nextGenerator ::
                    boxSet(box, boxGet(innerBox));
                    <> seqGenerator1(nextGenerator)
                }
                {
                    def nextGenerator =
                        seqGeneratorFromValues(listDelNth(values, 0)*);
                    <> nextGenerator(box)
                }
        }
    };

    <> seqGenerator1(generatorFromValue(listNth(values, 0)));
};

# Documented in Samizdat Layer 0 spec.
fn tokenGeneratorFromValue(value) {
    <> filterGenerator(value)
        { elem :: <> @[(elem)] }
};

<> [
    filterGenerator:            filterGenerator,
    generatorForExclusiveRange: generatorForExclusiveRange,
    generatorForInclusiveRange: generatorForInclusiveRange,
    generatorForOpenRange:      generatorForOpenRange,
    generatorFromValue:         generatorFromValue,
    listForExclusiveRange:      listForExclusiveRange,
    listForInclusiveRange:      listForInclusiveRange,
    listFromGenerator:          listFromGenerator,
    optGenerator:               optGenerator,
    paraGeneratorFromValues:    paraGeneratorFromValues,
    seqGeneratorFromValues:     seqGeneratorFromValues,
    tokenGeneratorFromValue:    tokenGeneratorFromValue
]
