# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Generator functions
#


#
# Private Definitions
#

# Helper for `paraGenerator`, which implements the degenerate case of
# a single inner generator. This can end up being usefully used in a few
# cases, e.g. by virtue of `filterGenerator` always calling `paraGenerator`.
fn oneItemParaGenerator(generator) {
    <> { <out> box ::
        def innerBox = makeYieldBox();
        <> ifValue { <> nextValue(generator, innerBox) }
            { nextGenerator ::
                store(box, [fetch(innerBox)]);
                <> oneItemParaGenerator(nextGenerator)
            }
    }
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn collectFilter(filterFunction, generators*) {
    ifIs { <> eq(size(generators), 1) }
        {
            def generator = generators*;
            ifIs { <> isList(generator) } {
                # We are filtering a single list, so just use the
                # special-case (and more efficient) `listFilter`.
                return listFilter(filterFunction, generator)
            }
        };

    <> [filterGenerator(filterFunction, generators*)*]
};

# Documented in Samizdat Layer 0 spec.
fn doFilter(filterFunction, generators*) {
    loopReduce(paraGenerator(generators*))
        { gen ::
            def box = makeYieldBox();
            <> ifValue { <> nextValue(gen, box) }
                { nextGenerator ::
                    filterFunction(fetch(box)*);
                    <> [nextGenerator]
                }
                {
                    # The inner generator was voided.
                    return
                }
        }
};

# Documented in Samizdat Layer 0 spec.
fn doGenerator(generator) {
    loopReduce(generator) { gen ::
        <> ifValue { <> nextValue(gen, nullBox) }
            { nextGen <> [nextGen] }
            { return }
    }
};

# Documented in Samizdat Layer 0 spec.
fn doReduce(reduceFunction, generator, baseValues*) {
    loopReduce(generator, baseValues)
        { gen, values ::
            def box = makeYieldBox();
            <> ifValue { <> nextValue(gen, box) }
                { nextGenerator ::
                    <> ifValue { <> reduceFunction(fetch(box), values*) }
                        { nextValues <> [nextGenerator, nextValues] }
                        {
                            # The reduce function discarded the values.
                            <> [nextGenerator, values]
                        }
                }
                {
                    # The inner generator was voided.
                    return values
                }
        }
};

# Documented in Samizdat Layer 0 spec.
fn doReduce1(reduceFunction, generator, baseValue) {
    loopReduce(generator, baseValue)
        { gen, value ::
            def box = makeYieldBox();
            <> ifValue { <> nextValue(gen, box) }
                { nextGenerator ::
                    <> ifValue { <> reduceFunction(fetch(box), value) }
                        { nextValue <> [nextGenerator, nextValue] }
                        {
                            # The reduce function discarded the value.
                            <> [nextGenerator, value]
                        }
                }
                {
                    # The inner generator was voided.
                    return value
                }
        }
};

# Documented in Samizdat Layer 0 spec.
fn filterGenerator(filterFunction, generators*) {
    # Main generator maker, which takes a generator (per se) as its argument.
    fn filterGenerator1(gen) {
        <> { <out> box ::
            # This loop handles the fact that the filter function is
            # allowed to yield void to indicate a generated value is to
            # be discarded.
            loopReduce(gen) { <next> gen ::
                def innerBox = makeYieldBox();
                ifValue { <> nextValue(gen, innerBox) }
                    { nextGenerator ::
                        ifValue { <> filterFunction(fetch(innerBox)*) }
                            { value ::
                                store(box, value);
                                <out> filterGenerator1(nextGenerator)
                            }
                            {
                                # The filter discarded the value. Iterate!
                                <next> [nextGenerator]
                            }
                    };

                # The inner generator was voided.
                store(box);
                <out>
            }
        }
    };

    <> filterGenerator1(paraGenerator(generators*))
};

# Documented in Samizdat Layer 0 spec.
fn mapFromGenerator(generator) {
    # Avoid pointless map->generator->map conversion.
    ifIs { <> isMap(generator) }
        { return generator };

    <> cat([:], generator*)
};

# Documented in Samizdat Layer 0 spec.
fn paraGenerator(generators*) {
    # Main generator maker, which takes a list (per se) of generators
    # as a single argument.
    fn paraGenerator1(generators) {
        <> { <out> box ::
            def generatorCalls = listFilter(generators)
                { gen ::
                    def innerBox = makeYieldBox();
                    <> ifValue { <> nextValue(gen, innerBox) }
                        { nextGenerator ::
                            <> [fetch(innerBox), nextGenerator]
                        }
                        {
                            store(box); # Void result.
                            <out>
                        }
                };
            def yields = listFilter(generatorCalls)
                { one <> nth(one, 0) };
            def nexts = listFilter(generatorCalls)
                { one <> nth(one, 1) };

            store(box, yields);
            <> paraGenerator1(nexts);
        }
    };

    # Handle the degenerate case of no arguments.
    ifIs { <> eq(generators, []) }
        { return nullGenerator };

    # Handle the degenerate case of a signle argument.
    ifIs { <> eq(size(generators), 1) }
        { return oneItemParaGenerator(generators*) };

    # Make the initial inner call (to the function defined above).
    <> paraGenerator1(generators)
};

# Documented in Samizdat Layer 0 spec.
fn tokenGenerator(generator) {
    <> filterGenerator(generator)
        { elem <> @[(elem)] }
};

<> [
    collectFilter:       collectFilter,
    doFilter:            doFilter,
    doGenerator:         doGenerator,
    doReduce:            doReduce,
    doReduce1:           doReduce1,
    filterGenerator:     filterGenerator,
    mapFromGenerator:    mapFromGenerator,
    paraGenerator:       paraGenerator,
    tokenGenerator:      tokenGenerator
]
