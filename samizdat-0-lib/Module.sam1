# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#


#
# Private Definitions
#

# Box containing a set-like map of fully-qualified names representing
# modules in the middle of being loaded.
def thePendingBox = makeMutableBox([:]);


#
# Exported Definitions
#

# Documented in spec.
fn moduleUse(searchInfo) {
    def name = get(searchInfo, "name");

    ifValue { <> moduleGet(searchInfo) }
        { module :: return module };

    def pendings = fetch(thePendingBox);
    ifIs { <> get(pendings, name) }
        {
            io0Die(cat(
                "Dependency loop with modules: ",
                sourceString(keyList(pendings))))
        };

    # Indicate that the module is in the process of being loaded.
    store(thePendingBox, put(pendings, name, null));

    def moduleReader = io0SandboxedReader([MODULE_PATH*, name*]);
    def infoText = moduleReader(["module.sam"]);
    def info = sam0Eval(LIBRARY, sam0ParseProgram(infoText))();

    # TODO: Currently ignores everything about `searchInfo` other than the name.
    ifIs { <> ne(name, get(info, "name")) }
        { io0Die(cat("Module name mismatch: ", sourceString(name))) };

    def mainText = moduleReader(["main.sam"]);
    def subLibrary = makeLibrary([LIBRARY*:, INFO: info, READER: moduleReader]);
    def exports = sam0Eval(subLibrary, sam0ParseProgram(mainText))();

    def result = @[Module: [info: info, exports: exports]];
    moduleDef(result);

    # Indicate that the module load is no longer in-process.
    update(thePendingBox, { pendings <> del(pendings, name) });

    <> result
};

<> [
    moduleUse: moduleUse
]
