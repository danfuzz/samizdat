# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#

def Box = moduleGet({name: ["core", "Box"]});
def Io1 = moduleGet({name: ["core", "Io1"]});


#
# Private Definitions
#

# Parsed version of `ENVIRONMENT::MODULE_PATHS`, which includes a parsed
# version of `LIBRARY_DIR` as the first element.
def MODULE_PATHS_LIST = ifValue { <> ENVIRONMENT::MODULE_PATHS }
    { paths <> Io1::pathListFromFlat(paths) }
    { <> [] };

# The (base) name of a module metainformation file.
def MODULE_FILE_NAME = "module.sam";

# Box containing a set-like map of fully-qualified names representing
# modules in the middle of being loaded.
def thePendingBox = Box::makeMutableBox({});

# Finds the directory for the named module, by iterating over
# `MODULE_PATHS_LIST`, looking for a `module.sam` file. Either returns
# the directory path or dies with an error.
fn findModuleDirectory(fqName, optPaths?) {
    def paths = ifValueOr { <> optPaths* } { <> MODULE_PATHS_LIST };

    ifIs { <> eq(paths, []) }
        { Io1::die(cat("Module not found: ", stringFromModuleName(fqName))) };

    def oneDir = [Collection::first(paths)*, fqName*];

    <> ifIs { <> Io1::fileExists([oneDir*, MODULE_FILE_NAME]) }
        { <> oneDir }
        { <> findModuleDirectory(fqName, Collection::butFirst(paths)) }
};



#
# Exported Definitions
#

# Documented in spec.
fn moduleUse(searchInfo) {
    def fqName = searchInfo::name;

    ifValue { <> moduleGet(searchInfo) }
        { modu -> return modu };

    def pendings = Box::fetch(thePendingBox);
    ifIs { <> get(pendings, fqName) }
        {
            Io1::die(cat(
                "Dependency loop with modules: ",
                Format::source(Collection::keyList(pendings))))
        };

    # Indicate that the module is in the process of being loaded.
    Box::store(thePendingBox, put(pendings, fqName, null));

    def moduleDir = findModuleDirectory(fqName);
    def moduleReader = Io1::sandboxedReader(moduleDir);
    def infoText = moduleReader(["module.sam"]);
    def info = sam0Eval(LIBRARY, sam0ParseExpression(infoText));

    # TODO: Currently ignores everything about `searchInfo` other than the name.
    ifIs { <> ne(fqName, info::name) }
        { io1::die(cat("Module name mismatch: ", stringFromFqName(fqName))) };

    def mainText = moduleReader(["main.sam"]);
    def subLibrary = makeLibrary({LIBRARY*, INFO: info, READER: moduleReader});
    def exports = sam0Eval(subLibrary, sam0ParseProgram(mainText))();

    def result = @[Module: {info: info, exports: exports}];
    moduleDef(result);

    # Indicate that the module load is no longer in-process.
    Box::update(thePendingBox,
        { pendings <> Collection::del(pendings, fqName) });

    <> result
};

<> {
    moduleUse: moduleUse
}
