# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#

def Box = moduleUse({name: ["core", "Box"]});
def Io1 = moduleUse({name: ["core", "Io1"]});
def Lang0 = moduleUse({name: ["core", "Lang0"]});
def Module0 = moduleUse({name: ["core", "Module0"]});


#
# Private Definitions
#

# Box for the parsed list of module paths.
def theModulePathsBox = Box::makeYieldBox();

# The (base) name of a module metainformation file.
def MODULE_FILE_NAME = "module.sam";

# The (base) name of a main module program file.
def MAIN_FILE_NAME = "main.sam";

# Box containing a set-like map of fully-qualified names representing
# modules in the middle of being loaded.
def thePendingBox = Box::makeMutableBox({});

# Finds the directory for the named module, by iterating over
# `MODULE_PATHS_LIST`, looking for a `module.sam` file. Either returns
# the directory path or dies with an error.
fn findModuleDirectory(fqName) {
    Generator::filterPump(Box::fetch(theModulePathsBox))
        { onePath ->
            def fullPath = [onePath*, fqName*];
            ifIs { <> Io1::fileExists([fullPath*, MODULE_FILE_NAME]) }
                { return fullPath }
        };

    Io1::die(cat(
        "Module not found: ",
        Module0::stringFromModuleName(fqName)))
};


#
# Exported Definitions
#

# Documented in spec.
fn initModule(moduleDirs) {
    def pathsList = Io1::pathListFromFlat(moduleDirs);
    Box::store(theModulePathsBox, pathsList)
};

# Documented in spec.
fn moduleUse(searchInfo) {
    def fqName = searchInfo::name;

    ifValue { <> Module0::moduleGet(searchInfo) }
        { modu -> return modu };

    def pendings = Box::fetch(thePendingBox);
    ifIs { <> get(pendings, fqName) }
        {
            Io1::die(cat(
                "Dependency loop with modules: ",
                Format::source(Collection::keyList(pendings))))
        };

    # Indicate that the module is in the process of being loaded.
    Box::store(thePendingBox, Collection::put(pendings, fqName, null));

    def baseContext = Module0::getGlobals(
        Module0::moduleGet({name: ["core", "Globals"]}));
    def moduleDir = findModuleDirectory(fqName);

    def result = Module0::load(baseContext, moduleDir);
    def info = Module0::getInfo(result);

    # TODO: Currently ignores everything about `searchInfo` other than the name.
    ifIs { <> ne(fqName, info::name) }
        { Io1::die(cat("Module name mismatch: ", stringFromFqName(fqName))) };

    Module0::moduleDef(result);

    # Indicate that the module load is no longer in-process.
    Box::update(thePendingBox,
        { pendings <> Collection::del(pendings, fqName) });

    <> result
};

<> {
    # Re-exports from `core::Module0`.
    getAllModules:        Module0::getAllModules,
    getExports:           Module0::getExports,
    getGlobals:           Module0::getGlobals,
    getInfo:              Module0::getInfo,
    moduleDef:            Module0::moduleDef,
    moduleGet:            Module0::moduleGet,
    stringFromModuleName: Module0::stringFromModuleName,

    # Defined here.
    initModule: initModule,
    moduleUse:  moduleUse
}
