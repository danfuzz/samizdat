# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#

def Box = moduleUse({name: ["core", "Box"]});
def Io1 = moduleUse({name: ["core", "Io1"]});
def Lang0 = moduleUse({name: ["core", "Lang0"]});
def Module0 = moduleUse({name: ["core", "Module0"]});


#
# Private Definitions
#

# Finds the directory for the named module, by iterating over the given
# `modulePaths`, looking for a `module.sam` file. Either returns
# the tail of `modulePaths` that starts with the module path where the
# module was found, or dies with an error.
fn findModuleDirectory(searchInfo, modulePaths) {
    def fqName = searchInfo::name;

    loopReduce(modulePaths) { paths ->
        ifIs { <> eq(paths, []) }
            {
                Io1::die(cat(
                "Module not found: ",
                Module0::stringFromModuleName(fqName)))
            };

        def moduleFile = [Collection::first(paths)*, fqName*, "module.sam"];
        ifIs { <> Io1::fileExists(moduleFile) }
            { return paths };

        <> [Collection::butFirst(paths)]
    };
};

# Loads a module at the given path, using the given module paths for
# subsequent module lookups.
fn loadPath(moduleDir, modulePaths) {
    def baseContext = Module0::getGlobals(
        Module0::moduleGet({name: ["core", "Globals"]}));

    # This `moduleUse` is bound in the load context.
    fn innerModuleUse(searchInfo, optPaths?) {
        def fullPaths = ifValue { <> optPaths* }
            { paths <> [paths*, modulePaths*] }
            { <> modulePaths };

        <> moduleUse(searchInfo, fullPaths)
    };

    def fullContext = { baseContext*, moduleUse: innerModuleUse };
    def result = Module0::load(fullContext, moduleDir);

    Module0::moduleDef(result);

    <> result
};


#
# Exported Definitions
#

# Documented in spec.
fn moduleUse(searchInfo, modulePaths?) {
    ifValue { <> Module0::moduleGet(searchInfo) }
        { modu -> return modu };

    def paths = ifValueOr { <> modulePaths* } { <> [] };

    ifValue { <> searchInfo::path }
        { path ->
            # The module is being specified as an explicit path. This
            # means that the path per se should be loaded, and it should
            # include its own `modules` at the head of the paths list.
            return loadPath(path, [[path*, "modules"], paths*])
        };

    def fqName = searchInfo::name;

    ifIs { <> eq(paths, []) }
        {
            Io1::die(cat(
                "Module not already loaded, and no `modulePaths` specified: ",
                Module0::stringFromModuleName(fqName)))
        };

    def remainingPaths = findModuleDirectory(searchInfo, paths);
    def moduleDir = [Collection::first(remainingPaths)*, fqName*];
    def result = loadPath(moduleDir, remainingPaths);
    def info = Module0::getInfo(result);

    # TODO: Currently ignores everything about `searchInfo` other than the name.
    ifIs { <> ne(fqName, info::name) }
        {
            Io1::die(cat(
                "Module name mismatch: ",
                Module0::stringFromModuleName(fqName)))
        };

    <> result
};

<> {
    # Re-exports from `core::Module0`.
    getAllModules:        Module0::getAllModules,
    getExports:           Module0::getExports,
    getGlobals:           Module0::getGlobals,
    getInfo:              Module0::getInfo,
    load:                 Module0::load,
    moduleDef:            Module0::moduleDef,
    moduleGet:            Module0::moduleGet,
    stringFromModuleName: Module0::stringFromModuleName,

    # Defined here.
    moduleUse:  moduleUse
}
