# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Command line interpreter
#

def Io1 = moduleUse({name: ["core", "Io1"]});
def Module = moduleUse({name: ["core", "Module"]});


#
# Private Definitions
#

# Parses a single `\0`-terminated word. Yields a simple string.
def parWord = {/
    chars = [! "\0"]*
    "\0"
    { <> Peg::stringFromTokenList(chars) }
/};

# Parses a key prefix of a word, not including the ending `=`.
def parKey = {/
    chars = [! "=\0"]+
    { <> Peg::stringFromTokenList(chars) }
/};

# Parses a key-value option word. Yields a single-mapping map of
# `[(key): value]`.
def parKeyValue = {/
    "--"
    key = parKey
    "="
    value = parWord
    { <> {(key): value} }
/};

# Parses a non-value flag option word. Yields a single-mapping map of
# `[(flag): true]`.
def parFlag = {/
    "--"
    flag = parWord
    { <> ne(flag, "") } # Reject plain `--`.
    { <> {(flag): true} }
/};

# Parses a syntactically invalid option. This includes words that start with
# just a single dash and are not *just* `-` (which is a valid non-option
# argument); as well as options with empty keys (`--=...`).
def parError = {/
    ch1 = "-"
    ch2 = [! "-\0"]
    word = parWord
    {
        def value = cat(stringFromTokens(ch1, ch2), word);
        Io1::note(cat("Unknown option: ", Format::source(value)));
        <> {error: true}
    }
/};

# Parses and yields an arbitrary option (including errors).
def parOption = {/
    parKeyValue | parFlag | parError
/};

# Parses the entire list of argument words. Yields a map of
# `[options: [k: v, ...], args: [arg, ...]]`.
def parArguments = {/
    optionList = parOption*
    "--\0"?
    args = parWord*
    {
        def options = cat({}, optionList*);
        ifIs { <> options::error }
            { Io1::die("Invalid option(s).") };
        <> {options: options, args: args}
    }
/};

# Runs a module-form command-line. In this case, a named directory is
# loaded as a module. It is expected to export a `main()` function, which
# is called with the Posix-style command-line arguments.
fn runModule(modulePath, args) {
    def loaded = Module::moduleUse({path: modulePath});

    <> ifValue { <> loaded::main }
        { main <> main(modulePath, args*) }
        { Io1::die("No `main` exported from primary module.") }
};

# Runs a simple-file-form command-line. In this case, the indicated file
# is read as a top-level program, and evaluated, passing it no arguments.
# Its environment includes `PATH` and `ARGUMENTS` variables indicating
# the path to the file and the command-line arguments, respectively.
fn runFile(langLayer, filePath, args) {
    def programText = Io1::readFileUtf8(filePath);
    def langModule = moduleUse({name: ["core", cat("Lang", langLayer)]});
    def parsedProgram = langModule::parseProgram(programText);

    def globals = {
        (Module::getExports(moduleUse({name: ["core", "Globals"]})))*,
        ARGUMENTS: args,
        PATH:      filePath
    };

    def evalled = langModule::eval(globals, parsedProgram);
    <> evalled()
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn parseArgs(args) {
    # Make a unified string with each argument "\0"-terminated.
    def argFilter = Generator::makeFilterGenerator(args)
        { arg <> cat(arg, "\0") };
    def argString = cat("", argFilter*);

    # Use the peg grammar above to split the arguments back apart.
    <> Peg::apply(parArguments, argString)
};

# Documented in Samizdat Layer 0 spec.
fn runCommandLine(rawArgs*) {
    def parsedArgs = parseArgs(rawArgs);
    def options = parsedArgs::options;
    def argWords = parsedArgs::args;

    def fileName = ifValueOr { <> Collection::first(argWords) }
        { <> "/dev/stdin" };
    def filePath = Io1::pathFromFlat(fileName);
    def args = ifValueOr { <> Collection::butFirst(argWords) }
        { <> [] };

    <> ifIs { <> Io1::fileExists([filePath*, "module.sam"]) }
        { <> runModule(filePath, args) }
        {
            def langLayer = ifValueOr { <> options::layer } { <> "2" };
            <> runFile(langLayer, filePath, args)
        }
};

<> {
    parseArgs,
    runCommandLine
}
