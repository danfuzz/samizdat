# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# PEG (Parsing Expression Grammar) support
#

def Box = moduleUse({name: ["core", "Box"]});


#
# Type Definitions
#

# `parse(peg, box, input, items*)`
def parse = makeRegularGeneric("parse", 3);

# Documented in Samizdat Layer 0 spec.
def any = @PegAny;

# Documented in Samizdat Layer 0 spec.
def empty = @[PegResult: null];

# Documented in Samizdat Layer 0 spec.
def eof = @PegEof;

# Documented in Samizdat Layer 0 spec.
def fail = @PegFail;

# Documented in Samizdat Layer 0 spec.
fn PegAny_parse(peg, box, input, .*) {
    <> Generator::nextValue(input, box)
};
genericBind(parse, "PegAny", PegAny_parse);

# Documented in Samizdat Layer 0 spec.
fn PegChoice_parse(peg, box, input, items*) {
    Generator::filterPump(dataOf(peg)) { rule ->
        def innerBox = Box::makeYieldBox();
        ifValue { <> parse(rule, innerBox, input, items*) }
            { newInput ->
                Box::store(box, Box::fetch(innerBox));
                return newInput
            }
    };

    # No rule succeeded.
    Box::store(box)
};
genericBind(parse, "PegChoice", PegChoice_parse);

# Documented in Samizdat Layer 0 spec.
fn PegCode_parse(peg, box, input, items*) {
    <> ifValue { <> dataOf(peg)(items*) }
        { result ->
            Box::store(box, result);
            <> input
        }
        { Box::store(box) };
};
genericBind(parse, "PegCode", PegCode_parse);

# Documented in Samizdat Layer 0 spec.
fn PegEof_parse(peg, box, input, .*) {
    <> ifIs { <> Generator::nextValue(input, Box::nullBox) }
        { Box::store(box) }
        {
            Box::store(box, null);
            <> input
        }
};
genericBind(parse, "PegEof", PegEof_parse);

# Documented in Samizdat Layer 0 spec.
fn PegFail_parse(peg, box, input, .*) {
    Box::store(box)
};
genericBind(parse, "PegFail", PegFail_parse);

# Documented in Samizdat Layer 0 spec.
fn PegLookaheadFailure_parse(peg, box, input, items*) {
    <> ifIs { <> parse(dataOf(peg), Box::nullBox, input, items*) }
        { Box::store(box) }
        {
            Box::store(box, null);
            <> input
        }
};
genericBind(parse, "PegLookaheadFailure", PegLookaheadFailure_parse);

# Documented in Samizdat Layer 0 spec.
fn PegLookaheadSuccess_parse(peg, box, input, items*) {
    <> ifIs { <> parse(dataOf(peg), box, input, items*) }
        { <> input }
};
genericBind(parse, "PegLookaheadSuccess", PegLookaheadSuccess_parse);

# Documented in Samizdat Layer 0 spec.
fn PegMain_parse(peg, box, input, .*) {
    # The point of this implementation is to drop the `items` context.
    <> parse(dataOf(peg), box, input)
};
genericBind(parse, "PegMain", PegMain_parse);

# Documented in Samizdat Layer 0 spec.
fn PegOpt_parse(peg, box, input, items*) {
    def innerBox = Box::makeYieldBox();
    <> ifValue { <> parse(dataOf(peg), innerBox, input, items*) }
        { newInput ->
            Box::store(box, [Box::fetch(innerBox)]);
            <> newInput
        }
        {
            Box::store(box, []);
            <> input
        }
};
genericBind(parse, "PegOpt", PegOpt_parse);

# Documented in Samizdat Layer 0 spec.
fn PegRepeat_parse(peg, box, input, items*) {
    def params = dataOf(peg);
    def rule = params::rule;

    loopReduce(input, [])
        { input, values ->
            def innerBox = Box::makeYieldBox();
            <> ifValue { <> parse(rule, innerBox, input, items*) }
                { newInput <> [newInput, [values*, Box::fetch(innerBox)]] }
                {
                    ifValue { <> params::minSize }
                        { minSize ->
                            ifIs { <> lt(Collection::sizeOf(values), minSize) }
                                {
                                    # Did not parse minimum required size.
                                    Box::store(box);
                                    return
                                }
                        };
                    Box::store(box, values);
                    return input
                }
        }
};
genericBind(parse, "PegRepeat", PegRepeat_parse);

# Documented in Samizdat Layer 0 spec.
fn PegResult_parse(peg, box, input, .*) {
    Box::store(box, dataOf(peg));
    <> input
};
genericBind(parse, "PegResult", PegResult_parse);

# Documented in Samizdat Layer 0 spec.
fn PegSequence_parse(peg, box, input, items*) {
    # Each rule after the first gets passed as additional arguments
    # the matched results of all the previous rules, in order.

    def reduction = Generator::doReduce(dataOf(peg), input, items)
        { rule, input, items ->
            def innerBox = Box::makeYieldBox();
            <> ifValue { <> parse(rule, innerBox, input, items*) }
                { newInput <> [newInput, [items*, Box::fetch(innerBox)]] }
                {
                    # Propagate the failure.
                    Box::store(box);
                    return
                }
        };

    def newInput = Collection::nth(reduction, 0);
    def results = Collection::nth(reduction, 1);
    Box::store(box, Collection::last(results));
    <> newInput
};
genericBind(parse, "PegSequence", PegSequence_parse);

# Documented in Samizdat Layer 0 spec.
fn PegTokenSet_parse(peg, box, input, items*) {
    def set = dataOf(peg);
    def innerBox = Box::makeYieldBox();

    ifValue { <> Generator::nextValue(input, innerBox) }
        { newInput ->
            def item = Box::fetch(innerBox);
            ifIs { <> get(set, typeOf(item)) }
                {
                    Box::store(box, item);
                    return newInput
                }
        };

    # Either EOF or no match.
    Box::store(box);
};
genericBind(parse, "PegTokenSet", PegTokenSet_parse);

# Documented in Samizdat Layer 0 spec.
fn PegTokenSetComplement_parse(peg, box, input, items*) {
    def set = dataOf(peg);
    def innerBox = Box::makeYieldBox();

    ifValue { <> Generator::nextValue(input, innerBox) }
        { newInput ->
            def item = Box::fetch(innerBox);
            ifNot { <> get(set, typeOf(item)) }
                {
                    Box::store(box, item);
                    return newInput
                }
        };

    # Either EOF or no match.
    Box::store(box);
};
genericBind(parse, "PegTokenSetComplement", PegTokenSetComplement_parse);


#
# Exported Definitions
#

# Private helper for `make*Set*`, which takes a `sense` argument and
# produces the desired rule.
fn genericMakeTokenSet(sense, types) {
    def set = {types*: true}; # A set-like map of all the token types.

    ifIs { <> eq(set, {}) }
        {
            # Trivial case: Empty set. Return an appropriate absolute rule.
            return ifIs { <> eq(sense, true) }
                { <> fail }
                { <> any }
        };

    <> ifIs { <> eq(sense, true) }
        { <> @[PegTokenSet: set] }
        { <> @[PegTokenSetComplement: set] }
};

# Documented in Samizdat Layer 0 spec.
fn makeResult(value) {
    <> @[PegResult: value]
};

# Documented in Samizdat Layer 0 spec.
fn makeCharSet(strings*) {
    # Make a combined string, passing it to the general token set constructor,
    # which then splays all the characters out as a set of map keys.
    <> genericMakeTokenSet(true, cat("", strings*))
};

# Documented in Samizdat Layer 0 spec.
fn makeCharSetComplement(strings*) {
    # See comment in `makeCharSet`.
    <> genericMakeTokenSet(false, cat("", strings*))
};

# Documented in Samizdat Layer 0 spec.
fn makeChoice(rules*) {
    # Trivial case: No rules. Return the failure rule.
    ifIs { <> eq(rules, []) }
        { return @PegFail };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(Collection::sizeOf(rules), 1) }
        { return rules* };

    # The general case.
    <> @[PegChoice: rules]
};

# Documented in Samizdat Layer 0 spec.
fn makeCode(function) {
    <> @[PegCode: function]
};

# Documented in Samizdat Layer 0 spec.
fn makeLookaheadFailure(rule) {
    # Optimiziation: Representation of `!.`.
    ifIs { <> eq(rule, @PegAny) }
        { return @PegEof };

    # Optimization: Representation of `!()`.
    ifIs { <> eq(rule, empty) }
        { return @PegFail };

    # The general case.
    <> @[PegLookaheadFailure: rule]
};

# Documented in Samizdat Layer 0 spec.
fn makeLookaheadSuccess(rule) {
    <> @[PegLookaheadSuccess: rule]
};

# Documented in Samizdat Layer 0 spec.
fn makeMainChoice(rules*) {
    <> @[PegMain: makeChoice(rules*)]
};

# Documented in Samizdat Layer 0 spec.
fn makeMainSequence(rules*) {
    <> @[PegMain: makeSequence(rules*)]
};

# Documented in Samizdat Layer 0 spec.
fn makeOpt(rule) {
    <> @[PegOpt: rule]
};

# Documented in Samizdat Layer 0 spec.
fn makePlus(rule) {
    <> @[PegRepeat: {rule: rule, minSize: 1}]
};

# Documented in Samizdat Layer 0 spec.
fn makeSequence(rules*) {
    # Trivial case: No rules. Return the empty rule.
    ifIs { <> eq(rules, []) }
        { return empty };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(Collection::sizeOf(rules), 1) }
        { return rules* };

    # The general case.
    <> @[PegSequence: rules]
};

# Documented in Samizdat Layer 0 spec.
fn makeStar(rule) {
    <> @[PegRepeat: {rule: rule}]
};

# Documented in Samizdat Layer 0 spec.
fn makeString(string) {
    # Trivial case: Empty string. Return an always-successful yield of `@""`.
    ifIs { <> eq(string, "") }
        { return @[PegResult: @""] };

    # Trivial case: One-char string. Return a simple one-char rule.
    ifIs { <> eq(Collection::sizeOf(string), 1) }
        { return makeToken(string) };

    # This is implemented as, in effect, `("1" "2" ... { <> string })`,
    # which allows us to minimize code duplication.

    # Make a list of rules per character.
    def chars = Generator::filter(string, makeToken);

    <> @[PegSequence: [chars*, @[PegResult: @[(string)]]]]
};

# Documented in Samizdat Layer 0 spec.
fn makeToken(type) {
    # This is just uses a single-item token set. The performance difference
    # between that and doing a more special-case single item type check is
    # probably negligible.
    <> @[PegTokenSet: {(type): null}];
};

# Documented in Samizdat Layer 0 spec.
fn makeTokenSet(tokens*) {
    <> genericMakeTokenSet(true, tokens)
};

# Documented in Samizdat Layer 0 spec.
fn makeTokenSetComplement(tokens*) {
    <> genericMakeTokenSet(false, tokens)
};


#
# Miscellaneous functions
#

# Documented in Samizdat Layer 0 spec.
fn apply(rule, input) {
    def box = Box::makeYieldBox();
    def generator = ifIs { <> isString(input) }
        {
            # This converts generated characters into tokens with the
            # characters as the type.
            <> Generator::makeFilterGenerator(makeValue, input)
        }
        { <> input };

    <> ifIs { <> parse(rule, box, generator) }
        { <> Box::fetch(box) }
};

# Documented in Samizdat Layer 0 spec.
fn stringFromTokenList(tokens) {
    <> cat("", Generator::filter(tokens, typeOf)*)
};


#
# Export mechanics
#

<> {
    any:                    any,
    apply:                  apply,
    empty:                  empty,
    eof:                    eof,
    fail:                   fail,
    makeCharSet:            makeCharSet,
    makeCharSetComplement:  makeCharSetComplement,
    makeChoice:             makeChoice,
    makeCode:               makeCode,
    makeLookaheadFailure:   makeLookaheadFailure,
    makeLookaheadSuccess:   makeLookaheadSuccess,
    makeMainChoice:         makeMainChoice,
    makeMainSequence:       makeMainSequence,
    makeOpt:                makeOpt,
    makePlus:               makePlus,
    makeResult:             makeResult,
    makeSequence:           makeSequence,
    makeStar:               makeStar,
    makeString:             makeString,
    makeToken:              makeToken,
    makeTokenSet:           makeTokenSet,
    makeTokenSetComplement: makeTokenSetComplement,
    parse:                  parse,
    stringFromTokenList:    stringFromTokenList
}
