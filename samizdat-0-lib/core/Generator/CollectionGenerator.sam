# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `CollectionGenerator` Type
#
# Payload is `[collection: coll, index: int]`.

def Box = moduleGet({name: ["core", "Box"]});
def Generator = moduleGet({name: ["proto", "Generator"]});


#
# Exported Definitions
#

# Documented in spec.
fn makeCollectionGenerator(coll, optIndex?) {
    def indexMap = ifValue { <> optIndex* }
        { index <> {index: index} }
        { <> {} };

    <> @[CollectionGenerator: {collection: coll, indexMap*}]
};

# Documented in spec.
fn CollectionGenerator_nextValue(gen, box) {
    def data = dataOf(gen);
    def index = data::index;

    # This uses void contagion to fail the `Box::store` call when `index` is
    # out of range for the collection.
    <> ifIs { <> Box::store(box, &Collection::nth(data::collection, index)) }
        {
            <> @[CollectionGenerator:
                Collection::put(data, "index", Number::add(index, 1))]
        }
        {
            # Voided (out of elements).
            Box::store(box)
        }
};
genericBind(Generator::nextValue, "CollectionGenerator", CollectionGenerator_nextValue);

# `nextValue` binding for the core collection types.
fn Collection_nextValue(coll, box) {
    # Get the first element directly, and return a generator for the rest.
    <> ifIs { <> Box::store(box, &Collection::nth(coll, 0)) }
        { <> @[CollectionGenerator: {collection: coll, index: 1}] }
        {
            # `coll` is empty.
            Box::store(box)
        }
};
genericBind(Generator::nextValue, List,   Collection_nextValue);
genericBind(Generator::nextValue, Map,    Collection_nextValue);
genericBind(Generator::nextValue, String, Collection_nextValue);

<> {
    makeCollectionGenerator: makeCollectionGenerator
}
