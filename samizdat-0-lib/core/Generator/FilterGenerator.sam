# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `FilterGenerator` Type
#
# Payload is a map `[filterFunction: function, generator: subGen]`.
# `subGen` is expected to produce lists of arguments to apply.

def Generator = moduleUse({name: ["proto", "Generator"]});

def ParaGenerator = submoduleUse("ParaGenerator");


#
# Exported Definitions
#

# Documented in spec.
fn makeFilterGenerator(filterFunction, generators*) {
    <> @[FilterGenerator: {
        filterFunction: filterFunction,
        generator: ParaGenerator::makeParaGenerator(generators*)
    }]
};

# Documented in spec.
fn FilterGenerator_nextValue(gen, box) {
    def payload = dataOf(gen);
    def filterFunction = payload::filterFunction;

    # This loop handles the fact that the filter function is
    # allowed to yield void to indicate a generated value is to
    # be discarded.
    loopReduce(payload::generator) { <next> gen ->
        def innerBox = Box::makePromise();

        ifValue { <> Generator::nextValue(gen, innerBox) }
            { nextGenerator ->
                ifValue { <> filterFunction(Box::fetch(innerBox)*) }
                    { value ->
                        Box::store(box, value);
                        return @[FilterGenerator:
                            Collection::put(payload, "generator",
                                nextGenerator)
                        ]
                    }
                    {
                        # The filter discarded the value. Iterate!
                        <next> [nextGenerator]
                    }
            };

        # The inner generator was voided.
        Box::store(box);
        return
    }
};
genericBind(Generator::nextValue, "FilterGenerator",
    FilterGenerator_nextValue);

<> {
    makeFilterGenerator: makeFilterGenerator
}
