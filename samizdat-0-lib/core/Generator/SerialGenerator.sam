# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `SerialGenerator` Type
#
# Payload is `[subGens*]`, a list of sub-generators.

def Box = moduleUse({name: ["core", "Box"]});
def Generator = moduleUse({name: ["proto", "Generator"]});

def NullGenerator = submoduleUse("NullGenerator");


#
# Exported Definitions
#

# Documented in spec.
fn makeSerialGenerator(generators*) {
    # Return the `nullGenerator` if we weren't passed any arguments.
    ifIs { <> eq(generators, []) }
        { return NullGenerator::nullGenerator };

    # Return the argument directly if we were only passed one.
    # This saves some gratuitous call wrapping / double yields.
    ifIs { <> eq(Collection::sizeOf(generators), 1) }
        { return generators* };

    <> @[SerialGenerator: generators]
};

# Documented in spec.
fn SerialGenerator_nextValue(gen, box) {
    def subGens = dataOf(gen);

    <> ifValue { <> Collection::first(subGens) }
        { firstGen ->
            def moreGens = Collection::butFirst(subGens);
            def innerBox = Box::makePromise();

            <> ifValue { <> Generator::nextValue(firstGen, innerBox) }
                { nextGenerator ->
                    Box::store(box, Box::fetch(innerBox));
                    <> @[SerialGenerator: [nextGenerator, moreGens*]]
                }
                {
                    # First generator was voided.
                    <> Generator::nextValue(
                        makeSerialGenerator(moreGens*),
                        box)
                }
        }
        {
            # Totally voided.
            Box::store(box)
        }
};
genericBind(Generator::nextValue, "SerialGenerator", SerialGenerator_nextValue);

<> {
    makeSerialGenerator: makeSerialGenerator
}
