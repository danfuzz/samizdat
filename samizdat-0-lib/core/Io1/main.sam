# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Baseline I/O functions
#


def Box = moduleGet({name: ["core", "Box"]});
def Generator = moduleGet({name: ["core", "Generator"]});
def Io0 = moduleGet({name: ["core", "Io0"]});
def ParseForwarder = moduleGet({name: ["core", "ParseForwarder"]});
def Peg = moduleGet({name: ["core", "Peg"]});


#
# Private Definitions: `parPathString`
#

# Parses a single path component.
def parPathComponent = {/
    # Ignore duplicate slashes, but require at least one. Note: The parser
    # is only ever called on a string that begins with a slash.
    "/"+

    # Match the component text. This is a `*` and not a `+` rule, in order to
    # successfully match a string-final empty component (that is, a trailing
    # slash on the overall path string).
    component = [! "/"]*
    { <> stringFromTokenList(component) }
/};

# Parses a regular (non-up-directory) component. The `..` check ensures that
# `..` only gets parsed as part of a balanced `name/..` pair.
def parRegularComponent = {/
    component = parPathComponent
    {
        <> ifIs { <> ne(component, "..") }
            { <> [component] }
    }
/};

# Parses a matched set of components that are collectively ignored, e.g.
# `"/x/y/../.."` or `"/."`.
def parIgnoredComponent = ParseForwarder::make();
def implIgnoredComponent = {/
    component = parPathComponent

    (
        { <> eq(component, ".") }
    |
        parIgnoredComponent?
        dotdot = parPathComponent
        { <> eq(dotdot, "..") }
    )

    { <> [] }
/};
Box::store(parIgnoredComponent, implIgnoredComponent);

# Helper for `pathFromFlat` which parses absolute path strings
# into components. This canonicalizes the path by ignoring duplicate
# slashes, `.` components, and matched `name/..` pairs.
def parPathString = {/
    components = (parIgnoredComponent | parRegularComponent)+

    (
        .
        { <> "Invalid `..` component in path" }
    |
        { <> cat(components*) }
    )
/};


#
# Private Definitions: `parPathList`
#

# Parses a path within a path list.
def parOnePath = {/
    chars = [! ":"]+
    { <> stringFromTokenList(chars) }
/};

# Parses a flattened path list (e.g. the format for `MODULE_PATHS`) into
# a list of strings (for further parsing).
def parPathList = {/
    ":"*
    first = parOnePath
    rest = (
        ":"+
        parOnePath
    )*
    ":"*

    { <> [first, rest*] }
/};


#
# Private Definitions
#

# Helper for `flatFromPath` which validates a single path component.
# Yields an error string on invalid. Parsing fails for valid components.
def parErrorFromPathComponent = {/
    ".." !.
    { <> "Invalid `..` component in path." }
|
    "." !.
    { <> "Invalid `.` component in path." }
|
    !.
    { <> "Invalid empty component in path." }
|
    [! "/\0"]+
    (
        "/"
        { <> "Invalid `/` in path." }
    |
        "\0"
        { <> "Invalid `\\0` in path." }
    )
/};

# Checks whether the given alleged prefix is actually a prefix of the
# given path, or equal to it.
fn isPrefix(prefix, path) {
    def prefixSize = sizeOf(prefix);

    ifIs { <> gt(prefixSize, sizeOf(path)) }
        {
            # The "prefix" is longer than the path, so it can't actually be
            # a prefix.
            return
        };

    <> eq(prefix, slice(path, 0, prefixSize))
};

# Dies with the given message including the given path.
fn dieWith(msg, path) {
    Io0::die(cat(msg, ": ", Format::source(path)))
};

# Helper for `sandboxedReader` which does symbolic link resolution,
# respecting the sandbox directory.
fn resolveLinks(sandboxDirectory, path) {
    loopReduce(path, 50) { path, limit ->
        ifIs { <> le(limit, 0) }
            { Io0::die("Too many links in symbolic link chain.") };
        ifNot { <> isPrefix(sandboxDirectory, path) }
            { Io0::die("Symbolic link escapes sandbox directory.") };

        <> ifValue { <> readLink(path) }
            { newPath <> [newPath, sub(limit, 1)] }
            { return path }
    }
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn fileExists(path) {
    <> ifIs { <> Io0::flatFileExists(flatFromPath(path)) }
        { <> path }
};

# Documented in Samizdat Layer 0 spec.
fn flatFromPath(path) {
    ifIs { <> eq(path, []) }
        { dieWith("Invalid empty path", path) };

    def gen =
        Generator::makeFilterGenerator(path, makeOpenRange(sizeOf(path), -1))
        { <out> one, n ->
            # This test skips the check on the last path component, if it
            # happens to be empty (which is the only valid case of an empty
            # path component).
            ifIs { <> eq([one, n], ["", 1]) }
                { <out> "/" }
                {
                    ifValue { <> Peg::apply(parErrorFromPathComponent, one) }
                        { error -> dieWith(error, path) }
                };
            <> cat("/", one)
        };

    <> cat(gen*)
};

# Documented in Samizdat Layer 0 spec.
fn pathFromFlat(string) {
    # Reject the empty string.
    ifIs { <> eq(string, "") }
        { dieWith("Invalid path", "") };

    # Prepend the current directory if the path isn't absolute.
    def absoluteString = ifIs { <> eq(nth(string, 0), "/") }
        { <> string }
        { <> cat(Io0::flatCwd(), "/", string) };

    # Parse the string into components (or an error string).
    def components = Peg::apply(parPathString, absoluteString);

    ifIs { <> isString(components) }
        { dieWith(components, string) };

    <> components
};

# Documented in Samizdat Layer 0 spec.
fn pathListFromFlat(string) {
    # Parse the given string into a list of flat paths.
    def flats = Peg::apply(parPathList, string);

    # Call `pathFromFlat` on each element.
    <> Generator::filterAll(pathFromFlat, flats)
};

# Documented in Samizdat Layer 0 spec.
fn readFileUtf8(path) {
    <> Io0::flatReadFileUtf8(flatFromPath(path))
};

# Documented in Samizdat Layer 0 spec.
fn readLink(path) {
    <> ifValue { <> Io0::flatReadLink(flatFromPath(path)) }
        { newPath <> pathFromFlat(newPath) }
};

# Documented in Samizdat Layer 0 spec.
fn sandboxedReader(directory) {
    <> { path ->
        def fullPath = resolveLinks(directory, [directory*, path*]);
        <> readFileUtf8(fullPath);
    }
};

# Documented in Samizdat Layer 0 spec.
fn writeFileUtf8(path, text) {
    <> Io0::flatWriteFileUtf8(flatFromPath(path), text)
};

<> {
    # Re-exported from Io0.
    die:               Io0::die,
    note:              Io0::note,

    # Defined in this file.
    fileExists:        fileExists,
    flatFromPath:      flatFromPath,
    pathFromFlat:      pathFromFlat,
    pathListFromFlat:  pathListFromFlat,
    readFileUtf8:      readFileUtf8,
    readLink:          readLink,
    sandboxedReader:   sandboxedReader,
    writeFileUtf8:     writeFileUtf8
}
