# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operators
#



#
# Helper definitions
#

# Verifies that it should be possible to compare the two given values,
# terminating the runtime if not.
assertComparable = { v1 v2 ::
    type1 = lowType(v1);
    type2 = lowType(v2);

    ifTrue { <> ne(type1, type2)}
        { io0Die(format("Incomparable values: %q, %q"), v1, v2); };

    ifTrue { <> eq(type1, "token") }
        {
            tok1 = tokenType(v1);
            tok2 = tokenType(v2);
            ifTrue { <> ne(tok1, tok2)}
                { io0Die(format("Incomparable values: %q, %q"), v1, v2); };
        };
};


#
# Exported functions
#

# TODO: Documented in Samizdat Layer 2 spec.
\"binary==" = { v1 v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> eq(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary!=" = { v1 v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ne(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary<" = { v1 v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> lt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary>" = { v1 v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> gt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary<=" = { v1 v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> le(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary>=" = { v1 v2 ::
    assertComparable(v1, v2);

    # TODO: Needs to do special things for some token types (e.g. floats).
    <> ge(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.==." = { v1 v2 ::
    <> eq(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.!=." = { v1 v2 ::
    <> ne(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.<." = { v1 v2 ::
    <> lt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.>." = { v1 v2 ::
    <> gt(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.<=." = { v1 v2 ::
    <> le(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.>=." = { v1 v2 ::
    <> ge(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary+" = { v1 v2 ::
    <> iadd(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary-" = { v1 v2 ::
    <> isub(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary*" = { v1 v2 ::
    <> imul(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary/" = { v1 v2 ::
    <> idiv(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary%" = { v1 v2 ::
    <> irem(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.and." = { v1 v2 ::
    <> iand(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.eqv." = { v1 v2 ::
    <> inot(ixor(v1, v2))
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.nand." = { v1 v2 ::
    <> inot(iand(v1, v2))
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.nor." = { v1 v2 ::
    <> inot(ior(v1, v2))
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.or." = { v1 v2 ::
    <> ior(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.shl." = { v1 v2 ::
    <> ishl(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.shr." = { v1 v2 ::
    <> ishr(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
\"binary.xor." = { v1 v2 ::
    <> ixor(v1, v2)
};

# TODO: Documented in Samizdat Layer 2 spec.
compareChain = { functions values* ::
    # TODO: Implement this.
    io0Note(format("=== compare %q %q", functions, values));
    <> false;
};

<> [
    "binary+"      = \"binary+",
    "binary-"      = \"binary-",
    "binary*"      = \"binary*",
    "binary/"      = \"binary/",
    "binary%"      = \"binary%",
    "binary=="     = \"binary==",
    "binary!="     = \"binary!=",
    "binary<"      = \"binary<",
    "binary>"      = \"binary>",
    "binary<="     = \"binary<=",
    "binary>="     = \"binary>=",
    "binary.==."   = \"binary.==.",
    "binary.!=."   = \"binary.!=.",
    "binary.<."    = \"binary.<.",
    "binary.>."    = \"binary.>.",
    "binary.<=."   = \"binary.<=.",
    "binary.>=."   = \"binary.>=.",
    "binary.and."  = \"binary.and.",
    "binary.eqv."  = \"binary.eqv.",
    "binary.nand." = \"binary.nand.",
    "binary.nor."  = \"binary.nor.",
    "binary.or."   = \"binary.or.",
    "binary.shl."  = \"binary.shl.",
    "binary.shr."  = \"binary.shr.",
    "binary.xor."  = \"binary.xor.",
    "compareChain" = compareChain
]
