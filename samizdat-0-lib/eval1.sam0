# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 Evaluation
#


#
# Helper functions
#

# Forward declaration of `convertExpression` and `convertPex`.
convertExpression = forwardFunction();
convertPex = forwardFunction();

# Does parser conversion of an expression or statement list.
convertList = { nodes ::
    <> listMap(nodes) { ., node :: <> convertExpression(node) }
};

# Constructs a function call.
makeCall = { function, args* ::
    <> @["call": ["function": function, "actuals": args]]
};

# Constructs a named function call with the given arguments, each of
# which must be a (non-parsing) expression node.
callNameWithExpressions = { functionName, args* ::
    <> makeCall(@["varRef": functionName], args*);
};

# Converts a pex to a named function call of the converted inner pex.
callNameWithPex = { node, formals, functionName ::
    convertedNode = convertPex(tokenValue(node), formals);
    <> callNameWithExpressions(functionName, convertedNode)
};

# Constructs a named function call of the given literal arguments.
callNameWithLiterals = { functionName, args* ::
    literalArgs = listMap(args) { ., arg :: <> @["literal": arg] };
    <> callNameWithExpressions(functionName, literalArgs*)
};

# Converts a `choice` pex node.
convertPexChoice = { node, formals ::
    pexes = tokenValue(node);
    convertedPexes = listMap(pexes) { ., pex  :: <> convertPex(pex, formals) };
    <> callNameWithExpressions("pegMakeChoice", convertedPexes*)
};

# Converts a `sequence` pex node.
convertPexSequence = { node, formals ::
    pexes = tokenValue(node);

    # Extract the formals out of any `varDef` nodes.
    newFormals = listMap(pexes) { ., pex ::
        <> ifTrue { <> eq(tokenType(pex), "varDef") }
            { <> ["name": mapGet(tokenValue(pex), "name")] }
            { <> [:] }
    };

    # Convert all the pexes, passing in appropriately-extended formals
    # lists to each conversion.
    convertedPexes = listMap(pexes) { n, pex  ::
        subPex = ifTrue { <> eq(tokenType(pex), "varDef") }
            { <> mapGet(tokenValue(pex), "value") }
            { <> pex };
        <> convertPex(subPex, [formals*, listSlice(newFormals, 0, n)*])
    };

    <> callNameWithExpressions("pegMakeSequence", convertedPexes*)
};

# Converts a `string` pex node.
convertPexString = { node, formals ::
    <> callNameWithLiterals("pegMakeString", tokenValue(node))
};

# Converts a `token` pex node.
convertPexToken = { node, formals ::
    <> callNameWithLiterals("pegMakeToken", tokenValue(node))
};

# Converts a `varRef` pex node.
convertPexVarRef = { node, formals ::
    # `varRef` in the context of a pex just translates to the same `varRef`
    # in the context of an expression / statement.
    <> node
};

# Converts a `.` pex node.
convertPexDot = { node, formals ::
    <> @["varRef": "pegRuleAny"]
};

# Converts an `()` pex node.
convertPexEmpty = { node, formals ::
    <> @["varRef": "pegRuleEmpty"]
};

# Converts a `[]` pex node.
convertPexSet = { node, formals ::
    <> callNameWithLiterals("pegMakeTokenSet", tokenValue(node)*)
};

# Converts a `[!]` pex node.
convertPexSetComplement = { node, formals ::
    <> callNameWithLiterals("pegMakeTokenSetComplement", tokenValue(node)*);
};

# Converts a `{}` pex node.
convertPexCode = { node, formals ::
    # Use the lexical `formals` context to make a regular closure node,
    # and just convert that.

    closurePayload = [tokenValue(node)*, "formals": formals];
    convertedClosure = convertExpression(@["closure": closurePayload]);

    <> callNameWithExpressions("pegMakeCode", convertedClosure)
};

# Converts a `&&` pex node.
convertPexPredicate = { node, formals ::
    # This wraps the predicate in code, along these lines:
    #     `{ <> ifTrue { <> PREDICATE_CODE } { <> null } }`
    # Having done that, this calls `convertPexCode` (immediately above)
    # to perform the rest of the conversion.

    predicate = tokenValue(node);
    predicateThunk = @["closure": ["statements": [], "yield": predicate]];
    nullThunk = @["closure": [
        "statements": [],
        "yield": callNameWithLiterals("makeToken", "null")
    ]];
    yield = callNameWithExpressions("ifTrue", predicateThunk, nullThunk);
    codeNode = @["{}": ["statements": [], "yield": yield]];

    <> convertPexCode(codeNode, formals)
};

# Converts a `&` pex node.
convertPexLookaheadSuccess = { node, formals ::
    <> callNameWithPex(node, formals, "pegMakeLookaheadSuccess")
};

# Converts a `!` pex node.
convertPexLookaheadFailure = { node, formals ::
    <> callNameWithPex(node, formals, "pegMakeLookaheadFailure")
};

# Converts a `?` pex node.
convertPexOpt = { node, formals ::
    <> callNameWithPex(node, formals, "pegMakeOpt")
};

# Converts a `*` pex node.
convertPexStar = { node, formals ::
    <> callNameWithPex(node, formals, "pegMakeStar")
};

# Converts a `+` pex node.
convertPexPlus = { node, formals ::
    <> callNameWithPex(node, formals, "pegMakePlus")
};

# Map of types to parsing expression node converters.
CONVERT_PEX_MAP = [
    "choice":   convertPexChoice,
    "sequence": convertPexSequence,
    "string":   convertPexString,
    "token":    convertPexToken,
    "varRef":   convertPexVarRef,
    ".":        convertPexDot,
    "()":       convertPexEmpty,
    "[]":       convertPexSet,
    "[!]":      convertPexSetComplement,
    "{}":       convertPexCode,
    "&&":       convertPexPredicate,
    "&":        convertPexLookaheadSuccess,
    "!":        convertPexLookaheadFailure,
    "?":        convertPexOpt,
    "*":        convertPexStar,
    "+":        convertPexPlus
];

# Dispatches to an appropriate parser node converter. `formals` is the
# list of lexically bound result names, in order, in the form of `formals`
# values as defined by the Samizdat Layer 0 tree semanics spec.
convertPexImpl = { node, formals ::
    <> mapGet(CONVERT_PEX_MAP, tokenType(node))(node, formals)
};
convertPex(convertPexImpl);

# Does parser conversion of a `parser` node. This is where the juicy stuff
# happens!
convertParser = { node ::
    <> callNameWithPex(node, [], "pegMakeMainSequence")
};

# Does parser conversion of a `call` node.
convertCall = { node ::
    nodeValue = tokenValue(node);
    function = convertExpression(mapGet(nodeValue, "function"));
    actuals = convertList(mapGet(nodeValue, "actuals"));

    <> @["call": [nodeValue*, "function": function, "actuals": actuals]]
};

# Does parser conversion of a `closure` or `fnDef` node.
convertClosureLike = { node ::
    nodeType = tokenType(node);
    nodeValue = tokenValue(node);
    statements = convertList(mapGet(nodeValue, "statements"));
    yield = ifValue { <> mapGet(nodeValue, "yield") }
        { yield :: <> ["yield": convertExpression(yield)] }
        { <> [:] };

    <> @[nodeType: [nodeValue*, yield*, "statements": statements]]
};

# Does parser conversion of an `interpolate` node.
convertInterpolate = { node ::
    value = convertExpression(tokenValue(node));

    <> @["interpolate": value];
};

# Does parser conversion of a `varDef` node.
convertVarDef = { node ::
    nodeValue = tokenValue(node);
    value = convertExpression(mapGet(nodeValue, "value"));

    <> @["varDef": [nodeValue*, "value": value]]
};

# Does no-op node conversion.
convertNop = { node :: <> node };

# Map of types to expression/statement node converters.
CONVERT_EXPRESSION_MAP = [
    "call":        convertCall,
    "closure":     convertClosureLike,
    "fnDef":       convertClosureLike,
    "interpolate": convertInterpolate,
    "literal":     convertNop,
    "parser":      convertParser,
    "varDef":      convertVarDef,
    "varRef":      convertNop
];

# Iterates / visits the given expression or statement node, transforming
# parser subtrees into layer 0 function nodes.
convertExpressionImpl = { node ::
    <> mapGet(CONVERT_EXPRESSION_MAP, tokenType(node))(node)
};
convertExpression(convertExpressionImpl);


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
sam1Eval = { context, expressionNode ::
    convertedNode = convertExpression(expressionNode);
    <> sam0Eval(context, convertedNode)
};

<> [
    "sam1Eval": sam1Eval
]
