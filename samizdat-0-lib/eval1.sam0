# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 Evaluation
#


#
# Helper functions
#

# Forward declaration of `convertExpression` and `convertPex`.
convertExpression = forwardFunction();
convertPex = forwardFunction();

# Does parser conversion of an expression or statement list.
convertList = { nodes ::
    <> listMap nodes { . node :: <> convertExpression node }
};

# Constructs a named function call with the given arguments, each of
# which must be a (non-parsing) expression node.
callNameWithExpressions = { functionName args* ::
    <> @["call" ["function"=@["varRef" functionName] "actuals"=args]]
};

# Converts a pex to a named function call of the converted inner pex.
callNameWithPex = { node formals functionName ::
    convertedNode = convertPex (tokenValue node) formals;
    <> callNameWithExpressions functionName convertedNode
};

# Converts a pex to a named function call of the given literal arguments.
callNameWithLiterals = { functionName args* ::
    literalArgs = listMap args { . arg :: <> @["literal" arg] };
    <> apply callNameWithExpressions functionName literalArgs
};

# Converts a `choice` pex node.
convertPexChoice = { node formals ::
    pexes = tokenValue node;
    convertedPexes = listMap pexes { . pex  :: <> convertPex pex formals };
    <> apply callNameWithExpressions "pegMakeChoice" convertedPexes
};

# Converts a `sequence` pex node.
convertPexSequence = { node formals ::
    pexes = tokenValue node;

    # Extract the formals out of any `varDef` nodes.
    newFormals = listMap pexes { . pex ::
        <> ifTrue { <> eq (tokenType pex) "varDef" }
            { <> ["name" = (mapGet (tokenValue pex) "name")] }
            { <> [=] }
    };

    # Convert all the pexes, passing in appropriately-extended formals
    # lists to each conversion.
    convertedPexes = listMap pexes { n pex  ::
        subPex = ifTrue { <> eq (tokenType pex) "varDef" }
            { <> mapGet (tokenValue pex) "value" }
            { <> pex };
        <> convertPex subPex (listAdd formals (listSlice newFormals 0 n))
    };

    <> apply callNameWithExpressions "pegMakeSequence" convertedPexes
};

# Converts a `string` pex node.
convertPexString = { node formals ::
    <> callNameWithLiterals "pegMakeString" (tokenValue node)
};

# Converts a `token` pex node.
convertPexToken = { node formals ::
    <> callNameWithLiterals "pegMakeToken" (tokenValue node)
};

# Converts a `varRef` pex node.
convertPexVarRef = { node formals ::
    # `varRef` in the context of a pex just translates to the same `varRef`
    # in the context of an expression / statement.
    <> node
};

# Converts a `.` pex node.
convertPexDot = { node formals ::
    <> @["varRef" "pegRuleAny"]
};

# Converts an `()` pex node.
convertPexEmpty = { node formals ::
    <> @["varRef" "pegRuleEmpty"]
};

# Converts a `[]` pex node.
convertPexSet = { node formals ::
    <> apply callNameWithLiterals "pegMakeTokenSet" (tokenValue node)
};

# Converts a `[!]` pex node.
convertPexSetComplement = { node formals ::
    <> apply callNameWithLiterals "pegMakeTokenSetComplement" (tokenValue node)
};

# Converts a `{}` pex node.
convertPexCode = { node formals ::
    # Use the lexical `formals` context to make a regular function node,
    # and just convert that.
    functionPayload = mapPut (tokenValue node) "formals" formals;
    convertedFunction = convertExpression @["function" functionPayload];
    <> callNameWithExpressions "pegMakeCode" convertedFunction
};

# Converts a `&` pex node.
convertPexLookaheadSuccess = { node formals ::
    <> callNameWithPex node formals "pegMakeLookaheadSuccess"
};

# Converts a `!` pex node.
convertPexLookaheadFailure = { node formals ::
    <> callNameWithPex node formals "pegMakeLookaheadFailure"
};

# Converts a `?` pex node.
convertPexOpt = { node formals ::
    <> callNameWithPex node formals "pegMakeOpt"
};

# Converts a `*` pex node.
convertPexStar = { node formals ::
    <> callNameWithPex node formals "pegMakeStar"
};

# Converts a `+` pex node.
convertPexPlus = { node formals ::
    <> callNameWithPex node formals "pegMakePlus"
};

# Map of types to parsing expression node converters.
CONVERT_PEX_MAP = [
    "choice"   = convertPexChoice
    "sequence" = convertPexSequence
    "string"   = convertPexString
    "token"    = convertPexToken
    "varRef"   = convertPexVarRef
    "."        = convertPexDot
    "()"       = convertPexEmpty
    "[]"       = convertPexSet
    "[!]"      = convertPexSetComplement
    "{}"       = convertPexCode
    "&"        = convertPexLookaheadSuccess
    "!"        = convertPexLookaheadFailure
    "?"        = convertPexOpt
    "*"        = convertPexStar
    "+"        = convertPexPlus
];

# Dispatches to an appropriate parser node converter. `formals` is the
# list of lexically bound result names, in order, in the form of `formals`
# values as defined by the Samizdat Layer 0 tree semanics spec.
convertPexImpl = { node formals ::
    <> (mapGet CONVERT_PEX_MAP (tokenType node)) node formals
};
convertPex convertPexImpl;

# Does parser conversion of a `parser` node. This is where the juicy stuff
# happens!
convertParser = { node ::
    <> callNameWithPex node [] "pegMakeMainSequence"
};

# Does parser conversion of a `call` node.
convertCall = { node ::
    nodeValue = tokenValue node;
    function = convertExpression (mapGet nodeValue "function");
    actuals = convertList (mapGet nodeValue "actuals");

    <> @["call" (mapAdd nodeValue ["function"=function "actuals"=actuals])]
};

# Does parser conversion of a `function` node.
convertFunction = { node ::
    nodeValue = tokenValue node;
    statements = convertList (mapGet nodeValue "statements");
    yield = ifValue { <> mapGet nodeValue "yield" }
        { yield :: <> ["yield" = (convertExpression yield)] }
        { <> [=] };

    <> @["function" (mapAdd nodeValue ["statements" = statements] yield)]
};

# Does parser conversion of a `varDef` node.
convertVarDef = { node ::
    nodeValue = tokenValue node;
    value = convertExpression (mapGet nodeValue "value");

    <> @["varDef" (mapPut nodeValue "value" value)]
};

# Does no-op node conversion.
convertNop = { node :: <> node };

# Map of types to expression node converters.
CONVERT_EXPRESSION_MAP = [
    "call"     = convertCall
    "function" = convertFunction
    "literal"  = convertNop
    "parser"   = convertParser
    "varDef"   = convertVarDef
    "varRef"   = convertNop
];

# Iterates / visits the given expression or statement node, transforming
# parser subtrees into layer 0 function nodes.
convertExpressionImpl = { node ::
    <> (mapGet CONVERT_EXPRESSION_MAP (tokenType node)) node
};
convertExpression convertExpressionImpl;


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
sam1Eval = { context expressionNode ::
    convertedNode = convertExpression expressionNode;
    <> sam0Eval context convertedNode
};

<> [
    "sam1Eval" = sam1Eval
]
