# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 Evaluation
#

# Forward declaration of `convertExpression` and `convertPex`.
convertExpression = forwardFunction();
convertPex = forwardFunction();

# Does parser conversion of an expression or statement list.
convertList = { nodes ::
    <> listMap nodes { . node :: <> convertExpression node };
};

convertTODO = { node ::
    io0Die "TODO";
};

# Map of types to parsing expression node converters.
CONVERT_PEX_MAP = [
    "string" = convertTODO
    "token" = convertTODO
    "." = convertTODO
    "()" = convertTODO
    "varDef" = convertTODO
    "varRef" = convertTODO
];

# Dispatches to an appropriate parser node converter.
convertPexImpl = { node ::
    <> (mapGet CONVERT_PEX_MAP (tokenType node)) node;
};
convertPex convertPexImpl;

# Does parser conversion of a `parser` node. This is where the juicy stuff
# happens!
convertParser = { node ::
    <> convertPex (nodeValue node);
};

# Does parser conversion of a `call` node.
convertCall = { node ::
    nodeValue = tokenValue node;
    function = convertExpression (mapGet nodeValue "function");
    actuals = convertList (mapGet nodeValue "actuals");

    <> @["call" (mapAdd nodeValue ["function"=function "actuals"=actuals])]
};

# Does parser conversion of a `function` node.
convertFunction = { node ::
    nodeValue = tokenValue node;
    statements = convertList (mapGet nodeValue "statements");
    yield = ifValue { <> mapGet nodeValue "yield" }
        { yield :: <> ["yield" = (convertExpression yield)] }
        { <> [=] };

    <> @["function" (mapAdd nodeValue ["statements" = statements] yield)];
};

# Does parser conversion of a `varDef` node.
convertVarDef = { node ::
    nodeValue = tokenValue node;
    value = convertExpression (mapGet nodeValue "value");

    <> @["varDef" (mapPut nodeValue "value" value)];
};

# Does no-op node conversion.
convertNop = { node :: <> node };

# Map of types to expression node converters.
CONVERT_EXPRESSION_MAP = [
    "call" = convertCall
    "function" = convertFunction
    "literal" = convertNop
    "parser" = convertParser
    "varDef" = convertVarDef
    "varRef" = convertNop
];

# Iterates / visits the given expression or statement node, transforming
# parser subtrees into layer 0 function nodes.
convertExpressionImpl = { node ::
    <> (mapGet CONVERT_EXPRESSION_MAP (tokenType node)) node;
};
convertExpression convertExpressionImpl;


#
# Exported functions
#

# Documented in Samizdat Layer 0 spec.
sam1Eval = { context expressionNode ::
    convertedNode = convertExpression expressionNode;
    <> sam0Eval context convertedNode
};

<> [
    "sam1Eval" = sam1Eval
]
