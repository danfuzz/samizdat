# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 Evaluation
#


#
# Private Definitions
#

# The old binding for `samEval`.
def subEval = samEval;

# `convertPex(node, formals)`, used to expand pex nodes into expression
# nodes.
def convertPex = makeRegularGeneric("convertPex", 2, 2);

# `convertPexIn(node)`, used to convert a layer 1 expression or statement
# node into an equivalent layer 0 node.
def convertPexIn = makeRegularGeneric("convertPexIn", 1, 1);

# Reference to the variable `get`.
def GET_REF = @[varRef: "get"];

# Reference to the variable `Peg`.
def PEG_REF = @[varRef: "Peg"];

# Does parser conversion of an expression or statement list.
fn convertPexInList(nodes) {
    <> Generator::filterAll(nodes) { node <> convertPexIn(node) }
};

# Constructs a function call.
fn makeCall(function, args*) {
    <> @[call: {function: function, actuals: args}]
};

# Makes a peg variable reference.
fn makePegRef(name) {
    <> makeCall(GET_REF, PEG_REF, @[literal: name])
};

# Constructs a named peg function call with the given arguments, each of
# which must be a (non-parsing) expression node.
fn callPegNameWithExpressions(functionName, args*) {
    <> makeCall(makePegRef(functionName), args*);
};

# Converts a pex to a named peg function call of the converted inner pex.
fn callPegNameWithPex(node, formals, functionName) {
    def convertedNode = convertPex(dataOf(node), formals);
    <> callPegNameWithExpressions(functionName, convertedNode)
};

# Constructs a named peg function call of the given literal arguments.
fn callPegNameWithLiterals(functionName, args*) {
    def literalArgs = Generator::filterAll(args) { arg <> @[literal: arg] };
    <> callPegNameWithExpressions(functionName, literalArgs*)
};


#
# `convertPex` bindings
#

# Converts a `choice` pex node.
fn choice_convertPex(node, formals) {
    def pexes = dataOf(node);
    def convertedPexes = Generator::filterAll(pexes)
        { pex <> convertPex(pex, formals) };
    <> callPegNameWithExpressions("makeChoice", convertedPexes*)
};
genericBind(convertPex, "choice", choice_convertPex);

# Converts a `sequence` pex node.
fn sequence_convertPex(node, formals) {
    def pexes = dataOf(node);

    # Extract the formals out of any `varDef` nodes.
    def newFormals = Generator::filterAll(pexes) { pex ->
        <> ifIs { <> eq(typeOf(pex), "varDef") }
            { <> {name: dataOf(pex)::name} }
            { <> {} }
    };

    # Convert all the pexes, passing in appropriately-extended formals
    # lists to each conversion.
    def convertedPexes = Generator::filterAll(Range::makeOpenRange(0, 1), pexes)
        { n, pex ->
            def subPex = ifIs { <> eq(typeOf(pex), "varDef") }
                { <> dataOf(pex)::value }
                { <> pex };
            <> convertPex(subPex,
                [formals*, Collection::slice(newFormals, 0, n)*])
        };

    <> callPegNameWithExpressions("makeSequence", convertedPexes*)
};
genericBind(convertPex, "sequence", sequence_convertPex);

# Converts a `string` pex node.
fn string_convertPex(node, formals) {
    <> callPegNameWithLiterals("makeString", dataOf(node))
};
genericBind(convertPex, "string", string_convertPex);

# Converts a `token` pex node.
fn token_convertPex(node, formals) {
    <> callPegNameWithLiterals("makeToken", dataOf(node))
};
genericBind(convertPex, "token", token_convertPex);

# Converts a `varRef` pex node.
fn varRef_convertPex(node, formals) {
    # `varRef` in the context of a pex just translates to the same `varRef`
    # in the context of an expression / statement.
    <> node
};
genericBind(convertPex, "varRef", varRef_convertPex);

# Converts an `any` pex node.
fn any_convertPex(node, formals) {
    <> makePegRef("any")
};
genericBind(convertPex, "any", any_convertPex);

# Converts an `empty` pex node.
fn empty_convertPex(node, formals) {
    <> makePegRef("empty")
};
genericBind(convertPex, "empty", empty_convertPex);

# Converts a `tokenSet` pex node.
fn tokenSet_convertPex(node, formals) {
    <> callPegNameWithLiterals("makeTokenSet", dataOf(node)*)
};
genericBind(convertPex, "tokenSet", tokenSet_convertPex);

# Converts a `tokenSetComplement` pex node.
fn tokenSetComplement_convertPex(node, formals) {
    <> callPegNameWithLiterals("makeTokenSetComplement", dataOf(node)*);
};
genericBind(convertPex, "tokenSetComplement", tokenSetComplement_convertPex);

# Converts a `code` pex node.
fn code_convertPex(node, formals) {
    # Use the lexical `formals` context to make a regular closure node,
    # and just convert that.

    def closurePayload = {(dataOf(node))*, formals: formals};
    def convertedClosure = convertPexIn(@[closure: closurePayload]);

    <> callPegNameWithExpressions("makeCode", convertedClosure)
};
genericBind(convertPex, "code", code_convertPex);

# Converts a `lookaheadSuccess` pex node.
fn lookaheadSuccess_convertPex(node, formals) {
    <> callPegNameWithPex(node, formals, "makeLookaheadSuccess")
};
genericBind(convertPex, "lookaheadSuccess", lookaheadSuccess_convertPex);

# Converts a `lookaheadFailure` pex node.
fn lookaheadFailure_convertPex(node, formals) {
    <> callPegNameWithPex(node, formals, "makeLookaheadFailure")
};
genericBind(convertPex, "lookaheadFailure", lookaheadFailure_convertPex);

# Converts an `opt` pex node.
fn opt_convertPex(node, formals) {
    <> callPegNameWithPex(node, formals, "makeOpt")
};
genericBind(convertPex, "opt", opt_convertPex);

# Converts a `star` pex node.
fn star_convertPex(node, formals) {
    <> callPegNameWithPex(node, formals, "makeStar")
};
genericBind(convertPex, "star", star_convertPex);

# Converts a `plus` pex node.
fn plus_convertPex(node, formals) {
    <> callPegNameWithPex(node, formals, "makePlus")
};
genericBind(convertPex, "plus", plus_convertPex);


#
# `convertPexIn` bindings
#

# Does parser conversion of a `closure` or `fnDef` node.
fn convertClosureLike(node) {
    def nodeType = typeOf(node);
    def nodeValue = dataOf(node);
    def statements = convertPexInList(nodeValue::statements);
    def yield = ifValue { <> nodeValue::yield }
        { yield <> {yield: convertPexIn(yield)} }
        { <> {} };

    <> @[(nodeType): {nodeValue*, yield*, statements: statements}]
};

# Does parser conversion of a node whose payload value is an
# arbitrary expression. This includes `expression` (per se) and
# `interpolate` nodes.
fn convertExpressionPayload(node) {
    def nodeType = typeOf(node);
    def nodeValue = convertPexIn(dataOf(node));

    <> @[(nodeType): nodeValue]
};

# Does parser conversion of a `call` node.
fn call_convertPexIn(node) {
    def nodeValue = dataOf(node);
    def function = convertPexIn(nodeValue::function);
    def actuals = convertPexInList(nodeValue::actuals);

    <> @[call: {nodeValue*, function: function, actuals: actuals}]
};
genericBind(convertPexIn, "call", call_convertPexIn);

# Does parser conversion of a `closure` node.
fn closure_convertPexIn(node) {
    <> convertClosureLike(node)
};
genericBind(convertPexIn, "closure", closure_convertPexIn);

# Does parser conversion of an `expression` node.
fn expression_convertPexIn(node) {
    <> convertExpressionPayload(node)
};
genericBind(convertPexIn, "expression", expression_convertPexIn);

# Does parser conversion of a `fnDef` node.
fn fnDef_convertPexIn(node) {
    <> convertClosureLike(node)
};
genericBind(convertPexIn, "fnDef", fnDef_convertPexIn);

# Does parser conversion of an `interpolate` node.
fn interpolate_convertPexIn(node) {
    <> convertExpressionPayload(node)
};
genericBind(convertPexIn, "interpolate", interpolate_convertPexIn);

# Does parser conversion of a `literal` node.
fn literal_convertPexIn(node) {
    <> node
};
genericBind(convertPexIn, "literal", literal_convertPexIn);

# Does parser conversion of a `parser` node. This is where the juicy stuff
# happens!
fn parser_convertPexIn(node) {
    <> callPegNameWithPex(node, [], "makeMainSequence")
};
genericBind(convertPexIn, "parser", parser_convertPexIn);

# Does parser conversion of a `varDef` node.
fn varDef_convertPexIn(node) {
    def nodeValue = dataOf(node);
    def value = convertPexIn(nodeValue::value);

    <> @[varDef: {nodeValue*, value: value}]
};
genericBind(convertPexIn, "varDef", varDef_convertPexIn);

# Does parser conversion of a `varRef` node.
fn varRef_convertPexIn(node) {
    <> node
};
genericBind(convertPexIn, "varRef", varRef_convertPexIn);

# Does parser conversion of a `voidable` node.
fn voidable_convertPexIn(node) {
    <> convertExpressionPayload(node)
};
genericBind(convertPexIn, "voidable", voidable_convertPexIn);


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn samEval(context, expressionNode) {
    def convertedNode = convertPexIn(expressionNode);
    <> subEval(context, convertedNode)
};

<> {
    samEval: samEval
}
