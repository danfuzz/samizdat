# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 1 Evaluation
#


#
# Private Definitions
#

# Forward declaration of `convertExpression`.
def convertExpression = makeFunctionForwarder();

# `convertPex(node, formals)`, used to expand pex nodes into expression
# or statement nodes.
def convertPex = makeRegularGeneric("convertPex", 2, 2);

# Does parser conversion of an expression or statement list.
fn convertList(nodes) {
    <> filterAll(nodes) { node <> convertExpression(node) }
};

# Constructs a function call.
fn makeCall(function, args*) {
    <> @[call: [function: function, actuals: args]]
};

# Constructs a named function call with the given arguments, each of
# which must be a (non-parsing) expression node.
fn callNameWithExpressions(functionName, args*) {
    <> makeCall(@[varRef: functionName], args*);
};

# Converts a pex to a named function call of the converted inner pex.
fn callNameWithPex(node, formals, functionName) {
    def convertedNode = convertPex(dataOf(node), formals);
    <> callNameWithExpressions(functionName, convertedNode)
};

# Constructs a named function call of the given literal arguments.
fn callNameWithLiterals(functionName, args*) {
    def literalArgs = filterAll(args) { arg <> @[literal: arg] };
    <> callNameWithExpressions(functionName, literalArgs*)
};


#
# `convertPex` bindings
#

# Converts a `choice` pex node.
fn choice_convertPex(node, formals) {
    def pexes = dataOf(node);
    def convertedPexes = filterAll(pexes)
        { pex <> convertPex(pex, formals) };
    <> callNameWithExpressions("pegMakeChoice", convertedPexes*)
};
genericBind(convertPex, "choice", choice_convertPex);

# Converts a `sequence` pex node.
fn sequence_convertPex(node, formals) {
    def pexes = dataOf(node);

    # Extract the formals out of any `varDef` nodes.
    def newFormals = filterAll(pexes) { pex ::
        <> ifIs { <> eq(typeOf(pex), "varDef") }
            { <> [name: get(dataOf(pex), "name")] }
            { <> [:] }
    };

    # Convert all the pexes, passing in appropriately-extended formals
    # lists to each conversion.
    def convertedPexes = filterAll(makeOpenRange(0, 1), pexes) { n, pex  ::
        def subPex = ifIs { <> eq(typeOf(pex), "varDef") }
            { <> get(dataOf(pex), "value") }
            { <> pex };
        <> convertPex(subPex, [formals*, slice(newFormals, 0, n)*])
    };

    <> callNameWithExpressions("pegMakeSequence", convertedPexes*)
};
genericBind(convertPex, "sequence", sequence_convertPex);

# Converts a `string` pex node.
fn string_convertPex(node, formals) {
    <> callNameWithLiterals("pegMakeString", dataOf(node))
};
genericBind(convertPex, "string", string_convertPex);

# Converts a `token` pex node.
fn token_convertPex(node, formals) {
    <> callNameWithLiterals("pegMakeToken", dataOf(node))
};
genericBind(convertPex, "token", token_convertPex);

# Converts a `varRef` pex node.
fn varRef_convertPex(node, formals) {
    # `varRef` in the context of a pex just translates to the same `varRef`
    # in the context of an expression / statement.
    <> node
};
genericBind(convertPex, "varRef", varRef_convertPex);

# Converts a `.` pex node.
fn any_convertPex(node, formals) {
    <> @[varRef: "pegAny"]
};
genericBind(convertPex, ".", any_convertPex);

# Converts an `()` pex node.
fn empty_convertPex(node, formals) {
    <> @[varRef: "pegEmpty"]
};
genericBind(convertPex, "()", empty_convertPex);

# Converts a `[]` pex node.
fn set_convertPex(node, formals) {
    <> callNameWithLiterals("pegMakeTokenSet", dataOf(node)*)
};
genericBind(convertPex, "[]", set_convertPex);

# Converts a `[!]` pex node.
fn setComplement_convertPex(node, formals) {
    <> callNameWithLiterals("pegMakeTokenSetComplement", dataOf(node)*);
};
genericBind(convertPex, "[!]", setComplement_convertPex);

# Converts a `{}` pex node.
fn code_convertPex(node, formals) {
    # Use the lexical `formals` context to make a regular closure node,
    # and just convert that.

    def closurePayload = [(dataOf(node))*:, formals: formals];
    def convertedClosure = convertExpression(@[closure: closurePayload]);

    <> callNameWithExpressions("pegMakeCode", convertedClosure)
};
genericBind(convertPex, "{}", code_convertPex);

# Converts a `&` pex node.
fn lookaheadSuccess_convertPex(node, formals) {
    <> callNameWithPex(node, formals, "pegMakeLookaheadSuccess")
};
genericBind(convertPex, "&", lookaheadSuccess_convertPex);

# Converts a `!` pex node.
fn lookaheadFailure_convertPex(node, formals) {
    <> callNameWithPex(node, formals, "pegMakeLookaheadFailure")
};
genericBind(convertPex, "!", lookaheadFailure_convertPex);

# Converts a `?` pex node.
fn opt_convertPex(node, formals) {
    <> callNameWithPex(node, formals, "pegMakeOpt")
};
genericBind(convertPex, "?", opt_convertPex);

# Converts a `*` pex node.
fn star_convertPex(node, formals) {
    <> callNameWithPex(node, formals, "pegMakeStar")
};
genericBind(convertPex, "*", star_convertPex);

# Converts a `+` pex node.
fn plus_convertPex(node, formals) {
    <> callNameWithPex(node, formals, "pegMakePlus")
};
genericBind(convertPex, "+", plus_convertPex);


#
# Other Private Definitions
#

# Does parser conversion of a `parser` node. This is where the juicy stuff
# happens!
fn convertParser(node) {
    <> callNameWithPex(node, [], "pegMakeMainSequence")
};

# Does parser conversion of a `call` node.
fn convertCall(node) {
    def nodeValue = dataOf(node);
    def function = convertExpression(get(nodeValue, "function"));
    def actuals = convertList(get(nodeValue, "actuals"));

    <> @[call: [nodeValue*:, function: function, actuals: actuals]]
};

# Does parser conversion of a `closure` or `fnDef` node.
fn convertClosureLike(node) {
    def nodeType = typeOf(node);
    def nodeValue = dataOf(node);
    def statements = convertList(get(nodeValue, "statements"));
    def yield = ifValue { <> get(nodeValue, "yield") }
        { yield <> [yield: convertExpression(yield)] }
        { <> [:] };

    <> @[(nodeType): [nodeValue*:, yield*:, statements: statements]]
};

# Does parser conversion of a node whose payload value is an
# arbitrary expression. This includes `expression` (per se) and
# `interpolate` nodes.
fn convertExpressionPayload(node) {
    def nodeType = typeOf(node);
    def nodeValue = convertExpression(dataOf(node));

    <> @[(nodeType): nodeValue]
};

# Does parser conversion of a `varDef` node.
fn convertVarDef(node) {
    def nodeValue = dataOf(node);
    def value = convertExpression(get(nodeValue, "value"));

    <> @[varDef: [nodeValue*:, value: value]]
};

# Does no-op node conversion.
fn convertNop(node) { <> node };

# Map of types to expression/statement node converters.
def CONVERT_EXPRESSION_MAP = [
    call:        convertCall,
    closure:     convertClosureLike,
    expression:  convertExpressionPayload,
    fnDef:       convertClosureLike,
    interpolate: convertExpressionPayload,
    literal:     convertNop,
    parser:      convertParser,
    varDef:      convertVarDef,
    varRef:      convertNop,
    voidable:    convertExpressionPayload
];

# Iterates / visits the given expression or statement node, transforming
# parser subtrees into layer 0 function nodes.
fn convertExpressionImpl(node) {
    <> get(CONVERT_EXPRESSION_MAP, typeOf(node))(node)
};
store(convertExpression, convertExpressionImpl);


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn sam1Eval(context, expressionNode) {
    def convertedNode = convertExpression(expressionNode);
    <> sam0Eval(context, convertedNode)
};

<> [
    sam1Eval: sam1Eval
]
