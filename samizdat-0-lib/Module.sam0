# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#


#
# Private Definitions
#

# Box containing a map from fully-qualified names to modules. Each name is a
# list-of-strings denoting a "path" to the module.
def theModuleBox = makeMutableBox([:]);

# Box containing a set-like map of fully-qualified names representing
# modules in the middle of being loaded.
def thePendingBox = makeMutableBox([:]);


#
# Type Definition
#
# `Module` payload is `[info: map, exports: map]`. `info` includes at least
# `[name: [string, ...], version: string]`.

# Gets the `exports` of a module.
fn getExports(module) {
    <> get(dataOf(module), "exports")
};

# Gets the `info` of a module.
fn getInfo(module) {
    <> get(dataOf(module), "info")
};

# Returns a new module like the given one, except with `exports` as
# given.
fn withExports(module, newExports) {
    <> @[Module: [(dataOf(module))*:, exports: newExports]]
};

# TODO: Documented in spec.
fn Module_cat(module, more*) {
    def data = dataOf(module);

    def allExports = filterAll(getExports, [module, more*]);
    def combinedExports = cat([:], allExports*);

    <> withExports(module, combinedExports)
};
genericBind(cat, "Module", Module_cat);

# TODO: Documented in spec.
fn Module_del(module, key) {
    <> withExports(module, del(getExports(module), key))
};
genericBind(del, "Module", Module_del);

# TODO: Documented in spec.
fn Module_get(module, key) {
    <> get(getExports(module), key)
};
genericBind(get, "Module", Module_get);

# TODO: Documented in spec.
fn Module_keyList(module) {
    <> keyList(getExports(module))
};
genericBind(keyList, "Module", Module_keyList);

# TODO: Documented in spec.
fn Module_nameOf(module) {
    <> get(infoOf(module), "name")
};
genericBind(nameOf, "Module", Module_nameOf);

# TODO: Documented in spec.
fn Module_nth(module, n) {
    <> nth(getExports(module), n)
};
genericBind(nth, "Module", Module_nth);

# TODO: Documented in spec.
fn Module_put(module, key, value) {
    <> withExports(module, put(getExports(module), key, value))
};
genericBind(put, "Module", Module_put);

# TODO: Documented in spec.
fn Module_sizeOf(module) {
    <> sizeOf(getExports(module))
};
genericBind(sizeOf, "Module", Module_sizeOf);

# TODO: Documented in spec.
fn Module_slice(module, start, end?) {
    <> withExports(module, slice(getExports(module), start, end*))
};
genericBind(slice, "Module", Module_slice);



#
# Exported Definitions
#

# TODO: Documented in spec. (Define a previously-undefined module.)
fn moduleDef(module) {
    def name = nameOf(module);

    ifIs { <> moduleGet(name) }
        { io0Die(cat("Cannot redefine module: "), sourceString(name)) };

    def mods = fetch(theModuleBox);
    store(theModuleBox, put(mods, name, module));

    <> module
};

# TODO: Documented in spec. (Get a previously-defined module.)
fn moduleGet(name) {
    def mods = fetch(theModuleBox);
    <> get(mods, name)
};

# TODO: Documented in spec. (Get a module, first reading it from storage and
# initializing it if necessary.)
fn moduleUse(name, info) {
    # TODO: Currently ignores everything about `info` other than the name.
    def name = get(info, "name");

    ifValue { <> moduleGet(name) }
        { module :: return module };

    def pendings = fetch(thePendingBox);
    ifIs { <> get(pendings, name) }
        {
            io0Die(cat(
                "Dependency loop with modules: ",
                sourceString(keyList(pendings))))
        };

    store(thePendingBox, put(pendings, name, null));

    io0Die("TODO: Load module here.");
    io0Die("TODO: Remove module from pendings here.")
};



#
# BEGIN OLD VERSION
#

#
# Private Definitions
#

# Variable name prefix for all module definitions.
def MODULE_PREFIX = "module:";

# Size of `MODULE_PREFIX`.
def MODULE_PREFIX_SIZE = sizeOf(MODULE_PREFIX);

# Given a name, returns the module name portion of it if it in fact starts
# with `MODULE_PREFIX`. Returns void if not.
fn moduleNameFromString(orig) {
    ifIs { <> le(sizeOf(orig), MODULE_PREFIX_SIZE) }
        { return };

    <> ifIs { <> eq(slice(orig, 0, MODULE_PREFIX), MODULE_PREFIX) }
        { <> slice(orig, add(MODULE_PREFIX_SIZE, 1)) }
};

# Does a `get` on the payload data of the given value.
fn dataGet(value, key) {
    <> get(dataOf(value), key)
};

# Does a `sizeOf` on the payload data of the given value.
fn dataSize(value) {
    <> sizeOf(dataOf(value))
};

# Deletes all the given keys from the given map.
fn delAll(map, keys*) {
    <> doReduce1(keys, map) { elem, result <> del(result, elem) }
};

# Returns `mod` iff it is a module (either uninitialized or initialized).
fn isModule(mod) {
    ifNot { <> eq(typeOf(mod), "Module") }
        { return };

    ifNot { <> isMap(&dataOf(mod)) }
        { return };

    ifNot { <> isString(&dataGet(mod, "version")) }
        { return };

    ifIs { <> isMap(&dataGet(mod, "exports")) }
        {
            ifNot { <> eq(dataSize(mod), 2) }
                { return }
        }
        {
            ifNot { <> isMap(&dataGet(mod, "imports")) }
                { return };
            ifNot { <> isUniqlet(&dataGet(mod, "init")) }
                { return };
            ifNot { <> eq(dataSize(mod), 3) }
                { return }
        };

    return mod
};

# Asserts that the given value is a module.
fn assertModule(mod) {
    <> ifIs { <> isModule(mod) }
        { <> mod }
        { io0Die(cat("Not a module: ", sourceString(mod))) }
};

# Returns `mod` if the given module has any dependencies, or void if not.
fn hasDependencies(mod) {
    <> ifIs { <> ne([], &dataGet(mod, "imports")) }
        { <> mod }
};

# Performs topological sort on a list of modules, returning the names
# of the modules in a valid dependency order (not guaranteed to be unique).
#
# This uses the traditional "edge removal" algorithm. See
# <http://en.wikipedia.org/wiki/Topological_sorting> for details.
fn sortModules(modules) {
    # Easy out if there are no modules.
    ifIs { <> eq(modules, []) }
        { return [] };

    # Split the list of modules into those that do and don't have
    # dependencies. Remove from the dependent modules any dependencies from
    # the independent list.

    def independentNames = filterAll(modules)
        { mod ::
            <> ifNot { <> hasDependencies(mod) } { <> dataGet(mod, "name") }
        };

    def dependentModules = filterAll(modules)
        { mod ::
            <> ifIs { <> hasDependencies(mod) }
                {
                    def importMap =
                        delAll([(dataGet(mod, "imports"))*: true],
                            independentNames*);
                    <> @[mod: [(dataOf(mod))*:, imports: keyList(importMap)]]
                }
        };

    # If there are no independent modules, there's a cycle.
    ifIs { <> eq(independentModules, []) }
        {
            def allNames = filterAll(modules)
                { mod <> dataGet(mod, "name") };
            io0Die(cat("Module cycle among: ",
                sourceStringUnadorned(allNames)));
        };

    # Recursively sort the dependent modules.
    def dependentNames = sortModules(dependentModules);

    # Combine for the final result.
    <> [independentNames*, dependentNames*]
};


#
# Exported Definitions
#

# Documented in Samizdat Layer 0 spec.
fn moduleInit(context) {
    # Get a list of just the uninitialized modules, each with its name added
    # to the payload.
    def unsortedModules = filterAll(context)
        { mapping ::
            def name = keyOf(mapping);
            def mod = valueOf(mapping);
            <> ifValue { <> moduleNameFromString(name) }
                { modName ::
                    assertModule(mod);
                    <> @[module: [(dataOf(mod))*:, name: modName]]
                }
        };

    # Make a map from names to modules.
    def moduleMap = collectAsMap(
        makeFilterGenerator(unsortedModules)
            { mod :: <> [(dataGet(mod, "name")): mod] });

    # Do a topological sort of the modules, to get them in dependency
    # order (dependencies before dependents).
    def sortedModuleNames = sortModules(unsortedModules);

    # Iterate over the modules in sorted order, calling the initializer on
    # each (if any), passing it the set of already-initialized modules.
    <> doReduce1(sortedModuleNames, [:])
        { name, initted ::
            def mod = get(moduleMap, name);
            def newMod = ifValue { <> dataGet(mod, "init") }
                { init ::
                    <> @[module: [
                        exports: init(initted),
                        name: dataGet(mod, "name"),
                        version: dataGet(mod, "version")
                    ]]
                }
                {
                    # It's a pre-initialized module.
                    <> mod
                };
            <> [initted*:, (name): newMod]
        }
};

# <> [
#     moduleInit: moduleInit
# ]

#
# END OLD VERSION
#

<> [
    moduleDef: moduleDef,
    moduleGet: moduleGet,
    moduleUse: moduleUse
]
