# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Module functions
#


#
# Private Definitions
#

# Box containing a map from fully-qualified names to modules. Each name is a
# list-of-strings denoting a "path" to the module.
def theModulesBox = Box_makeMutableBox({});

# Flattens a module name to a simple directory name.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Io*` modules, because this function needs to be called before the `Io*`
# modules are loaded.
fn flattenName(name) {
    # Suffix each component with `/`, concatenate them all together, and
    # drop the final `/`.

    def withSlashes = Generator_filter(name, { elem <> cat(elem, "/") });
    def nearResult = cat(withSlashes*);
    <> Collection_slice(
        nearResult,
        0,
        Number_sub(Collection_sizeOf(nearResult), 1))
};

# Makes a module-load global context, based on the given `baseCtx` and which
# adds submodule read and load functions that use the given `directory` (a
# flat path).
fn makeModuleContext(baseCtx, directory) {
    # A box for the final load context, to enable the necessary self-reference.
    def ctxBox = Box_makeYieldBox();

    # A box for all the loaded submodules.
    def subsBox = Box_makeMutableBox({});

    fn submoduleRead(name) {
        Io0_note(cat("        ", name));
        def path = cat(directory, "/", name);
        <> ifIs { <> Io0_flatFileExists(path) }
            { <> Io0_flatReadFileUtf8(path) }
            { Io0_die(cat("No such module file: ", name)) }
    };

    fn submoduleLoad(name) {
        def ctx = Box_fetch(ctxBox);
        def text = submoduleRead(cat(name, ".sam"));
        def tree = ctx::submoduleParse(text);
        def func = ctx::submoduleEval(ctx, tree);
        <> func()
    };

    fn submoduleUse(name) {
        ifValue { <> get(Box_fetch(subsBox), name) }
            { value -> return value };

        def result = ifValue { <> submoduleLoad(name) }
            { r <> r }
            { <> {} };

        Box_store(subsBox, {(Box_fetch(subsBox))*, (name): result});
        <> result
    };

    # This must evaluate to a map.
    def moduleInfo = Lang0_eval(baseCtx,
        Lang0_parseExpression(submoduleRead("module.sam")));

    def languageName = moduleInfo::language;
    def languageModule = ifIs { <> ne(languageName, "none") }
        { <> baseCtx::moduleUse({name: ["core", languageName]}) }
        {
            # Fall-back used when loading modules before `Lang0` is defined.
            <> {
                eval:         Lang0_eval,
                parseProgram: Lang0_parseProgram
            }
        };

    def fullCtx = {
        baseCtx*,
        moduleInfo:     moduleInfo,
        submoduleEval:  languageModule::eval,
        submoduleUse:   submoduleUse,
        submoduleParse: languageModule::parseProgram,
        submoduleRead:  submoduleRead
    };

    Box_store(ctxBox, fullCtx);
    <> fullCtx
};


#
# Type Definition
#
# `Module` payload is `{info: map, exports: map}`. `info` includes at least
# `{name: [string, ...], version: string}`.

# Gets the `exports` of a module.
fn getExports(modu) {
    <> dataOf(modu)::exports
};

# Gets the `info` of a module.
fn getInfo(modu) {
    <> dataOf(modu)::info
};

# Returns a new module like the given one, except with `exports` as
# given.
fn withExports(modu, newExports) {
    <> @[Module: {(dataOf(modu))*, exports: newExports}]
};

# Documented in spec.
fn Module_cat(modu, more*) {
    def data = dataOf(modu);

    def allExports = Generator_filter([modu, more*], getExports);
    def combinedExports = cat({}, allExports*);

    <> withExports(modu, combinedExports)
};
genericBind(cat, "Module", Module_cat);

# Documented in spec.
fn Module_del(modu, key) {
    <> withExports(modu, Collection_del(getExports(modu), key))
};
genericBind(Collection_del, "Module", Module_del);

# Documented in spec.
fn Module_get(modu, key) {
    <> get(getExports(modu), key)
};
genericBind(get, "Module", Module_get);

# Documented in spec.
fn Module_keyList(modu) {
    <> Collection_keyList(getExports(modu))
};
genericBind(Collection_keyList, "Module", Module_keyList);

# Documented in spec.
fn Module_nameOf(modu) {
    <> getInfo(modu)::name
};
genericBind(nameOf, "Module", Module_nameOf);

# Documented in spec.
fn Module_nth(modu, n) {
    <> Collection_nth(getExports(modu), n)
};
genericBind(Collection_nth, "Module", Module_nth);

# Documented in spec.
fn Module_put(modu, key, value) {
    <> withExports(modu, Collection_put(getExports(modu), key, value))
};
genericBind(Collection_put, "Module", Module_put);

# Documented in spec.
fn Module_sizeOf(modu) {
    <> Collection_sizeOf(getExports(modu))
};
genericBind(Collection_sizeOf, "Module", Module_sizeOf);

# Documented in spec.
fn Module_slice(modu, start, end?) {
    <> withExports(modu, Collection_slice(getExports(modu), start, end*))
};
genericBind(Collection_slice, "Module", Module_slice);



#
# Exported Definitions
#

# Documented in spec.
fn getGlobals(modu) {
    def info = getInfo(modu);
    def bindings = ifValue { <> info::globalExports }
        { globals ->
            def bindings = Generator_filter(
                globals,
                { g <> {(g): get(modu, g)} });
            <> cat(bindings*)
        }
        { <> {} };
    def moduleBinding = ifValue { <> info::globalModuleName }
        { name <> {(name): modu} }
        { <> {} };

    <> { bindings*, moduleBinding* }
};

# Documented in spec.
#
# **Note:** This function is a (low rent) duplicate of functionality in
# `Module`, because this function needs to be called before `Module` is
# fully loaded.
fn load(baseCtx, directory) {
    def flatPath = flattenName(directory);
    def ctx = makeModuleContext(baseCtx, flatPath);

    # This must evaluate to a map.
    def exports = ctx::submoduleUse("main");

    # Combine `moduleInfo` and `exports` to form the final module value.
    <> @[Module: {info: ctx::moduleInfo, exports: exports}];
};

# Documented in spec.
fn moduleDef(modu) {
    def name = nameOf(modu);

    ifIs { <> moduleGet({name: name}) }
        {
            Io0_die(cat("Cannot redefine module: ",
                stringFromModuleName(name)))
        };

    def mods = Box_fetch(theModulesBox);
    Box_store(theModulesBox, Collection_put(mods, name, modu));
};

# Documented in spec.
fn moduleGet(searchInfo) {
    # TODO: Currently ignores everything about `searchInfo` other than the name.
    def name = searchInfo::name;

    <> get(Box_fetch(theModulesBox), name)
};

# Documented in spec.
#
# **Note:** This is the early-bootstrap version of this function, which
# requires a module to be pre-defined.
fn moduleUse(searchInfo) {
    <> ifValueOr { <> moduleGet(searchInfo) }
        {
            Io0_die(cat("Module not found: ",
                stringFromModuleName(searchInfo::name)))
        }
};

# Documented in spec.
fn stringFromModuleName(fqName) {
    # Prefix each component with "::", combine them all, and then drop the
    # first two characters.
    def parts = Generator_filter(fqName, { n <> cat("::", n) });
    def result = cat(parts*);

    <> Collection_slice(result, 2)
};

# Documented in spec. This is a manual definition of the `Module0` module.
def Module0 = @[Module: {
    info: {
        name: ["core", "Module0"],
        version: "0.0.1"
    },
    exports: {
        getGlobals:           getGlobals,
        load:                 load,
        moduleDef:            moduleDef,
        moduleGet:            moduleGet,
        moduleUse:            moduleUse,
        stringFromModuleName: stringFromModuleName
    }
}];
moduleDef(Module0);

<> {
    moduleDef: moduleDef,
    moduleGet: moduleGet,
    moduleUse: moduleUse
}
