# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 2 Tree Parser
#


#
# Helper definitions
#

# Set-like map of all lowercase identifier characters. Used to figure
# out if we're looking at a keyword in the `identifierString` rule.
LOWER_ALPHA = ["a".."z": true];

# Returns a `call` node.
makeCall = { function, actuals* ::
    <> @[call: [function: function, actuals: actuals]]
};

# Returns a `varDef` node.
makeVarDef = { name, value ::
    <> @[varDef: [name: name, value: value]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @[varRef: name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name, actuals* ::
    <> @[call: [function: makeVarRef(name), actuals: actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @[literal: value]
};

# Returns node representing a thunk (no-arg function) that returns the
# expression represented by the given node.
makeThunk = { expression ::
    <> @[closure: [statements: [], yield: expression]]
};

# Returns a `call` node that names a function as a `varRef` and passes
# "thunked" versions of each of the given actual arguments.
makeCallNameThunks = { name, actuals* ::
    thunks = listMap(actuals) { ., one :: <> makeThunk(one) };
    <> makeCallName(name, thunks*)
};

# Returns a `call` node to a nonlocal exit with the given name and
# with optional expression value. The expression if supplied is automatically
# "thunked".
makeCallNonlocalExit = { name, expression? ::
    <> ifValue { <> listFirst(expression) }
        { ex :: <> makeCall(makeVarRef("nonlocalExit"), name, makeThunk(ex)) }
        { <> makeCall(makeVarRef("nonlocalExit"), name) }
};

# Map of token types to corresponding unary operator function name variable
# references.
UNARY_OPERATORS = listReduce([:], ["+", "-", "!", "[]", "!!!"])
    { result, ., name ::
        <> [result*, (name): makeVarRef(stringAdd("unary", name))]
    };

# Map of token types to corresponding binary operator function name variable
# references.
BINARY_OPERATORS = listReduce([:],
    [
        "+", "-", "*", "/", "%",
        "&&&", "|||", "^^^", "<<<", ">>>",
        "==", "!=", "<", ">", "<=", ">=",
        "\\==", "\\!=", "\\<", "\\>", "\\<=", "\\>="
    ]
    )
    { result, ., name ::
        <> [result*, (name): makeVarRef(stringAdd("binary", name))]
    };

# Helper for parsing binary operator expressions, which puts together
# a sequence of function calls.
makeBinaryCalls = { firstEx, opExList ::
    <> listReduce(firstEx, opExList) { result, ., opEx ::
        op = listFirst(opEx);
        ex = listLast(opEx);
        <> makeCall(mapGet(BINARY_OPERATORS, tokenType(op)), result, ex)
    }
};

# Reports the given list of pending tokens as part of error processing.
reportError = { pending ::
    io0Note("Pending tokens:");

    listForEach(pending)
        { ., token :: io0Note(format("    %q", token)) };

    io0Die("\nExtra tokens at end of program.")
};


#
# Grammar rules
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations.
parseClosure = forwardFunction();
parseExpression = forwardFunction();

# Forward declaration required for integrating layer 1 definitions.
parseParser = forwardFunction();

# Parses an integer literal.
parseInt = {/
    i = @int
    { <> makeLiteral(tokenValue(i)) }
/};

# Parses a string literal.
parseString = {/
    s = @string
    { <> makeLiteral(tokenValue(s)) }
/};

# Parses an identifier, identifier-like keyword, or string literal,
# returning a string literal in all cases.
parseIdentifierString = {/
    s = [@identifier @string]
    { <> makeLiteral(tokenValue(s)) }
|
    token = .
    &&(not(tokenHasValue(token)))
    {
        type = tokenType(token);
        firstCh = stringNth(type, 0);
        <> ifTrue { <> mapHasKey(LOWER_ALPHA, firstCh) }
            { <> makeLiteral(type) }
    }
/};

# Parses a list element.
parseListElement = {/
    ex = parseExpression

    (
        @"*"
        { <> @[interpolate: ex] }
    |
        @".."
        end = parseExpression
        { <> @[interpolate: makeCallName("makeRange", ex, end)] }
    |
        { <> ex }
    )
/};

# Parses an "unadorned" (no bracketing) list. Yields a list (per se)
# of contents.
parseUnadornedList = {/
    first = parseListElement
    rest = (@"," parseListElement)*
    { <> [first, rest*] }
|
    { <> [] }
/};

# Parses a list literal.
parseList = {/
    @"["
    expressions = parseUnadornedList
    @"]"
    {
        <> ifTrue { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> makeCallName("makeList", expressions*) }
    }
/};

# Parses an empty map literal.
parseEmptyMap = {/
    @"[" @":" @"]"
    { <> makeLiteral([:]) }
/};

# Parses a mapping (element of a map).
parseMapping = {/
    key = (
        k = parseIdentifierString
        @":"
        { <> k }
    |
        k = parseListElement
        @":"
        { <> k }
    )

    value = parseExpression
    { <> makeCallName("makeList", value, key) }
|
    map = parseExpression
    @"*"
    { <> map }
/};

# Parses a map literal.
parseMap = {/
    @"["
    (@":" @",")?
    first = parseMapping
    rest = (@"," parseMapping)*
    @"]"
    { <> makeCallName("makeMap", first, rest*) }
/};

# Parses a token literal.
parseToken = {/
    @"@"

    tokenArgs = (
        @"["
        type = parseIdentifierString
        value = (@":" parseExpression)?
        @"]"
        { <> [type, value*] }
    |
        @"["
        type = parseExpression
        value = (@":" parseExpression)?
        @"]"
        { <> [type, value*] }
    |
        type = parseIdentifierString
        { <> [type] }
    )

    { <> makeCallName("makeToken", tokenArgs*) }
/};

# Parses a uniqlet literal.
parseUniqlet = {/
    @"@@"
    { <> makeCallName("makeUniqlet") }
/};

# Parses a variable reference.
parseVarRef = {/
    name = @identifier
    { <> makeVarRef(tokenValue(name)) }
/};

# Parses a variable definition.
parseVarDef = {/
    name = @identifier
    @"="
    ex = parseExpression
    { <> makeVarDef(tokenValue(name), ex) }
/};

# Parses a parenthesized expression.
parseParenExpression = {/
    @"("
    ex = parseExpression
    @")"
    { <> ex }
/};

# Parses an atomic expression.
parseAtom = {/
    parseVarRef | parseInt | parseString |
    parseList | parseEmptyMap | parseMap |
    parseUniqlet | parseToken | parseClosure | parseParenExpression |
    # Defined by Samizdat Layer 1.
    &@"{/" parseParser
/};

# Parses an optional yield / non-local exit definition.
parseOptYieldDef = {/
    @"<"
    name = @identifier
    @">"
    { <> [yieldDef: tokenValue(name)] }
|
    { <> [:] }
/};

# Parses a list of "actual" (as opposed to formal) arguments to a function.
# Yields a list of expression nodes.
parseActualsList = {/
    @"()"
    parseClosure*
|
    @"("
    normalActuals = parseUnadornedList
    @")"
    closureActuals = parseClosure*
    { <> [normalActuals*, closureActuals*] }
|
    parseClosure+
/};

# `callExpression` and `expression` from layer 0 are omitted here, and
# `statement` and `nonlocalExit` are replaced with forwarded functions here.
# These are all subsumed by more featureful layer 2 definitions, below.
parseStatement = forwardFunction();
parseNonlocalExit = forwardFunction();

# Parses a local yield / return.
parseYield = {/
    @"<>"
    (
        ex = parseExpression
        { <> [yield: ex] }
    |
        { <> [:] }
    )
/};

# Parses a formal argument decalaration.
parseFormal = {/
    name = (
        n = @identifier
        { <> [name: tokenValue(n)] }
    |
        @"." { <> [:] }
    )

    repeat = (
        r = [@"?" @"*" @"+"]
        { <> [repeat: tokenType(r)] }
    |
        { <> [:] }
    )

    { <> [:, name*, repeat*] }
/};

# Parses a list of formal arguments, with no surrounding parentheses.
parseFormalsList = {/
    first = parseFormal
    rest = (@"," parseFormal)*
    { <> [formals: [first, rest*]] }
|
    { <> [:] }
/};

# Parses a program body (statements plus optional yield).
parseProgramBody = {/
    @";"*

    most = (
        s = parseStatement
        @";"+
        { <> s }
    )*

    last = (
        s = (parseStatement | parseNonlocalExit)
        { <> [statements: [s]] }
    |
        y = parseYield
        { <> [statements: [], y*] }
    |
        { <> [statements: []] }
    )

    @";"*

    {
        allStatements = [most*, mapGet(last, "statements")*];
        <> [last*, statements: allStatements]
    }
/};

# Parses program / function declarations.
parseProgramDeclarations = {/
    yieldDef = parseOptYieldDef
    formals = parseFormalsList

    @"::"

    { <> [:, formals*, yieldDef*] }
/};

# Parses a program (top-level program or contents inside function braces).
parseProgram = {/
    decls = (parseProgramDeclarations | { <> [:] })
    body = parseProgramBody
    { <> @[closure: [:, decls*, body*]] }
/};

# Parses a closure (in-line anonymous function, with no extra bindings).
implClosure = {/
    @"{"
    prog = parseProgram
    @"}"
    { <> prog }
/};
parseClosure(implClosure);

# Top-level rule to parse a program with possible error afterwards.
# Note that an empty string is a valid program.
parseProgramOrError = {/
    prog = parseProgram
    (
        pending = .+
        { reportError(pending) }
    )?
    { <> prog }
/};


#
# Samizdat Layer 1 definitions
#

# Forward declaration.
parseChoicePex = forwardFunction();

# Parses a closure which must not define any formal arguments. This is done
# by parsing an arbitrary closure and then verifying that it does not
# declare formals. This is preferable to not-including formal argument
# syntax, because (a) no rule wants to differentiate these cases (rules either
# wants an arbitrary closure or a specifically-constrained kind); (b) it
# reduces redundancy in the syntax, and (c) the error case on the former
# would be more obscure (as in just something like "unexpected token" on
# the would-be formal argument).
parseNullaryClosure = {/
    closure = parseClosure

    {
        ifTrue { <> mapHasKey(tokenValue(closure), "formals") }
            { io0Die("Invalid formal argument in code block.") };
        <> closure
    }
/};

# Parses a parser function.
implParser = {/
    @"{/"
    pex = parseChoicePex
    @"/}"
    { <> @[parser: pex] }
/};
parseParser(implParser);

# Parses a parenthesized parsing expression.
parseParenPex = {/
    @"("
    pex = parseChoicePex
    @")"
    { <> pex }
/};

# Parses a string literal parsing expression.
parseParserString = {/
    s = @string
    {
        value = tokenValue(s);
        <> ifTrue { <> eq(lowSize(value), 1) }
            { <> @[token: value] }
            { <> s }
    }
/};

# Parses a token literal parsing expression.
parseParserToken = {/
    @"@"
    type = [@identifier @string]
    { <> @[token: tokenValue(type)] }
/};

# Parses a string or character range parsing expression, used when defining
# sets.
parseParserSetString = {/
    s = @string
    (
        @".."
        startInt = {
            startValue = tokenValue(s);
            <> ifTrue { <> eq(lowSize(startValue), 1) }
                { <> intFromString(startValue) }
        }
        end = @string
        endInt = {
            endValue = tokenValue(end);
            <> ifTrue { <> eq(lowSize(endValue), 1) }
                { <> intFromString(endValue) }
        }
        {
            loopReduce([startInt, ""]) { result ::
                at = listFirst(result);
                soFar = listLast(result);
                ifTrue { <> gt(at, endInt) } { <out> @[string: soFar] };
                <> [iadd(at, 1), stringAdd(soFar, stringFromInt(at))]
            }
        }
    |
        { <> s }
    )
/};

# Parses a set (or set complement) parsing expression.
parseParserSet = {/
    @"["

    type = (
        @"!" { <> "[!]" }
    |
        { <> "[]" }
    )

    terminals = (
        strings = parseParserSetString+
        {
            oneString = listReduce("", strings)
                { result, ., s :: <> stringAdd(result, tokenValue(s)) };
            <> stringReduce([], oneString)
                { result, ., ch :: <> [result*, ch] }
        }
    |
        tokens = parseParserToken+
        { <> listMap(tokens) { ., t :: <> tokenValue(t) } }
    |
        { <> [] }
    )

    @"]"

    { <> @[(type): terminals] }
/};

# Parses a code block parsing expression.
parseParserCode = {/
    closure = parseNullaryClosure
    { <> @["{}": tokenValue(closure) ] }
/};

# Parses a predicate parsing expression.
parseParserPredicate = {/
    @"&&"
    predicate = parseParenExpression
    { <> @["&&": predicate] }
/};

# Parses an atomic parsing expression.
parseParserAtom = {/
    parseVarRef
|
    parseParserString
|
    parseParserToken
|
    parseParserSet
|
    parseParserCode
|
    parseParserPredicate
|
    @"."
|
    @"()"
|
    parseParenPex
/};

# Parses a repeat (or not) parsing expression.
parseRepeatPex = {/
    atom = parseParserAtom
    (
        repeat = [@"?" @"*" @"+"]
        { <> @[tokenType(repeat): atom] }
    |
        { <> atom }
    )
/};

# Parses a lookahead (or not) parsing expression. This covers both lookahead
# success and lookahead failure.
parseLookaheadPex = {/
    (
        lookahead = [@"&" @"!"]
        pex = parseRepeatPex
        { <> @[tokenType(lookahead): pex] }
    )
|
    parseRepeatPex
/};

# Parses a name (or not) parsing expression.
parseNamePex = {/
    (
        name = @identifier
        @"="
        pex = parseLookaheadPex
        { <> @[varDef: [name: tokenValue(name), value: pex]] }
    )
|
    parseLookaheadPex
/};

# Parses a sequence parsing expression. This includes sequences of length
# one, but it does *not* parse empty (zero-length) sequences.
parseSequencePex = {/
    items = parseNamePex+
    { <> @[sequence: items] }
/};

# Parses a choice parsing expression. This includes a single choice.
implChoicePex = {/
    first = parseSequencePex
    rest = (@"|" parseSequencePex)*
    { <> @[choice: [first, rest*]] }
/};
parseChoicePex(implChoicePex);


#
# Samizdat Layer 2 definitions
#

# Parses a closure which must have neither formal arguments nor a yield
# definition. See `parseNullaryClosure` above for discussion.
parseCodeOnlyClosure = {/
    closure = parseNullaryClosure

    {
        ifTrue { <> mapHasKey(tokenValue(closure), "yieldDef") }
            { io0Die("Invalid yield definition in code block.") };
        <> closure
    }
/};

# Common parsing for `fn` statements and expressions. The syntax for
# both is identical, except that the statement form requires that the
# function be named. The result of this rule is a map identical in form to
# a closure payload, except that `name` may also be bound.
#
# If `name` is *not* bound, the result is suitable for use as a `closure` node
# payload. And if `name` *is* bound, it is valid to use the result as the
# payload for a `fnDef` node.
#
# The translation is along these lines:
#
# ```
# fn <out> name(arg1, arg2) { stat1; stat2 }
# ```
#
# ```
# {/ arg1 arg2 <\"return"> ::
#     out = \"return";
#     stat1;
#     stat2
# /}
# ```
#
# with:
#
# * no yield def binding statement if an explicit yield def was not present.
#
# * the key `name` bound to the function name, if a name was defined. (This
#   is not representable in lower-layer surface syntax.)
parseFnCommon = {/
    @"fn"

    # This is a variable definition statement which binds the yield def
    # name to the `return` function, if there is in fact a yield def present.
    returnDef = (
        y = parseOptYieldDef
        {
            <> ifValue { <> mapGet(y, "yieldDef") }
                { yieldName :: <> makeVarDef(yieldName, makeVarRef("return")) }
        }
    )?

    name = (
        n = @identifier
        { <> [name: tokenValue(n)] }
    |
        { <> [:] }
    )

    formals = (
        @"()"
        { <> [:] }
    |
        @"("
        f = parseFormalsList
        @")"
        { <> f }
    )

    code = parseCodeOnlyClosure

    {
        codeMap = tokenValue(code);
        statements = [returnDef*, mapGet(codeMap, "statements")*];
        <> [
            codeMap*, name*, formals*,
            yieldDef: "return",
            statements: statements
        ]
    }
/};

# Parses a non-local exit / return. All of the form matched by this rule
# have the dual properties of (a) necessarily being at the end of a code
# block, and (b) being represented as a function call in the underlying
# function representation of code blocks.
implNonlocalExit = {/
    @"<"
    name = parseVarRef
    @">"
    value = parseExpression?
    { <> makeCallNonlocalExit(name, value*) }
|
    op = [@"break" @"return"]
    value = parseExpression?
    { <> makeCallNonlocalExit(makeVarRef(tokenType(op)), value*) }
|
    # This one is separate from `break` and `return`, because it doesn't
    # accept a value.
    @"continue"
    { <> makeCallNonlocalExit(makeVarRef("continue")) }
/};
parseNonlocalExit(implNonlocalExit);

# Parses a unary prefix operator. This yields a `varRef` node for the function
# to apply when applying the prefix.
parsePrefixOperator = {/
    operator = [@"+" @"-" @"!" @"!!!"]
    { <> mapGet(UNARY_OPERATORS, tokenType(operator)) }
/};

# Parses a unary postfix operator. This yields a function (per se) to call
# in order to construct a node that represents the appropriate ultimate
# function call.
parsePostfixOperator = {/
    actuals = parseActualsList
    { <> { node :: <> makeCall(node, actuals*) } }
|
    @"["
    exprs = parseUnadornedList
    @"]"

    (
        &&(eq(exprs, []))
        { io0Die("Missing index value(s) from index expression.") }
    )?

    {
        function = mapGet(UNARY_OPERATORS, "[]");
        <> { node :: <> makeCall(function, node, exprs*) }
    }
|
    names = (@"." parseIdentifierString)+

    {
        function = mapGet(UNARY_OPERATORS, "[]");
        <> { node :: <> makeCall(function, node, names*) }
    }
/};

# Parses a unary expression. This is an atom, optionally surrounded on
# either side by any number of unary operators. Postfix operators
# take precedence over (are applied before) the prefix operators.
parseUnaryExpression = {/
    prefixes = parsePrefixOperator*
    atom = parseAtom
    postfixes = parsePostfixOperator*

    {
        withPosts = listReduce(atom, postfixes)
            { result, ., postfix :: <> postfix(result) };
        <> listReduce(withPosts, listReverse(prefixes))
            { result, ., prefix :: <> makeCall(prefix, result) }
    }
/};

# Parses a multiplicative expression. (Binary infix operator expressions
# are listed from tightest to loosest binding / precedence.)
parseMulExpression = {/
    firstEx = parseUnaryExpression
    opExes = (
        op = [@"*" @"/" @"%" @"<<<" @">>>"]
        ex = parseUnaryExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses an additive expression.
parseAddExpression = {/
    firstEx = parseMulExpression
    opExes = (
        op = [@"+" @"-" @"&&&" @"|||" @"^^^"]
        ex = parseMulExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses a comparison expression. The syntax here is the mathematical
# style of `x < y < z` meaning `x < y && y < z`, supported by the
# `compareChain` library function.
parseCompareExpression = {/
    firstEx = parseAddExpression
    opExes = (
        op = [
            @"=="   @"!="   @"<"   @">"   @"<="   @">="
            @"\\==" @"\\!=" @"\\<" @"\\>" @"\\<=" @"\\>="
        ]
        ex = parseAddExpression
        { <> [op, ex] }
    )*

    (
        # No actual comparisons (just a simple pass-through to `addExpression`).
        &&(eq(lowSize(opExes), 0))
        { <> firstEx }
    |
        # Just one operator, so no need to chain.
        &&(eq(lowSize(opExes), 1))
        { <> makeBinaryCalls(firstEx, opExes) }
    |
        # The general case of two or more comparison operators.
        {
            # Make separate ops and exes arrays.
            arrays = listReduce([[], []], opExes) { result, ., one ::
                ops = listFirst(result);
                exes = listLast(result);
                op = mapGet(BINARY_OPERATORS, tokenType(listFirst(one)));
                ex = listLast(one);
                <> [[ops*, op], [exes*, ex]]
            };
            ops = makeCallName("makeList", listFirst(arrays)*);
            exes = listLast(arrays);

            <> makeCallName("compareChain", ops, firstEx, exes*);
        }
    )
/};

# Parses a short-circuit logical-and expression.
parseAndExpression = {/
    first = parseCompareExpression
    rest = (@"&&" parseCompareExpression)*

    (
        # Not actually a logical-and expression.
        &&(eq(lowSize(rest), 0))
        { <> first }
    |
        { <> makeCallNameThunks("and", first, rest*) }
    )
/};

# Parses a short-circuit logical-or expression.
parseOrExpression = {/
    first = parseAndExpression
    rest = (@"||" parseAndExpression)*

    (
        # Not actually a logical-or expression.
        &&(eq(lowSize(rest), 0))
        { <> first }
    |
        { <> makeCallNameThunks("or", first, rest*) }
    )
/};

# Parses a `fn` (function with `return` binding) expression. The translation
# is as described in `parseFnCommon` (above) if the function is not given a
# name. If the function *is* given a name, the translation is along the
# following lines:
#
# ```
# fn <out> name(arg1, arg2) { stat1; stat2 }
# ```
#
# =>
#
# ```
# {/
#     name = forwardFunction();
#     <> name {/ arg1 arg2 <\"return"> ::
#         out = \"return";
#         stat1;
#         stat2
#     /}
# /}()
# ```
parseFnExpression = {/
    funcMap = parseFnCommon
    closure = { <> @[closure: funcMap] }

    (
        name = { <> mapGet(funcMap, "name") }
        {
            mainClosure = @[closure: [
                statements: [
                    makeVarDef(name, makeCallName("forwardFunction"))
                ],
                yield: makeCall(makeVarRef(name), closure)
            ]];

            <> makeCall(mainClosure)
        }
    |
        { <> closure }
    )
/};

# Parses an if expression.
parseIfExpression = {/
    @"if"
    yieldDef = parseOptYieldDef
    firstCondition = parseParenExpression
    firstThen = parseNullaryClosure

    elseIfThens = (
        @"else"
        @"if"
        condition = parseParenExpression
        then = parseNullaryClosure
        { <> [condition, then] }
    )*

    finalElse = (
        @"else"
        parseClosure
    )?

    mainCall = (
        # Unchained if-then or if-then-else.
        &&(eq(lowSize(elseIfThens), 0))
        {
            <> makeCallName("ifTrue",
                makeThunk(firstCondition), firstThen, finalElse*)
        }
    |
        # General chained form.
        {
            # Make separate conditions and thens arrays.
            arrays = listReduce(
                [[makeThunk(firstCondition)], [firstThen]],
                elseIfThens)
                { result, ., one ::
                    conditions = listFirst(result);
                    thens = listLast(result);
                    condition = makeThunk(listFirst(one));
                    then = listLast(one);
                    <> [
                        [conditions*, condition],
                        [thens*, then]
                    ]
                };

            conditions = makeCallName("makeList", listFirst(arrays)*);
            thens = [listLast(arrays)*, finalElse*];

            <> makeCallName("ifChain", conditions, thens*);
        }
    )

    (
        # There was a yield def; wrap the whole thing in a thunk-call.
        &&(ne(yieldDef, [:]))
        {
            mainClosure = @[closure: [
                yieldDef: mapValue(yieldDef),
                statements: [],
                yield: mainCall
            ]];

            <> makeCall(mainClosure)
        }
    |
        { <> mainCall }
    )
/};

# Parses the optional yield definition that's associated with the `break`
# exit of a loop. This always results in a list, which is empty if there
# is no yield definition present, or is a single-element list of an
# appropriate variable definition and assignment.
parseOptBreakDef = {/
    y = parseOptYieldDef

    {
        <> ifTrue { <> ne(y, [:]) }
            { <> makeVarDef(mapValue(y), makeVarRef("break")) }
    }?
/};

# Helper for switch expressions: Parse a regular case.
parseSwitchCase = {/
    key = parseUnadornedList
    @":"
    code = parseNullaryClosure
    { <> makeCallName("makeList", code, key*) }
/};

# Helper for switch expressions: Parse a default case.
parseSwitchDefault = {/
    @"default"
    @":"
    parseNullaryClosure
/};

# Parses a switch expression. The translation is along these lines:
#
# ```
# switch <out> (value) {
#     ex1: { stat1a; stat1b }
#     ex2: { stat2a; stat2b }
#     default: { statDefault }
# }
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     <> \"switch"(
#         value,
#         [
#             ex1 = { stat1a; stat1b },
#             ex2 = { stat2a; stat2b }
#         ])
#         { statDefault }
# }
# ```
#
# with the initial break assignment omitted if there is no yield def,
# and with overrides of map keys switched around so the *first* key
# wins.
parseSwitchExpression = {/
    @"switch"
    breakDef = parseOptBreakDef
    value = parseParenExpression

    @"{"

    cases1 = parseSwitchCase*
    optDefault = parseSwitchDefault?
    cases2 = parseSwitchCase*

    (
        # Detect double default clause as an explicit error.
        parseSwitchDefault
        { io0Die("Multiple default clauses.") }
    )?

    @"}"

    {
        switchCall = makeCallName("switch",
            value,
            makeCallName("makeMapReversed", cases1*, cases2*),
            optDefault*);

        mainClosure = @[closure: [
            yieldDef: "break",
            statements: [breakDef*],
            yield: switchCall
        ]];

        <> makeCall(mainClosure)
    }
/};


# Parses a while expression. The translation is along these lines:
#
# ```
# while <out> (expr) { <next> :: stat1; stat2 }
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     loop { <\"continue"> ::
#         ifTrue { <> expr }
#             { <next> :: stat1; stat2 }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def.
parseWhileExpression = {/
    @"while"
    breakDef = parseOptBreakDef
    condition = parseParenExpression
    code = parseNullaryClosure

    {
        loopClosure = @[closure: [
            yieldDef: "continue",
            statements: [
                makeCallName("ifTrue",
                    makeThunk(condition),
                    code,
                    makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
            ]
        ]];

        mainClosure = @[closure: [
            yieldDef: "break",
            statements: [breakDef*, makeCallName("loop", loopClosure)]
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a do expression. The translation is along these lines:
#
# ```
# do <out> { <next> :: stat1; stat2 } while (expr)
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     loop { <\"continue"> ::
#         { <next> :: stat1; stat2 }();
#         ifFalse { <> expr }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def, and
# with the `ifFalse` statement omitted if there is no `while` at the end
# of the `do`.
parseDoExpression = {/
    @"do"
    breakDef = parseOptBreakDef
    code = parseNullaryClosure
    condition = (
        @"while"
        ex = parseParenExpression
        {
            <> makeCallName("ifFalse",
                makeThunk(ex),
                makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
        }
    )?

    {
        loopClosure = @[closure: [
            yieldDef: "continue",
            statements: [makeCall(code), condition*]
        ]];

        mainClosure = @[closure: [
            yieldDef: "break",
            statements: [breakDef*, makeCallName("loop", loopClosure)]
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a general expression.
implExpression = {/
    # This one's the top level "regular-looking" expression (in that it
    # covers the territory of C-style expressions).
    parseOrExpression
|
    # This one is only nominally "regular-looking" (in that not many C
    # family languages have function expressions).
    parseFnExpression
|
    # This one and the rest are "statement-like" expressions (in that they
    # look like corresponding statements from C-derived languages).
    parseIfExpression
|
    parseDoExpression
|
    parseSwitchExpression
|
    parseWhileExpression
/};
parseExpression(implExpression);

# Parses a `fn` definition statement. The syntax here is the same as
# what's recognized by `parseFnCommon`, except that the name is required.
# We don't error out (terminate the runtime) on a missing name, though, as
# that just means that we're looking at a legit `fn` expression, which will
# get successfully parsed by the `expression` alternative of `statement`.
parseFnDef = {/
    funcMap = parseFnCommon
    &&(mapHasKey(funcMap, "name"))

    { <> @[fnDef: funcMap] }
/};

# Parses a statement.
implStatement = {/
    parseVarDef | parseFnDef | parseExpression
/};
parseStatement(implStatement);


#
# Exported functions
#

# Documented in Samizdat Layer 1 spec.
sam2Tree = { program ::
    tokens = ifTrue { <> isString(program) }
        { <> sam2Tokenize(program) }
        { <> program };

    <> pegApply(parseProgramOrError, tokens)
};

<> [
    sam2Tree: sam2Tree
]
