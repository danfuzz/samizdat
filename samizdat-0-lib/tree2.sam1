# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 2 Tree Parser
#


#
# Helper definitions
#

# Returns a `call` node.
makeCall = { function, actuals* ::
    <> @["call" = ["function"=function, "actuals"=actuals]]
};

# Returns a `varDef` node.
makeVarDef = { name, value ::
    <> @["varDef" = ["name"=name, "value"=value]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @["varRef" = name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name, actuals* ::
    <> @["call" = ["function"=makeVarRef(name), "actuals"=actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @["literal" = value]
};

# Returns node representing a thunk (no-arg function) that returns the
# expression represented by the given node.
makeThunk = { expression ::
    <> @["closure" = ["statements"=[], "yield"=expression]]
};

# Returns a `call` node that names a function as a `varRef` and passes
# "thunked" versions of each of the given actual arguments.
makeCallNameThunks = { name, actuals* ::
    thunks = listMap(actuals) { ., one :: <> makeThunk(one) };
    <> apply(makeCallName, name, thunks)
};

# Returns a `call` node to a nonlocal exit with the given name and
# with optional expression value. The expression if supplied is automatically
# "thunked".
makeCallNonlocalExit = { name, expression? ::
    <> ifValue { <> listFirst(expression) }
        { ex :: <> makeCall(makeVarRef("nonlocalExit"), name, makeThunk(ex)) }
        { <> makeCall(makeVarRef("nonlocalExit"), name) }
};

# Map of token types to corresponding unary operator function name variable
# references.
UNARY_OPERATORS = listReduce([=], ["+", "-", "!", "[]", "!!!"])
    { result, ., name ::
        <> mapPut(result, name, makeVarRef(stringAdd("unary", name)))
    };

# Map of token types to corresponding binary operator function name variable
# references.
BINARY_OPERATORS = listReduce([=],
    [
        "+", "-", "*", "/", "%",
        "&&&", "|||", "^^^", "<<<", ">>>",
        "==", "!=", "<", ">", "<=", ">=",
        "\\==", "\\!=", "\\<", "\\>", "\\<=", "\\>="
    ]
    )
    { result, ., name ::
        <> mapPut(result, name, makeVarRef(stringAdd("binary", name)))
    };

# Helper for parsing binary operator expressions, which puts together
# a sequence of function calls.
makeBinaryCalls = { firstEx, opExList ::
    <> listReduce(firstEx, opExList) { result, ., opEx ::
        op = listFirst(opEx);
        ex = listLast(opEx);
        <> makeCall(mapGet(BINARY_OPERATORS, tokenType(op)), result, ex)
    }
};

# Reports the given list of pending tokens as part of error processing.
reportError = { pending ::
    io0Note("Pending tokens:");

    listForEach(pending)
        { ., token :: io0Note(format("    %q", token)) };

    io0Die("\nExtra tokens at end of program.")
};


#
# Grammar rules
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations.
parseClosure = forwardFunction();
parseExpression = forwardFunction();

# Forward declaration required for integrating layer 1 definitions.
parseParser = forwardFunction();

# Parses an integer literal.
parseInt = {/
    i = @int
    { <> makeLiteral(tokenValue(i)) }
/};

# Parses a string literal.
parseString = {/
    s = @string
    { <> makeLiteral(tokenValue(s)) }
/};

# Parses an "unadorned" (no bracketing) list. Yields a list (per se)
# of contents.
parseUnadornedList = {/
    first = parseExpression
    rest = (@"," parseExpression)*
    { <> listPrepend(first, rest) }
|
    { <> [] }
/};

# Parses a list literal.
parseList = {/
    @"["
    expressions = parseUnadornedList
    @"]"
    {
        <> ifTrue { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> apply(makeCallName, "makeList", expressions) }
    }
/};

# Parses an empty map literal.
parseEmptyMap = {/
    @"[" @"=" @"]"
    { <> makeLiteral([=]) }
/};

# Parses a mapping (element of a map).
parseMapping = {/
    key = parseExpression
    @"="
    value = parseExpression
    { <> [key, value] }
/};

# Parses a map literal.
parseMap = {/
    @"["
    first = parseMapping
    rest = (@"," parseMapping)*
    @"]"
    {
        mappings = apply(listAdd, first, rest);
        <> apply(makeCallName, "makeMap", mappings)
    }
/};

# Parses a token literal.
parseToken = {/
    @"@"
    (
        @"["
        type = parseExpression
        value = (@"=" parseExpression)?
        @"]"
        { <> apply(makeCallName, "makeToken", type, value) }
    |
        type = [@string @identifier]
        { <> makeCallName("makeToken", makeLiteral(tokenValue(type))) }
    )
/};

# Parses a uniqlet literal.
parseUniqlet = {/
    @"@@"
    { <> makeCallName("makeUniqlet") }
/};

# Parses a variable reference.
parseVarRef = {/
    name = @identifier
    { <> makeVarRef(tokenValue(name)) }
/};

# Parses a variable definition.
parseVarDef = {/
    name = @identifier
    @"="
    ex = parseExpression
    { <> makeVarDef(tokenValue(name), ex) }
/};

# Parses a parenthesized expression.
parseParenExpression = {/
    @"("
    ex = parseExpression
    @")"
    { <> ex }
/};

# Parses an atomic expression.
parseAtom = {/
    parseVarRef | parseInt | parseString |
    parseList | parseEmptyMap | parseMap |
    parseUniqlet | parseToken | parseClosure | parseParenExpression |
    # Defined by Samizdat Layer 1.
    &@"{/" parseParser
/};

# Parses an optional yield / non-local exit definition.
parseOptYieldDef = {/
    @"<"
    name = @identifier
    @">"
    { <> ["yieldDef" = tokenValue(name)] }
|
    { <> [=] }
/};

# Parses a list of "actual" (as opposed to formal) arguments to a function.
# Yields a list of expression nodes.
parseActualsList = {/
    @"()"
    parseClosure*
|
    @"("
    normalActuals = parseUnadornedList
    @")"
    closureActuals = parseClosure*
    { <> listAdd(normalActuals, closureActuals) }
|
    parseClosure+
/};

# Note: `callExpression` and `expression` from layer 0 are omitted
# here, as they are subsumed by the layer 2 definition (below).

# Parses a statement.
parseStatement = {/
    parseVarDef | parseExpression
/};

# Note: `nonlocalExit` from layer 0 is replaced with a forward here, as it
# is subsumed by the layer 2 definition (below).
parseNonlocalExit = forwardFunction();

# Parses a local yield / return.
parseYield = {/
    @"<>"
    (
        ex = parseExpression
        { <> ["yield" = ex] }
    |
        { <> [=] }
    )
/};

# Parses a formal argument decalaration.
parseFormal = {/
    name = (
        n = @identifier
        { <> ["name" = tokenValue(n)] }
    |
        @"." { <> [=] }
    )

    repeat = (
        r = [@"?" @"*" @"+"]
        { <> ["repeat" = tokenType(r)] }
    |
        { <> [=] }
    )

    { <> mapAdd(name, repeat) }
/};

# Parses a list of formal arguments, with no surrounding parentheses.
parseFormalsList = {/
    first = parseFormal
    rest = (@"," parseFormal)*
    { <> ["formals" = listPrepend(first, rest)] }
|
    { <> [=] }
/};

# Parses a program body (statements plus optional yield).
parseProgramBody = {/
    @";"*

    most = (
        s = parseStatement
        @";"+
        { <> s }
    )*

    last = (
        s = (parseStatement | parseNonlocalExit)
        { <> ["statements" = [s]] }
    |
        y = parseYield
        { <> mapAdd(["statements" = []], y) }
    |
        { <> ["statements" = []] }
    )

    @";"*

    {
        allStatements = listAdd(most, mapGet(last, "statements"));
        <> mapPut(last, "statements", allStatements)
    }
/};

# Parses program / function declarations.
parseProgramDeclarations = {/
    yieldDef = parseOptYieldDef
    formals = parseFormalsList

    @"::"

    { <> mapAdd(formals, yieldDef) }
/};

# Parses a program (top-level program or contents inside function braces).
parseProgram = {/
    decls = (parseProgramDeclarations | { <> [=] })
    body = parseProgramBody
    { <> @["closure" = mapAdd(decls, body)] }
/};

# Parses a closure (in-line anonymous function, with no extra bindings).
implClosure = {/
    @"{"
    prog = parseProgram
    @"}"
    { <> prog }
/};
parseClosure(implClosure);

# Top-level rule to parse a program with possible error afterwards.
# Note that an empty string is a valid program.
parseProgramOrError = {/
    prog = parseProgram
    (
        pending = .+
        { reportError(pending) }
    )?
    { <> prog }
/};


#
# Samizdat Layer 1 definitions
#

# Forward declaration.
parseChoicePex = forwardFunction();

# Parses a closure which must not define any formal arguments. This is done
# by parsing an arbitrary closure and then verifying that it does not
# declare formals. This is preferable to not-including formal argument
# syntax, because (a) no rule wants to differentiate these cases (rules either
# wants an arbitrary closure or a specifically-constrained kind); (b) it
# reduces redundancy in the syntax, and (c) the error case on the former
# would be more obscure (as in just something like "unexpected token" on
# the would-be formal argument).
parseNullaryClosure = {/
    closure = parseClosure

    {
        ifTrue { <> mapHasKey(tokenValue(closure), "formals") }
            { io0Die("Invalid formal argument in code block.") };
        <> closure
    }
/};

# Parses a parser function.
implParser = {/
    @"{/"
    pex = parseChoicePex
    @"/}"
    { <> @["parser" = pex] }
/};
parseParser(implParser);

# Parses a parenthesized parsing expression.
parseParenPex = {/
    @"("
    pex = parseChoicePex
    @")"
    { <> pex }
/};

# Parses a string literal parsing expression.
parseParserString = {/
    s = @string
    {
        value = tokenValue(s);
        <> ifTrue { <> eq(lowSize(value), 1) }
            { <> @["token" = value] }
            { <> s }
    }
/};

# Parses a token literal parsing expression.
parseParserToken = {/
    @"@"
    type = [@identifier @string]
    { <> @["token" = tokenValue(type)] }
/};

# Parses a string or character range parsing expression, used when defining
# sets.
parseParserSetString = {/
    s = @string
    (
        @".."
        startInt = {
            startValue = tokenValue(s);
            <> ifTrue { <> eq(lowSize(startValue), 1) }
                { <> intFromString(startValue) }
        }
        end = @string
        endInt = {
            endValue = tokenValue(end);
            <> ifTrue { <> eq(lowSize(endValue), 1) }
                { <> intFromString(endValue) }
        }
        {
            loopReduce([startInt, ""]) { result ::
                at = listFirst(result);
                soFar = listLast(result);
                ifTrue { <> gt(at, endInt) } { <out> @["string" = soFar] };
                <> [iadd(at, 1), stringAdd(soFar, stringFromInt(at))]
            }
        }
    |
        { <> s }
    )
/};

# Parses a set (or set complement) parsing expression.
parseParserSet = {/
    @"["

    type = (
        @"!" { <> "[!]" }
    |
        { <> "[]" }
    )

    terminals = (
        strings = parseParserSetString+
        {
            oneString = listReduce("", strings)
                { result, ., s :: <> stringAdd(result, tokenValue(s)) };
            <> stringReduce([], oneString)
                { result, ., ch :: <> listAppend(result, ch) }
        }
    |
        tokens = parseParserToken+
        { <> listMap(tokens) { ., t :: <> tokenValue(t) } }
    |
        { <> [] }
    )

    @"]"

    { <> @[type = terminals] }
/};

# Parses a code block parsing expression.
parseParserCode = {/
    closure = parseNullaryClosure
    { <> @["{}" = tokenValue(closure) ] }
/};

# Parses a predicate parsing expression.
parseParserPredicate = {/
    @"&&"
    predicate = parseParenExpression
    { <> @["&&" = predicate] }
/};

# Parses an atomic parsing expression.
parseParserAtom = {/
    parseVarRef
|
    parseParserString
|
    parseParserToken
|
    parseParserSet
|
    parseParserCode
|
    parseParserPredicate
|
    @"."
|
    @"()"
|
    parseParenPex
/};

# Parses a repeat (or not) parsing expression.
parseRepeatPex = {/
    atom = parseParserAtom
    (
        repeat = [@"?" @"*" @"+"]
        { <> @[tokenType(repeat) = atom] }
    |
        { <> atom }
    )
/};

# Parses a lookahead (or not) parsing expression. This covers both lookahead
# success and lookahead failure.
parseLookaheadPex = {/
    (
        lookahead = [@"&" @"!"]
        pex = parseRepeatPex
        { <> @[tokenType(lookahead) = pex] }
    )
|
    parseRepeatPex
/};

# Parses a name (or not) parsing expression.
parseNamePex = {/
    (
        name = @identifier
        @"="
        pex = parseLookaheadPex
        { <> @["varDef" = ["name"=tokenValue(name), "value"=pex]] }
    )
|
    parseLookaheadPex
/};

# Parses a sequence parsing expression. This includes sequences of length
# one, but it does *not* parse empty (zero-length) sequences.
parseSequencePex = {/
    items = parseNamePex+
    { <> @["sequence" = items] }
/};

# Parses a choice parsing expression. This includes a single choice.
implChoicePex = {/
    first = parseSequencePex
    rest = (@"|" parseSequencePex)*
    { <> @["choice" = listPrepend(first, rest)] }
/};
parseChoicePex(implChoicePex);


#
# Samizdat Layer 2 definitions
#

# Parses a closure which must have neither formal arguments nor a yield
# definition. See `parseNullaryClosure` above for discussion.
parseCodeOnlyClosure = {/
    closure = parseNullaryClosure

    {
        ifTrue { <> mapHasKey(tokenValue(closure), "yieldDef") }
            { io0Die("Invalid yield definition in code block.") };
        <> closure
    }
/};

# Common parsing for `fn` statements and expressions. The syntax for
# both is identical, except that the statement form requires that the
# function be named. The result of this rule is a map identical in form to
# a closure payload, except that `name` may also be bound.
#
# If `name` is *not* bound, the result is suitable for use as a `closure` node
# payload. And if `name` *is* bound, it is valid to use the result as the
# payload for a `fnDef` node.
#
# The translation is along these lines:
#
# ```
# fn <out> name(arg1, arg2) { stat1; stat2 }
# ```
#
# ```
# {/ arg1 arg2 <\"return"> ::
#     out = \"return";
#     stat1;
#     stat2
# /}
# ```
#
# with:
#
# * no yield def binding statement if an explicit yield def was not present.
#
# * the key `name` bound to the function name, if a name was defined. (This
#   is not representable in lower-layer surface syntax.)
parseFnCommon = {/
    @"fn"

    # This is a variable definition statement which binds the yield def
    # name to the `return` function, if there is in fact a yield def present.
    returnDef = (
        y = parseOptYieldDef
        {
            <> ifValue { <> mapGet(y, "yieldDef") }
                { yieldName :: <> makeVarDef(yieldName, makeVarRef("return")) }
        }
    )?

    name = (
        n = @identifier
        { <> ["name" = n] }
    |
        { <> [=] }
    )

    formals = (
        @"()"
        { <> [=] }
    |
        @"("
        f = parseFormalsList
        @")"
        { <> f }
    )

    code = parseCodeOnlyClosure

    {
        codeMap = tokenValue(code);
        statements = listAdd(returnDef, mapGet(codeMap, "statements"));
        <> mapAdd(codeMap, name, formals,
            ["yieldDef"="return", "statements"=statements])
    }
/};

# Parses a non-local exit / return. All of the form matched by this rule
# have the dual properties of (a) necessarily being at the end of a code
# block, and (b) being represented as a function call in the underlying
# function representation of code blocks.
implNonlocalExit = {/
    @"<"
    name = parseVarRef
    @">"
    value = parseExpression?
    { <> apply(makeCallNonlocalExit, name, value) }
|
    op = [@"break" @"return"]
    value = parseExpression?
    { <> apply(makeCallNonlocalExit, makeVarRef(tokenType(op)), value) }
|
    # This one is separate from `break` and `return`, because it doesn't
    # accept a value.
    @"continue"
    { <> makeCallNonlocalExit(makeVarRef("continue")) }
/};
parseNonlocalExit(implNonlocalExit);

# Parses a unary prefix operator. This yields a `varRef` node for the function
# to apply when applying the prefix.
parsePrefixOperator = {/
    operator = [@"+" @"-" @"!" @"!!!"]
    { <> mapGet(UNARY_OPERATORS, tokenType(operator)) }
/};

# Parses a unary postfix operator. This yields a function (per se) to call
# in order to construct a node that represents the appropriate ultimate
# function call.
parsePostfixOperator = {/
    actuals = parseActualsList
    { <> { node :: <> apply(makeCall, node, actuals) } }
|
    @"["
    exprs = parseUnadornedList
    &&(ne(exprs, []))
    @"]"
    {
        function = mapGet(UNARY_OPERATORS, "[]");
        <> { node :: <> apply(makeCall, function, node, exprs) }
    }
/};

# Parses a unary expression. This is an atom, optionally surrounded on
# either side by any number of unary operators. Postfix operators
# take precedence over (are applied before) the prefix operators.
parseUnaryExpression = {/
    prefixes = parsePrefixOperator*
    atom = parseAtom
    postfixes = parsePostfixOperator*

    {
        withPosts = listReduce(atom, postfixes)
            { result, ., postfix :: <> postfix(result) };
        <> listReduce(withPosts, listReverse(prefixes))
            { result, ., prefix :: <> makeCall(prefix, result) }
    }
/};

# Parses a multiplicative expression. (Binary infix operator expressions
# are listed from tightest to loosest binding / precedence.)
parseMulExpression = {/
    firstEx = parseUnaryExpression
    opExes = (
        op = [@"*" @"/" @"%" @"<<<" @">>>"]
        ex = parseUnaryExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses an additive expression.
parseAddExpression = {/
    firstEx = parseMulExpression
    opExes = (
        op = [@"+" @"-" @"&&&" @"|||" @"^^^"]
        ex = parseMulExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses a comparison expression. The syntax here is the mathematical
# style of `x < y < z` meaning `x < y && y < z`, supported by the
# `compareChain` library function.
parseCompareExpression = {/
    firstEx = parseAddExpression
    opExes = (
        op = [
            @"=="   @"!="   @"<"   @">"   @"<="   @">="
            @"\\==" @"\\!=" @"\\<" @"\\>" @"\\<=" @"\\>="
        ]
        ex = parseAddExpression
        { <> [op, ex] }
    )*

    (
        # No actual comparisons (just a simple pass-through to `addExpression`).
        &&(eq(lowSize(opExes), 0))
        { <> firstEx }
    |
        # Just one operator, so no need to chain.
        &&(eq(lowSize(opExes), 1))
        { <> makeBinaryCalls(firstEx, opExes) }
    |
        # The general case of two or more comparison operators.
        {
            # Make separate ops and exes arrays.
            arrays = listReduce([[], []], opExes) { result, ., one ::
                ops = listFirst(result);
                exes = listLast(result);
                op = mapGet(BINARY_OPERATORS, tokenType(listFirst(one)));
                ex = listLast(one);
                <> [listAppend(ops, op), listAppend(exes, ex)]
            };
            ops = apply(makeCallName, "makeList", listFirst(arrays));
            exes = listLast(arrays);

            <> apply(makeCallName, "compareChain", ops, firstEx, exes);
        }
    )
/};

# Parses a short-circuit logical-and expression.
parseAndExpression = {/
    first = parseCompareExpression
    rest = (@"&&" parseCompareExpression)*

    (
        # Not actually a logical-and expression.
        &&(eq(lowSize(rest), 0))
        { <> first }
    |
        { <> apply(makeCallNameThunks, "and", first, rest) }
    )
/};

# Parses a short-circuit logical-or expression.
parseOrExpression = {/
    first = parseAndExpression
    rest = (@"||" parseAndExpression)*

    (
        # Not actually a logical-or expression.
        &&(eq(lowSize(rest), 0))
        { <> first }
    |
        { <> apply(makeCallNameThunks, "or", first, rest) }
    )
/};

# Parses an if expression.
parseIfExpression = {/
    @"if"
    firstCondition = parseParenExpression
    firstThen = parseNullaryClosure

    elseIfThens = (
        @"else"
        @"if"
        condition = parseParenExpression
        then = parseNullaryClosure
        { <> [condition, then] }
    )*

    finalElse = (
        @"else"
        parseClosure
    )?

    (
        # Unchained if-then or if-then-else.
        &&(eq(lowSize(elseIfThens), 0))
        {
            <> apply(makeCallName, "ifTrue",
                makeThunk(firstCondition), firstThen, finalElse)
        }
    |
        # General chained form.
        {
            # Make separate conditions and thens arrays.
            arrays = listReduce(
                [[makeThunk(firstCondition)], [firstThen]],
                elseIfThens)
                { result, ., one ::
                    conditions = listFirst(result);
                    thens = listLast(result);
                    condition = makeThunk(listFirst(one));
                    then = listLast(one);
                    <> [
                        listAppend(conditions, condition),
                        listAppend(thens, then)
                    ]
                };

            conditions = apply(makeCallName, "makeList", listFirst(arrays));
            thens = listAdd(listLast(arrays), finalElse);

            <> apply(makeCallName, "ifChain", conditions, thens);
        }
    )
/};

# Parses the optional yield definition that's associated with the `break`
# exit of a loop. This always results in a list, which is empty if there
# is no yield definition present, or is a single-element list of an
# appropriate variable definition and assignment.
parseOptBreakDef = {/
    y = parseOptYieldDef

    {
        <> ifTrue { <> ne(y, [=]) }
            { <> makeVarDef(mapValue(y), makeVarRef("break")) }
    }?
/};

# Parses a while expression. The translation is along these lines:
#
# ```
# while (expr) <out> { <next> :: stat1; stat2 }
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     loop { <\"continue"> ::
#         ifTrue { <> expr }
#             { <next> :: stat1; stat2 }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def.
parseWhileExpression = {/
    @"while"
    breakDef = parseOptBreakDef
    condition = parseParenExpression
    code = parseNullaryClosure

    {
        loopClosure = @["closure" = [
            "yieldDef" = "continue",
            "statements" = [
                makeCallName("ifTrue",
                    makeThunk(condition),
                    code,
                    makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
            ]
        ]];

        mainClosure = @["closure" = [
            "yieldDef" = "break",
            "statements" = listAppend(breakDef,
                makeCallName("loop", loopClosure)
            )
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a do expression. The translation is along these lines:
#
# ```
# do <out> { <next> :: stat1; stat2 } while (expr)
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     loop { <\"continue"> ::
#         { <next> :: stat1; stat2 }();
#         ifFalse { <> expr }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def, and
# with the `ifFalse` statement omitted if there is no `while` at the end
# of the `do`.
parseDoExpression = {/
    @"do"
    breakDef = parseOptBreakDef
    code = parseNullaryClosure
    condition = (
        @"while"
        ex = parseParenExpression
        {
            <> makeCallName("ifFalse",
                makeThunk(ex),
                makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
        }
    )?

    {
        loopClosure = @["closure" = [
            "yieldDef" = "continue",
            "statements" = listPrepend(makeCall(code), condition)
        ]];

        mainClosure = @["closure" = [
            "yieldDef" = "break",
            "statements" = listAppend(breakDef,
                makeCallName("loop", loopClosure)
            )
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a `fn` (function with `return` binding) expression. The translation
# is as described in `parseFnCommon` (above) if the function is not given a
# name. If the function *is* given a name, the translation is along the
# following lines:
#
# ```
# fn <out> name(arg1, arg2) { stat1; stat2 }
# ```
#
# =>
#
# ```
# {/
#     name = forwardFunction();
#     <> name {/ arg1 arg2 <\"return"> ::
#         out = \"return";
#         stat1;
#         stat2
#     /}
# /}()
# ```
parseFnExpression = {/
    funcMap = parseFnCommon
    closure = { <> @["closure" = funcMap] }

    (
        name = { <> mapGet(funcMap, "name") }
        {
            mainClosure = @["closure" = [
                "statements" = [
                    makeVarDef(name, makeCallName("forwardFunction"))
                ],
                "yield" = makeCall(name, closure)
            ]];

            <> makeCall(mainClosure)
        }
    |
        { <> closure }
    )
/};

# Parses a general expression.
implExpression = {/
    parseOrExpression
|
    parseIfExpression
|
    parseWhileExpression
|
    parseDoExpression
|
    parseFnExpression
/};
parseExpression(implExpression);


#
# Exported functions
#

# Documented in Samizdat Layer 1 spec.
sam2Tree = { program ::
    tokens = ifTrue { <> isString(program) }
        { <> sam2Tokenize(program) }
        { <> program };

    <> pegApply(parseProgramOrError, tokens)
};

<> [
    "sam2Tree" = sam2Tree
]
