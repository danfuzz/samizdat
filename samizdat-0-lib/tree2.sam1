# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 2 Tree Parser
#


#
# Helper definitions
#

# Returns a `call` node.
makeCall = { function actuals* ::
    <> @["call" = ["function"=function, "actuals"=actuals]]
};

# Returns a `varDef` node.
makeVarDef = { name value ::
    <> @["varDef" = ["name"=name, "value"=value]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @["varRef" = name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name actuals* ::
    <> @["call" = ["function"=makeVarRef(name), "actuals"=actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @["literal" = value]
};

# Returns node representing a thunk (no-arg function) that returns the
# expression represented by the given node.
makeThunk = { expression ::
    <> @["function" = ["statements"=[], "yield"=expression]]
};

# Returns a `call` node that names a function as a `varRef` and passes
# "thunked" versions of each of the given actual arguments.
makeCallNameThunks = { name actuals* ::
    thunks = listMap(actuals) { . one :: <> makeThunk(one) };
    <> apply(makeCallName, name, thunks)
};

# Returns a `call` node to a nonlocal exit with the given name and
# with optional expression value. The expression if supplied is automatically
# "thunked".
makeCallNonlocalExit = { name expression? ::
    <> ifValue { <> listFirst(expression) }
        { ex :: <> makeCall(makeVarRef("nonlocalExit"), name, makeThunk(ex)) }
        { <> makeCall(makeVarRef("nonlocalExit"), name) }
};

# Map of token types to corresponding unary operator function name variable
# references.
UNARY_OPERATORS = listReduce([=], ["+", "-", "!", "[]", "!!!"])
    { result . name ::
        <> mapPut(result, name, makeVarRef(stringAdd("unary", name)))
    };

# Map of token types to corresponding binary operator function name variable
# references.
BINARY_OPERATORS = listReduce([=],
    [
        "+", "-", "*", "/", "%",
        "&&&", "|||", "^^^", "<<<", ">>>",
        "==", "!=", "<", ">", "<=", ">=",
        "\\==", "\\!=", "\\<", "\\>", "\\<=", "\\>="
    ]
    )
    { result . name ::
        <> mapPut(result, name, makeVarRef(stringAdd("binary", name)))
    };

# Helper for parsing binary operator expressions, which puts together
# a sequence of function calls.
makeBinaryCalls = { firstEx opExList ::
    <> listReduce(firstEx, opExList) { result . opEx ::
        op = listFirst(opEx);
        ex = listLast(opEx);
        <> makeCall(mapGet(BINARY_OPERATORS, tokenType(op)), result, ex)
    }
};

# Reports the given list of pending tokens as part of error processing.
reportError = { pending ::
    io0Note("Pending tokens:");

    listForEach(pending)
        { . token :: io0Note(format("    %q", token)) };

    io0Die("\nExtra tokens at end of program.")
};


#
# Grammar rules
#

#
# Main language definitions
#

# Forward declarations.
parseExpression = forwardFunction();
parseFunction = forwardFunction();
parseParser = forwardFunction();

# Parses an integer literal.
parseInt = {/
    i = @int
    { <> makeLiteral(tokenValue(i)) }
/};

# Parses a string literal.
parseString = {/
    s = @string
    { <> makeLiteral(tokenValue(s)) }
/};

# Parses an "unadorned" (no bracketing) list. Yields a list (per se)
# of contents.
parseUnadornedList = {/
    first = parseExpression
    rest = (@"," parseExpression)*
    { <> listPrepend(first, rest) }
|
    { <> [] }
/};

# Parses a list literal.
parseList = {/
    @"["
    expressions = parseUnadornedList
    @"]"
    {
        <> ifTrue { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> apply(makeCallName, "makeList", expressions) }
    }
/};

# Parses an empty map literal.
parseEmptyMap = {/
    @"[" @"=" @"]"
    { <> makeLiteral([=]) }
/};

# Parses a mapping (element of a map).
parseMapping = {/
    key = parseExpression
    @"="
    value = parseExpression
    { <> [key, value] }
/};

# Parses a map literal.
parseMap = {/
    @"["
    first = parseMapping
    rest = (@"," parseMapping)*
    @"]"
    {
        mappings = apply(listAdd, first, rest);
        <> apply(makeCallName, "makeMap", mappings)
    }
/};

# Parses a token literal.
parseToken = {/
    @"@"
    (
        @"["
        type = parseExpression
        value = (@"=" parseExpression)?
        @"]"
        { <> apply(makeCallName, "makeToken", type, value) }
    |
        type = [@string @identifier]
        { <> makeCallName("makeToken", makeLiteral(tokenValue(type))) }
    )
/};

# Parses a uniqlet literal.
parseUniqlet = {/
    @"@@"
    { <> makeCallName("makeUniqlet") }
/};

# Parses a variable reference.
parseVarRef = {/
    name = @identifier
    { <> makeVarRef(tokenValue(name)) }
/};

# Parses a variable definition.
parseVarDef = {/
    name = @identifier
    @"="
    ex = parseExpression
    { <> makeVarDef(tokenValue(name), ex) }
/};

# Parses a parenthesized expression.
parseParenExpression = {/
    @"("
    ex = parseExpression
    @")"
    { <> ex }
/};

# Parses an atomic expression.
parseAtom = {/
    parseVarRef | parseInt | parseString |
    parseList | parseEmptyMap | parseMap |
    parseUniqlet | parseToken | parseFunction | parseParenExpression |
    # Defined by Samizdat Layer 1.
    &@"{/" parseParser
/};

# Parses a yield / non-local exit definition.
parseYieldDef = {/
    @"<"
    name = @identifier
    @">"
    { <> tokenValue(name) }
/};

# Parses a list of "actual" (as opposed to formal) arguments to a function.
# Yields a list of expression nodes.
parseActualsList = {/
    @"()"
    parseFunction*
|
    @"("
    normalActuals = parseUnadornedList
    @")"
    functionActuals = parseFunction*
    { <> listAdd(normalActuals, functionActuals) }
|
    parseFunction+
/};

# Parses a unary prefix operator. This yields a `varRef` node for the function
# to apply when applying the prefix.
parsePrefixOperator = {/
    operator = [@"+" @"-" @"!" @"!!!"]
    { <> mapGet(UNARY_OPERATORS, tokenType(operator)) }
/};

# Parses a unary postfix operator. This yields a function (per se) to call
# in order to construct a node that represents the appropriate ultimate
# function call.
parsePostfixOperator = {/
    actuals = parseActualsList
    { <> { node :: <> apply(makeCall, node, actuals) } }
|
    @"["
    exprs = parseUnadornedList
    &&(ne(exprs, []))
    @"]"
    {
        function = mapGet(UNARY_OPERATORS, "[]");
        <> { node :: <> apply(makeCall, function, node, exprs) }
    }
/};

# Parses a unary expression. This is an atom, optionally surrounded on
# either side by any number of unary operators. Postfix operators
# take precedence over (are applied before) the prefix operators.
parseUnaryExpression = {/
    prefixes = parsePrefixOperator*
    atom = parseAtom
    postfixes = parsePostfixOperator*

    {
        withPosts = listReduce(atom, postfixes)
            { result . postfix :: <> postfix(result) };
        <> listReduce(withPosts, listReverse(prefixes))
            { result . prefix :: <> makeCall(prefix, result) }
    }
/};

# Parses a multiplicative expression. (Binary infix operator expressions
# are listed from tightest to loosest binding / precedence.)
parseMulExpression = {/
    firstEx = parseUnaryExpression
    opExes = (
        op = [@"*" @"/" @"%"]
        ex = parseUnaryExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses an additive expression.
parseAddExpression = {/
    firstEx = parseMulExpression
    opExes = (
        op = [@"+" @"-"]
        ex = parseMulExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses an bitwise expression.
parseBitExpression = {/
    firstEx = parseAddExpression
    opExes = (
        op = [@"&&&" @"|||" @"^^^" @"<<<" @">>>"]
        ex = parseAddExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses a comparison expression. The syntax here is the mathematical
# style of `x < y < z` meaning `x < y && y < z`, supported by the
# `compareChain` library function.
parseCompareExpression = {/
    firstEx = parseBitExpression
    opExes = (
        op = [
            @"=="   @"!="   @"<"   @">"   @"<="   @">="
            @"\\==" @"\\!=" @"\\<" @"\\>" @"\\<=" @"\\>="
        ]
        ex = parseBitExpression
        { <> [op, ex] }
    )*

    (
        # Not actually a comparison expression.
        &&(eq(lowSize(opExes), 0))
        { <> firstEx }
    |
        # Just one operator, so no need to chain.
        &&(eq(lowSize(opExes), 1))
        { <> makeBinaryCalls(firstEx, opExes) }
    |
        # The general case of two or more comparison operators.
        {
            # Make separate ops and exes arrays.
            arrays = listReduce([[], []], opExes) { result . one ::
                ops = listFirst(result);
                exes = listLast(result);
                op = mapGet(BINARY_OPERATORS, tokenType(listFirst(one)));
                ex = listLast(one);
                <> [listAppend(ops, op), listAppend(exes, ex)]
            };
            ops = apply(makeCallName, "makeList", listFirst(arrays));
            exes = listLast(arrays);

            <> apply(makeCallName, "compareChain", ops, firstEx, exes);
        }
    )
/};

# Parses a short-circuit logical-and expression.
parseAndExpression = {/
    first = parseCompareExpression
    rest = (@"&&" parseCompareExpression)*

    (
        # Not actually a logical-and expression.
        &&(eq(lowSize(rest), 0))
        { <> first }
    |
        { <> apply(makeCallNameThunks, "and", first, rest) }
    )
/};

# Parses a short-circuit logical-or expression.
parseOrExpression = {/
    first = parseAndExpression
    rest = (@"||" parseAndExpression)*

    (
        # Not actually a logical-or expression.
        &&(eq(lowSize(rest), 0))
        { <> first }
    |
        { <> apply(makeCallNameThunks, "or", first, rest) }
    )
/};

# Parses an if expression.
parseIfExpression = {/
    @"if"
    firstCondition = parseParenExpression
    firstThen = parseFunction

    elseIfThens = (
        @"else"
        @"if"
        condition = parseParenExpression
        then = parseFunction
        { <> [condition, then] }
    )*

    finalElse = (
        @"else"
        parseFunction
    )?

    (
        # Unchained if-then or if-then-else.
        &&(eq(lowSize(elseIfThens), 0))
        {
            <> apply(makeCallName, "ifTrue",
                makeThunk(firstCondition), firstThen, finalElse)
        }
    |
        # General chained form.
        {
            # Make separate conditions and thens arrays.
            arrays = listReduce(
                [[makeThunk(firstCondition)], [firstThen]],
                elseIfThens)
                { result . one ::
                    conditions = listFirst(result);
                    thens = listLast(result);
                    condition = makeThunk(listFirst(one));
                    then = listLast(one);
                    <> [
                        listAppend(conditions, condition),
                        listAppend(thens, then)
                    ]
                };

            conditions = apply(makeCallName, "makeList", listFirst(arrays));
            thens = listAdd(listLast(arrays), finalElse);

            <> apply(makeCallName, "ifChain", conditions, thens);
        }
    )
/};

# Parses a while expression. The translation is along these lines:
#
# ```
# while (expr) <out> { <next> :: stat1; stat2 }
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     loop { <\"continue"> ::
#         ifTrue { <> expr }
#             { <next> :: stat1; stat2 }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def.
parseWhileExpression = {/
    @"while"
    yieldDef = (
        y = parseYieldDef
        { <> makeVarDef(y, makeVarRef("break")) }
    )?
    condition = parseParenExpression
    code = parseFunction

    {
        loopFunction = @["function" = [
            "yieldDef" = "continue",
            "statements" = [
                makeCallName("ifTrue",
                    makeThunk(condition),
                    code,
                    makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
            ]
        ]];

        mainFunction = @["function" = [
            "yieldDef" = "break",
            "statements" = listAppend(yieldDef,
                makeCallName("loop", loopFunction)
            )
        ]];

        <> makeCall(mainFunction)
    }
/};

# Parses a do expression. The translation is along these lines:
#
# ```
# do <out> { <next> :: stat1; stat2 } while (expr)
# ```
#
# =>
#
# ```
# { <\"break"> ::
#     out = \"break";
#     loop { <\"continue"> ::
#         { <next> :: stat1; stat2 }();
#         ifFalse { <> expr }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def, and
# with the `ifFalse` statement omitted if there is no `while` at the end
# of the `do`.
parseDoExpression = {/
    @"do"
    yieldDef = (
        y = parseYieldDef
        { <> makeVarDef(y, makeVarRef("break")) }
    )?
    code = parseFunction
    condition = (
        @"while"
        ex = parseParenExpression
        {
            <> makeCallName("ifFalse",
                makeThunk(ex),
                makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
        }
    )?

    {
        loopFunction = @["function" = [
            "yieldDef" = "continue",
            "statements" = listPrepend(makeCall(code), condition)
        ]];

        mainFunction = @["function" = [
            "yieldDef" = "break",
            "statements" = listAppend(yieldDef,
                makeCallName("loop", loopFunction)
            )
        ]];

        <> makeCall(mainFunction)
    }
/};

# Parses a general expression.
implExpression = {/
    parseOrExpression
|
    parseIfExpression
|
    parseWhileExpression
|
    parseDoExpression
/};
parseExpression(implExpression);

# Parses a statement.
parseStatement = {/
    parseVarDef | parseExpression
/};

# Parses a non-local exit / return. All of the form matched by this rule
# have the dual properties of (a) necessarily being at the end of a code
# block, and (b) being represented as a function call in the underlying
# function representation of code blocks.
parseNonlocalExit = {/
    @"<"
    name = parseVarRef
    @">"
    value = parseExpression?
    { <> apply(makeCallNonlocalExit, name, value) }
|
    @"break"
    value = parseExpression?
    { <> apply(makeCallNonlocalExit, makeVarRef("break"), value) }
|
    @"continue"
    { <> makeCallNonlocalExit(makeVarRef("continue")) }
/};

# Parses a local yield / return.
parseYield = {/
    @"<>"
    (
        ex = parseExpression
        { <> ["yield" = ex] }
    |
        { <> [=] }
    )
/};

# Parses a formal argument decalaration.
parseFormal = {/
    name = (
        n = @identifier
        { <> ["name" = tokenValue(n)] }
    |
        @"." { <> [=] }
    )

    repeat = (
        r = [@"?" @"*" @"+"]
        { <> ["repeat" = tokenType(r)] }
    |
        { <> [=] }
    )

    { <> mapAdd(name, repeat) }
/};

# Parses a program body (statements plus optional yield).
parseProgramBody = {/
    @";"*

    most = (
        s = parseStatement
        @";"+
        { <> s }
    )*

    last = (
        s = (parseStatement | parseNonlocalExit)
        { <> ["statements" = [s]] }
    |
        y = parseYield
        { <> mapAdd(["statements" = []], y) }
    |
        { <> ["statements" = []] }
    )

    @";"*

    {
        allStatements = listAdd(most, mapGet(last, "statements"));
        <> mapPut(last, "statements", allStatements)
    }
/};

# Parses program / function declarations.
parseProgramDeclarations = {/
    formals = (
        fs = parseFormal+
        { <> ["formals" = fs] }
    |
        { <> [=] }
    )

    yieldDef = (
        y = parseYieldDef
        { <> ["yieldDef" = y] }
    |
        { <> [=] }
    )

    @"::"

    { <> mapAdd(formals, yieldDef) }
/};

# Parses a program (top-level program or contents inside function braces).
parseProgram = {/
    decls = (parseProgramDeclarations | { <> [=] })
    body = parseProgramBody
    { <> @["function" = mapAdd(decls, body)] }
/};

# Parses a function (in-line anonymous function).
implFunction = {/
    @"{"
    prog = parseProgram
    @"}"
    { <> prog }
/};
parseFunction(implFunction);

# Top-level rule to parse a program with possible error afterwards.
# Note that an empty string is a valid program.
parseProgramOrError = {/
    prog = parseProgram
    (
        pending = .+
        { reportError(pending) }
    )?
    { <> prog }
/};


#
# Parser language definitions
#

# Forward declaration.
parseChoicePex = forwardFunction();

# Parse a parser function.
implParser = {/
    @"{/"
    pex = parseChoicePex
    @"/}"
    { <> @["parser" = pex] }
/};
parseParser(implParser);

# Parse a parenthesized parsing expression.
parseParenPex = {/
    @"("
    pex = parseChoicePex
    @")"
    { <> pex }
/};

# Parse a string literal parsing expression.
parseParserString = {/
    s = @string
    {
        value = tokenValue(s);
        <> ifTrue { <> eq(lowSize(value), 1) }
            { <> @["token" = value] }
            { <> s }
    }
/};

# Parse a token literal parsing expression.
parseParserToken = {/
    @"@"
    type = [@identifier @string]
    { <> @["token" = tokenValue(type)] }
/};

# Parse a string or character range parsing expression, used when defining
# sets.
parseParserSetString = {/
    s = @string
    (
        @".."
        startInt = {
            startValue = tokenValue(s);
            <> ifTrue { <> eq(lowSize(startValue), 1) }
                { <> intFromString(startValue) }
        }
        end = @string
        endInt = {
            endValue = tokenValue(end);
            <> ifTrue { <> eq(lowSize(endValue), 1) }
                { <> intFromString(endValue) }
        }
        {
            loopReduce([startInt, ""]) { result ::
                at = listFirst(result);
                soFar = listLast(result);
                ifTrue { <> gt(at, endInt) } { <out> @["string" = soFar] };
                <> [iadd(at, 1), stringAdd(soFar, stringFromInt(at))]
            }
        }
    |
        { <> s }
    )
/};

# Parse a set (or set complement) parsing expression.
parseParserSet = {/
    @"["

    type = (
        @"!" { <> "[!]" }
    |
        { <> "[]" }
    )

    terminals = (
        strings = parseParserSetString+
        {
            oneString = listReduce("", strings)
                { result . s :: <> stringAdd(result, tokenValue(s)) };
            <> stringReduce([], oneString)
                { result . ch :: <> listAppend(result, ch) }
        }
    |
        tokens = parseParserToken+
        { <> listMap(tokens) { . t :: <> tokenValue(t) } }
    |
        { <> [] }
    )

    @"]"

    { <> @[type = terminals] }
/};

# Parse a code block parsing expression.
parseParserCode = {/
    @"{"

    yieldDef = (
        y = parseYieldDef
        @"::"
        { <> ["yieldDef" = y] }
    |
        @"::"?
        { <> [=] }
    )

    body = parseProgramBody
    @"}"

    { <> @["{}" = mapAdd(yieldDef, body)] }
/};

# Parse a predicate parsing expression.
parseParserPredicate = {/
    @"&&"
    predicate = parseParenExpression
    { <> @["&&" = predicate] }
/};

# Parse an atomic parsing expression.
parseParserAtom = {/
    parseVarRef
|
    parseParserString
|
    parseParserToken
|
    parseParserSet
|
    parseParserCode
|
    parseParserPredicate
|
    @"."
|
    @"()"
|
    parseParenPex
/};

# Parse a repeat (or not) parsing expression.
parseRepeatPex = {/
    atom = parseParserAtom
    (
        repeat = [@"?" @"*" @"+"]
        { <> @[tokenType(repeat) = atom] }
    |
        { <> atom }
    )
/};

# Parse a lookahead (or not) parsing expression. This covers both lookahead
# success and lookahead failure.
parseLookaheadPex = {/
    (
        lookahead = [@"&" @"!"]
        pex = parseRepeatPex
        { <> @[tokenType(lookahead) = pex] }
    )
|
    parseRepeatPex
/};

# Parse a name (or not) parsing expression.
parseNamePex = {/
    (
        name = @identifier
        @"="
        pex = parseLookaheadPex
        { <> @["varDef" = ["name"=tokenValue(name), "value"=pex]] }
    )
|
    parseLookaheadPex
/};

# Parse a sequence parsing expression. This includes a sequence of length
# one.
parseSequencePex = {/
    items = parseNamePex+
    { <> @["sequence" = items] }
/};

# Parse a choice parsing expression. This includes a single choice.
implChoicePex = {/
    first = parseSequencePex
    rest = (@"|" parseSequencePex)*
    { <> @["choice" = listPrepend(first, rest)] }
/};
parseChoicePex(implChoicePex);


#
# Exported functions
#

# Documented in Samizdat Layer 1 spec.
sam2Tree = { program ::
    tokens = ifTrue { <> isString(program) }
        { <> sam2Tokenize(program) }
        { <> program };

    <> pegApply(parseProgramOrError, tokens)
};

<> [
    "sam2Tree" = sam2Tree
]
