# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 2 Tree Parser
#


#
# Helper functions
#

# Returns a `call` node.
makeCall = { function actuals* ::
    <> @["call" = ["function"=function, "actuals"=actuals]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @["varRef" = name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name actuals* ::
    <> @["call" = ["function"=makeVarRef(name), "actuals"=actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @["literal" = value]
};

# Reports the given list of pending tokens as part of error processing.
reportError = { pending ::
    io0Note("Pending tokens:");

    listForEach(pending)
        { . token :: io0Note(format("    %q", token)) };

    io0Die("\nExtra tokens at end of program.")
};


#
# Grammar rules
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations.
parseAtom = forwardFunction();
parseExpression = forwardFunction();
parseFunction = forwardFunction();
parseParser = forwardFunction();

# Parses an integer literal.
parseInt = {/
    i = @int
    { <> makeLiteral(tokenValue(i)) }
/};

# Parses a string literal.
parseString = {/
    s = @string
    { <> makeLiteral(tokenValue(s)) }
/};

# Parses an empty list literal.
parseEmptyList = {/
    @"[" @"]"
    { <> makeLiteral([]) }
/};

# Parses an "unadorned" (no bracketing) list. Yields a list (per se)
# of contents.
parseUnadornedList = {/
    first = parseExpression
    rest = (@"," parseExpression)*
    { <> listPrepend(first, rest) }
|
    { <> [] }
/};

# Parses a list literal.
parseList = {/
    @"["
    atoms = parseAtom+
    @"]"
    { <> apply(makeCallName, "makeList", atoms) }
/};

# Parses an empty map literal.
parseEmptyMap = {/
    @"[" @"=" @"]"
    { <> makeLiteral([=]) }
/};

# Parses a mapping (element of a map).
parseMapping = {/
    key = parseAtom
    @"="
    value = parseAtom
    { <> [key, value] }
/};

# Parses a map literal.
parseMap = {/
    @"["
    mappings = parseMapping+
    @"]"
    { <> apply(makeCallName, "makeMap", apply(listAdd, mappings)) }
/};

# Parses a token literal.
parseToken = {/
    @"@"
    (
        @"[" type=parseAtom value=parseAtom? @"]"
        { <> apply(makeCallName, "makeToken", type, value) }
    |
        type = [@string @identifier]
        { <> makeCallName("makeToken", makeLiteral(tokenValue(type))) }
    )
/};

# Parses a uniqlet literal.
parseUniqlet = {/
    @"@@"
    { <> makeCallName("makeUniqlet") }
/};

# Parses a variable reference.
parseVarRef = {/
    name = @identifier
    { <> makeVarRef(tokenValue(name)) }
/};

# Parses a variable definition.
parseVarDef = {/
    name = @identifier
    @"="
    ex = parseExpression
    { <> @["varDef" = ["name"=tokenValue(name), "value"=ex]] }
/};

# Parses a parenthesized expression.
parseParenExpression = {/
    @"("
    ex = parseExpression
    @")"
    { <> ex }
/};

# Parses an atomic expression.
implAtom = {/
    parseVarRef | parseInt | parseString |
    parseEmptyList | parseList | parseEmptyMap | parseMap |
    parseUniqlet | parseToken | parseFunction | parseParenExpression |
    # Defined by Samizdat Layer 1.
    &@"{/" parseParser
/};
parseAtom(implAtom);

# Parses a list of "actual" (as opposed to formal) arguments to a function.
# Yields a list of expression nodes.
parseActualsList = {/
    @"()"
    parseFunction*
|
    @"("
    normalActuals = parseUnadornedList
    @")"
    functionActuals = parseFunction*
    { <> listAdd(normalActuals, functionActuals) }
|
    parseFunction+
/};

# Parses a unary prefix operator. This yields a `varRef` node for the function
# to apply when applying the prefix.
parsePrefixOperator = {/
    operator = [@"+" @"-" @"!"]
    { <> makeVarRef(stringAdd("unary", tokenType(operator))) }
/};

# Parses a unary postfix operator. This yields a function (per se) to call
# in order to construct a node that represents the appropriate ultimate
# function call.
parsePostfixOperator = {/
    actuals = parseActualsList
    { <> { node :: <> apply(makeCall, node, actuals) } }
|
    @"["
    atoms = parseAtom+
    @"]"
    { <> { node :: <> apply(makeCall, makeVarRef("unary[]"), node, atoms) } }
/};

# Parses a unary expression. This is an atom, optionally surrounded on
# either side by any number of unary operators. Postfix operators
# take precedence over (are applied before) the prefix operators.
parseUnaryExpression = {/
    prefixes = parsePrefixOperator*
    atom = parseAtom
    postfixes = parsePostfixOperator*

    {
        withPosts = listReduce(atom, postfixes)
            { result . postfix :: <> postfix(result) };
        <> listReduce(withPosts, listReverse(prefixes))
            { result . prefix :: <> makeCall(prefix, result) }
    }
/};

# Parses a general expression.
implExpression = parseUnaryExpression;
parseExpression(implExpression);

# Parses a statement.
parseStatement = {/
    parseVarDef | parseExpression
/};

# Parses a non-local exit / return.
parseNonlocalExit = {/
    @"<"
    name = parseVarRef
    @">"
    ex = parseExpression?
    { <> apply(makeCall, name, ex) }
/};

# Parses a local yield / return.
parseYield = {/
    @"<>"
    (
        ex = parseExpression
        { <> ["yield" = ex] }
    |
        { <> [=] }
    )
/};

# Parses a yield / non-local exit definition.
parseYieldDef = {/
    @"<"
    name = @identifier
    @">"
    { <> tokenValue(name) }
/};

# Parses a formal argument decalaration.
parseFormal = {/
    name = (
        n = @identifier
        { <> ["name" = tokenValue(n)] }
    |
        @"." { <> [=] }
    )

    repeat = (
        r = [@"?" @"*" @"+"]
        { <> ["repeat" = tokenType(r)] }
    |
        { <> [=] }
    )

    { <> mapAdd(name, repeat) }
/};

# Parses a program body (statements plus optional yield).
parseProgramBody = {/
    @";"*

    most = (
        s = parseStatement
        @";"+
        { <> s }
    )*

    last = (
        s = (parseStatement | parseNonlocalExit)
        { <> ["statements" = [s]] }
    |
        y = parseYield
        { <> mapAdd(["statements" = []], y) }
    |
        { <> ["statements" = []] }
    )

    @";"*

    {
        allStatements = listAdd(most, mapGet(last, "statements"));
        <> mapPut(last, "statements", allStatements)
    }
/};

# Parses program / function declarations.
parseProgramDeclarations = {/
    formals = (
        fs = parseFormal+
        { <> ["formals" = fs] }
    |
        { <> [=] }
    )

    yieldDef = (
        y = parseYieldDef
        { <> ["yieldDef" = y] }
    |
        { <> [=] }
    )

    @"::"

    { <> mapAdd(formals, yieldDef) }
/};

# Parses a program (top-level program or contents inside function braces).
parseProgram = {/
    decls = (parseProgramDeclarations | { <> [=] })
    body = parseProgramBody
    { <> @["function" = mapAdd(decls, body)] }
/};

# Parses a function (in-line anonymous function).
implFunction = {/
    @"{"
    prog = parseProgram
    @"}"
    { <> prog }
/};
parseFunction(implFunction);

# Top-level rule to parse a program with possible error afterwards.
# Note that an empty string is a valid program.
parseProgramOrError = {/
    prog = parseProgram
    (
        pending = .+
        { reportError(pending) }
    )?
    { <> prog }
/};


#
# Samizdat Layer 1 definitions
#

# Forward declaration.
parseChoicePex = forwardFunction();

# Parse a parser function.
implParser = {/
    @"{/"
    pex = parseChoicePex
    @"/}"
    { <> @["parser" = pex] }
/};
parseParser(implParser);

# Parse a parenthesized parsing expression.
parseParenPex = {/
    @"("
    pex = parseChoicePex
    @")"
    { <> pex }
/};

# Parse a string literal parsing expression.
parseParserString = {/
    s = @string
    {
        value = tokenValue(s);
        <> ifTrue { <> eq(lowSize(value), 1) }
            { <> @["token" = value] }
            { <> s }
    }
/};

# Parse a character range parsing expression.
parseParserCharRange = {/
    start = @string
    startInt = {
        <> ifTrue { <> eq(lowSize(tokenValue(start)), 1) }
            { <> intFromString(tokenValue(start)) }
    }
    @".."
    end = @string
    endInt = {
        <> ifTrue { <> eq(lowSize(tokenValue(end)), 1) }
            { <> intFromString(tokenValue(end)) }
    }
    {
        loopReduce([startInt, ""]) { result ::
            at = listFirst(result);
            soFar = listLast(result);
            ifTrue { <> gt(at, endInt) } { <out> @["string" = soFar] };
            <> [iadd(at, 1), stringAdd(soFar, stringFromInt(at))]
        }
    }
/};

# Parse a token literal parsing expression.
parseParserToken = {/
    @"@"
    type = [@identifier @string]
    { <> @["token" = tokenValue(type)] }
/};

# Parse a set (or set complement) parsing expression.
parseParserSet = {/
    @"["

    type = (
        @"!" { <> "[!]" }
    |
        { <> "[]" }
    )

    terminals = (
        strings = (parseParserCharRange | @string)+
        {
            oneString = listReduce("", strings)
                { result . s :: <> stringAdd(result, tokenValue(s)) };
            <> stringReduce ([], oneString)
                { result . ch :: <> listAppend(result, ch) }
        }
    |
        tokens = parseParserToken*
        { <> listMap(tokens) { . t :: <> tokenValue(t) } }
    )

    @"]"

    { <> @[type = terminals] }
/};

# Parse a code block parsing expression.
parseParserCode = {/
    @"{"

    yieldDef = (
        y = parseYieldDef
        @"::"
        { <> ["yieldDef" = y] }
    |
        @"::"?
        { <> [=] }
    )

    body = parseProgramBody
    @"}"

    { <> @["{}" (mapAdd(yieldDef, body))] }
/};

# Parse an atomic parsing expression.
parseParserAtom = {/
    parseVarRef
|
    parseParserString
|
    parseParserToken
|
    parseParserSet
|
    parseParserCode
|
    @"."
|
    @"()"
|
    parseParenPex
/};

# Parse a repeat (or not) parsing expression.
parseRepeatPex = {/
    atom = parseParserAtom
    (
        repeat = [@"?" @"*" @"+"]
        { <> @[tokenType(repeat) = atom] }
    |
        { <> atom }
    )
/};

# Parse a lookahead (or not) parsing expression. This covers both lookahead
# success and lookahead failure.
parseLookaheadPex = {/
    (
        lookahead = [@"&" @"!"]
        pex = parseRepeatPex
        { <> @[tokenType(lookahead) = pex] }
    )
|
    parseRepeatPex
/};

# Parse a name (or not) parsing expression.
parseNamePex = {/
    (
        name = @identifier
        @"="
        pex = parseLookaheadPex
        { <> @["varDef" = ["name"=tokenValue(name), "value"=pex]] }
    )
|
    parseLookaheadPex
/};

# Parse a sequence parsing expression. This includes a sequence of length
# one.
parseSequencePex = {/
    items = parseNamePex+
    { <> @["sequence" = items] }
/};

# Parse a choice parsing expression. This includes a single choice.
implChoicePex = {/
    first = parseSequencePex
    rest = (@"|" parseSequencePex)*
    { <> @["choice" = listPrepend(first, rest)] }
/};
parseChoicePex(implChoicePex);


#
# Exported functions
#

# Documented in Samizdat Layer 1 spec.
sam2Tree = { program ::
    tokens = ifTrue { <> isString(program) }
        { <> sam2Tokenize(program) }
        { <> program };

    <> pegApply(parseProgramOrError, tokens)
};

<> [
    "sam2Tree" = sam2Tree
]
