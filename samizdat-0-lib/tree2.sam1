# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 2 Tree Parser
#


#
# Private Definitions
#

# Reports the given list of pending tokens as part of error processing.
fn reportError(pending) {
    io0Note("Pending tokens:");

    filterPump(pending, makeInclusiveRange(1, 1, 50))
        { token, . :: io0Note(cat("    ", sourceString(token))) };

    io0Die("\nExtra tokens at end of program.")
};

# Set-like map of all lowercase identifier characters. Used to figure
# out if we're looking at a keyword in the `identifierString` rule.
def LOWER_ALPHA = [
    makeInclusiveRange("a", 1, "z")*: true
];

# Returns an `interpolate` node.
fn makeInterpolate(expression) {
    <> @[interpolate: expression]
};

# Returns a `literal` node.
fn makeLiteral(value) {
    <> @[literal: value]
};

# Returns a node representing a thunk (no-arg function) that returns the
# expression represented by the given node.
fn makeThunk(expression) {
    <> @[closure: [formals: [], statements: [], yield: expression]]
};

# Returns a `varDef` node.
fn makeVarDef(name, value) {
    <> @[varDef: [name: name, value: value]]
};

# Returns a `varRef` node.
fn makeVarRef(name) {
    <> @[varRef: name]
};

# Returns a `call` node.
fn makeCall(function, actuals*) {
    <> @[call: [function: function, actuals: actuals]]
};

# Returns a `call` node that names a function as a `varRef`.
fn makeCallName(name, actuals*) {
    <> @[call: [function: makeVarRef(name), actuals: actuals]]
};

# Returns an optional-value expression. This wraps `node` as
# `optValue { <> node }`.
fn makeOptValueExpression(node) {
    <> makeCallName("optValue", makeThunk(node))
};

# Returns a `call` node to a nonlocal exit with the given name and
# with optional expression value. If passed, the expression is allowed
# to evaluate to void, in which case the nonlocal exit yields void at
# its exit point.
fn makeCallNonlocalExit(name, optExpression?) {
    <> ifValue { <> optExpression* }
        { ex ::
            <> makeCallName("nonlocalExit",
                name,
                makeInterpolate(makeOptValueExpression(ex)))
        }
        { <> makeCallName("nonlocalExit", name) }
};

# Returns a `call` node that names a function as a `varRef` and passes
# "thunked" versions of each of the given actual arguments.
fn makeCallNameThunks(name, actuals*) {
    def thunks = filterAll(actuals) { one <> makeThunk(one) };
    <> makeCallName(name, thunks*)
};

# Makes and returns a node representing a named method call.
fn makeMethodCall(target, name, actuals*) {
    <> makeCallName("methodCall",
        makeVarRef("DISPATCH"), target, name, actuals*)
};

# Returns a `closure` node like the one given, except with the `formals`
# binding replaced with the given arguments. Each of the `formals`
# must be a formal argument map as described in the execution tree spec.
fn closureWithFormals(closure, formals*) {
    <> @[closure: [dataOf(closure)*, formals: formals]]
};

# Returns a `closure` node like the one given, except with `yieldDef`
# bound to the indicated name.
fn closureWithYieldDef(closure, name) {
    <> @[closure: [dataOf(closure)*, yieldDef: name]]
};

# A no-argument yield-void thunk.
def YIELD_VOID_THUNK = @[closure: [formals: [], statements: []]];

# A single-argument yield-void function.
def YIELD_VOID_FN_1 = closureWithFormals(YIELD_VOID_THUNK, [:]);

# Map of token types to corresponding unary operator function name variable
# references.
def UNARY_OPERATORS = [
    "+":   makeVarRef("unary+"),
    "-":   makeVarRef("unary-"),
    "**":  makeVarRef("logicFromBoolean"),
    "!!!": makeVarRef("not")
];

# For binary operators, map of token types to one of:
#
# * a `varRef` node for the corresponding function name
# * a `literal` node for the corresponding method name
def BINARY_OPERATORS = [
    "+":    makeVarRef("binary+"),
    "-":    makeVarRef("binary-"),
    "*":    makeVarRef("binary*"),
    "/":    makeVarRef("binary/"),
    "%":    makeVarRef("binary%"),
    "//":   makeVarRef("binary//"),
    "%%":   makeVarRef("binary%%"),
    "==":   makeLiteral("eq"),
    "!=":   makeLiteral("ne"),
    "<":    makeLiteral("lt"),
    ">":    makeLiteral("gt"),
    "<=":   makeLiteral("le"),
    ">=":   makeLiteral("ge"),
    "&&&":  makeVarRef("and"),
    "|||":  makeVarRef("or"),
    "^^^":  makeVarRef("xor"),
    "<<<":  makeVarRef("shl"),
    ">>>":  makeVarRef("shr"),
    "\\==": makeVarRef("eq"),
    "\\!=": makeVarRef("ne"),
    "\\<":  makeVarRef("lt"),
    "\\>":  makeVarRef("gt"),
    "\\<=": makeVarRef("le"),
    "\\>=": makeVarRef("ge"),
    "..":   makeVarRef("makeInclusiveRange"),
    "..!":  makeVarRef("makeExclusiveRange"),
    "..+":  makeVarRef("makeOpenRange")
];

# Helper for parsing binary operator expressions, which puts together
# a sequence of function calls. `voidable`, if passed as `true`, indicates
# that the inner calls should be made voidable.
fn makeBinaryCalls(firstEx, opExList, optVoidable?) {
    ifIs { <> eq(opExList, []) }
        {
            # Don't bother with the rest if there are no ops to apply.
            # This avoids having to special-case the voidable stuff.
            return firstEx
        };

    def voidable = ifValueOr { <> optVoidable* } { <> false };

    def result = doReduce1(opExList, firstEx) { opEx, result ::
        def op = first(opEx);
        def ex = last(opEx);
        def resolvedOp = get(BINARY_OPERATORS, typeOf(op));

        def call = ifIs { <> eq(typeOf(resolvedOp), "varRef") }
            { <> makeCall(resolvedOp, result, ex) }
            { <> makeMethodCall(result, resolvedOp, ex) };

        <> ifIs { <> eq(voidable, true) }
            { <> @[voidable: call] }
            { <> call }
    };

    # For an inner-voidable expression, unwrap the outermost layer of
    # voidability.
    <> ifIs { <> eq(voidable, true) }
        { <> dataOf(result) }
        { <> result }
};


#
# *Layer 0* Rules
#
# This section consists of the definitions required to implement *Layer 0*,
# with comments indicating the "hooks" for higher layers.
#

# Forward declaration required for layer 2.
def parAtom2 = forwardFunction();

# Forward declarations.
def parProgramBody = forwardFunction();
def parExpression = forwardFunction();
def parVoidableExpression = forwardFunction();

# Forward declaration required for integrating layer 1 definitions.
def parParser = forwardFunction();

# Parses a yield / nonlocal exit definition, yielding the def name.
def parYieldDef = {/
    @"<"
    name = @identifier
    @">"
    { <> dataOf(name) }
/};

# Parses an optional yield / nonlocal exit definition, always yielding
# a map (an empty map if no yield def was present).
def parOptYieldDef = {/
    y = parYieldDef
    { <> [yieldDef: y] }
|
    { <> [:] }
/};

# Parses a formal argument decalaration.
def parFormal = {/
    name = (
        n = @identifier
        { <> [name: dataOf(n)] }
    |
        @"." { <> [:] }
    )

    repeat = (
        r = [@"?" @"*" @"+"]
        { <> [repeat: typeOf(r)] }
    |
        { <> [:] }
    )

    { <> [:, name*, repeat*] }
/};

# Parses a list of formal arguments, with no surrounding parentheses.
def parFormalsList = {/
    one = parFormal
    rest = (@"," parFormal)*
    { <> [one, rest*] }
|
    { <> [] }
/};

# Parses program / function declarations.
def parProgramDeclarations = {/
    yieldDef = parOptYieldDef
    formals = parFormalsList

    (@"::" | &@"<>")

    { <> [formals: formals, yieldDef*] }
|
    { <> [formals: []] }
/};

# Parses a program (top-level program or contents inside function braces).
def parProgram = {/
    decls = parProgramDeclarations
    body = parProgramBody
    { <> @[closure: [:, decls*, body*]] }
/};

# Parses a closure (in-line anonymous function, with no extra bindings).
def parClosure = {/
    @"{"
    prog = parProgram
    @"}"
    { <> prog }
/};

# Parses a closure which must not define any formal arguments. This is done
# by parsing an arbitrary closure and then verifying that it does not
# declare formals. This is preferable to not-including formal argument
# syntax, because (a) no rule wants to differentiate these cases (rules either
# want an arbitrary closure or a specifically-constrained kind); (b) it
# reduces redundancy in the syntax, and (c) the error case on the former
# would be more obscure (as in just something like "unexpected token" on
# the would-be formal argument).
def parNullaryClosure = {/
    c = parClosure

    {
        def formals = get(dataOf(c), "formals");
        ifIs { <> ne(formals, []) }
            { io0Die("Invalid formal argument in code block.") };
        <> c
    }
/};

# Parses a closure which must have neither formal arguments nor a yield
# definition. See `parseNullaryClosure` above for discussion.
def parCodeOnlyClosure = {/
    c = parNullaryClosure

    {
        ifIs { <> get(dataOf(c), "yieldDef") }
            { io0Die("Invalid yield definition in code block.") };
        <> c
    }
/};

# Common parsing for `fn` statements and expressions. The syntax for
# both is identical, except that the statement form requires that the
# function be named. The result of this rule is a map identical in form to
# what's required for a closure payload, except that `name` may also
# be bound.
#
# The result of this rule is suitable for use as a `closure` node
# payload. And as long as `name` is bound, the result is valid to use
# as the payload for a `fnDef` node.
#
# The translation is along these lines:
#
# ```
# fn <out> name(arg1, arg2) { stat1; stat2 }
# ```
# =>
# ```
# { <\"return"> arg1, arg2 ::
#     def out = \"return";
#     stat1;
#     stat2
# }
# ```
#
# with:
#
# * no yield def binding statement if an explicit yield def was not present.
#
# * the key `name` bound to the function name, if a name was defined. (This
#   is not representable in lower-layer surface syntax.)
def parFnCommon = {/
    @fn

    # This is a variable definition statement which binds the yield def
    # name to the `return` function, if there is in fact a yield def present.
    returnDef = (
        y = parYieldDef
        { <> makeVarDef(y, makeVarRef("return")) }
    )?

    name = (
        n = @identifier
        { <> [name: dataOf(n)] }
    |
        { <> [:] }
    )

    @"("
    formals = parFormalsList
    @")"

    code = parCodeOnlyClosure

    {
        def codeMap = dataOf(code);
        def statements = [returnDef*, get(codeMap, "statements")*];
        <> [
            codeMap*, name*,
            formals: formals,
            yieldDef: "return",
            statements: statements
        ]
    }
/};

# Parses a `fn` definition statement. The syntax here is the same as
# what's recognized by `parFnCommon`, except that the name is required.
# We don't error out (terminate the runtime) on a missing name, though, as
# that just means that we're looking at a legit `fn` expression, which will
# get successfully parsed by the `expression` alternative of `statement`.
def parFnDef = {/
    funcMap = parFnCommon

    {
        <> ifIs { <> get(funcMap, "name") }
            { <> @[fnDef: funcMap] }
    }
/};

# Parses a `fn` (function with `return` binding) expression. The translation
# is as described in `parFnCommon` (above) if the function is not given a
# name. If the function *is* given a name, the translation is along the
# following lines (so as to enable self-recursion):
#
# ```
# fn <out> name ...
# ```
# =>
# ```
# {
#     fn <out> name ...;
#     <> name
# }()
# ```
def parFnExpression = {/
    funcMap = parFnCommon
    closure = { <> @[closure: funcMap] }

    (
        name = { <> get(funcMap, "name") }
        {
            def mainClosure = @[closure: [
                formals: [],
                statements: [@[fnDef: funcMap]],
                yield: makeVarRef(name)
            ]];

            <> makeCall(mainClosure)
        }
    |
        { <> closure }
    )
/};

# Parses an integer literal.
def parInt = {/
    i = @int
    { <> makeLiteral(dataOf(i)) }
/};

# Parses a string literal.
def parString = {/
    s = @string
    { <> makeLiteral(dataOf(s)) }
/};

# Parses an identifier, identifier-like keyword, or string literal,
# returning a string literal in all cases.
def parIdentifierString = {/
    s = [@identifier @string]
    { <> makeLiteral(dataOf(s)) }
|
    token = .
    {
        <> ifNot { <> dataOf(token) }
            {
                def type = typeOf(token);
                def firstCh = nth(type, 0);
                <> ifIs { <> get(LOWER_ALPHA, firstCh) }
                    { <> makeLiteral(type) }
            }
    }
/};

# Parses an "unadorned" (no bracketing) list. Yields a list (per se)
# of contents.
def parUnadornedList = {/
    one = parVoidableExpression
    rest = (@"," parVoidableExpression)*
    { <> [one, rest*] }
|
    { <> [] }
/};

# Parses a list literal.
def parList = {/
    @"["
    expressions = parUnadornedList
    @"]"
    {
        <> ifIs { <> eq(expressions, []) }
            { <> makeLiteral([]) }
            { <> makeCallName("makeList", expressions*) }
    }
/};

# Parses an empty map literal.
def parEmptyMap = {/
    @"[" @":" @"]"
    { <> makeLiteral([:]) }
/};

# Parses an "atomic" key (as opposed to, e.g., the parens-and-commas form
# of map keys). This rule is used for the left-hand side of both mappings
# and derived values.
def parKeyAtom = {/
    # The lookahead at the end of the rule is to ensure we are not looking
    # at a more complicated expression. `@","` and `@")"` are matched here,
    # so that this rule can stay the same in *Layer 2*.
    k = parIdentifierString
    &[@":" @"," @")" @"]"]
    { <> k }
|
    parExpression
/};

# Parses an arbitrary map key. Note: This rule is nontrivial in *Layer 2*.
def parMapKey = {/
    # Note: This clause is only active for a list of two or more items.
    # A single parenthesized item is properly covered by the second alternate.
    @"("
    firstKey = parKeyAtom
    moreKeys = (@"," parKeyAtom)+
    @")"
    { <> makeInterpolate(makeCallName("makeList", firstKey, moreKeys*)) }
|
    parKeyAtom
/};

# Parses a mapping (element of a map).
def parMapping = {/
    key = parMapKey
    @":"
    value = parExpression

    # The `value` is wrapped in an `expression` node here to prevent
    # interpolation from being applied to `makeValueMap`.
    { <> makeCallName("makeValueMap", key, @[expression: value]) }
|
    map = parExpression
    {
        # We do a check to make sure the given expression is an interpolate
        # (which is the only way it can be valid). Note that
        # `expression @"*"` won't do the trick, since by the time we're here,
        # if there was a `*` it would have become part of the expression.
        <> ifIs { <> eq(typeOf(map), "interpolate") }
            { <> dataOf(map) }
    }
/};

# Parses a map literal.
def parMap = {/
    @"["
    (@":" @",")?
    one = parMapping
    rest = (@"," parMapping)*
    @"]"
    { <> makeCallName("cat", one, rest*) }
/};

# Parses a literal in derived value form.
def parDeriv = {/
    @"@"

    derivArgs = (
        @"["
        type = parKeyAtom
        value = (@":" parExpression)?
        @"]"
        { <> [type, value*] }
    |
        type = parIdentifierString
        { <> [type] }
    )

    { <> makeCallName("makeValue", derivArgs*) }
/};

# Parses a variable reference.
def parVarRef = {/
    name = @identifier
    { <> makeVarRef(dataOf(name)) }
/};

# Parses a variable definition.
def parVarDef = {/
    @def
    name = @identifier
    @"="
    ex = parExpression
    { <> makeVarDef(dataOf(name), ex) }
/};

# Parses a parenthesized expression.
def parParenExpression = {/
    @"("
    ex = parExpression
    @")"
    { <> @[expression: ex] }
/};

# Parses an atomic expression.
def parAtom = {/
    parVarRef | parInt | parString | parList | parEmptyMap | parMap |
    parDeriv | parClosure | parParenExpression
|
    # Defined by *Samizdat Layer 1*. The lookahead is just to make it clear
    # that *Layer 1* can only be "activated" with that one specific token.
    &@"{/" parParser
|
    # Defined by *Samizdat Layer 2*.
    &[@interpolatedString @"(" @"["] parAtom2
/};

# Parses a list of "actual" (as opposed to formal) arguments to a function.
# Yields a list of expression nodes.
def parActualsList = {/
    @"("
    normalActuals = parUnadornedList
    @")"
    closureActuals = parClosure*
    { <> [closureActuals*, normalActuals*] }
|
    parClosure+
/};

# `prefixOperator` and `postfixOperator` from layer 0 are replaced with
# forwarded functions here. These are subsumed by more featureful layer 2
# definitions, below.
def parPrefixOperator = forwardFunction();
def parPostfixOperator = forwardFunction();

# Parses a unary expression. This is an atom, optionally surrounded on
# either side by any number of unary operators. Postfix operators
# take precedence over (are applied before) the prefix operators.
def parUnaryExpression = {/
    prefixes = parPrefixOperator*
    base = parAtom
    postfixes = parPostfixOperator*

    {
        def withPosts = doReduce1(postfixes, base)
            { op, result <> op(result) };
        <> doReduce1(reverse(prefixes), withPosts)
            { op, result <> op(result) }
    }
/};

# Parses a possibly-voidable expression. This is done rather than including
# `&` as a prefix operator, since it is valid in more limited contexts than
# general expressions.
def implVoidableExpression = {/
    @"&"
    ex = parUnaryExpression
    { <> @[voidable: ex] }
|
    parExpression
/};
parVoidableExpression(implVoidableExpression);

# `expression` from layer 0 is omitted here (it's forwarded earlier), and
# `statement` and `nonlocalExit` are replaced with forwarded functions here.
# These are all subsumed by more featureful layer 2 definitions, below.
def parStatement = forwardFunction();
def parNonlocalExit = forwardFunction();

# Parses a local yield / return.
def parYield = {/
    @"<>"
    (
        ex = parExpression
        { <> [yield: ex] }
    |
        { <> [:] }
    )
/};

# Parses a program body (statements plus optional yield).
def implProgramBody = {/
    @";"*

    most = (
        s = parStatement
        @";"+
        { <> s }
    )*

    last = (
        s = (parStatement | parNonlocalExit)
        { <> [statements: [s]] }
    |
        y = parYield
        { <> [statements: [], y*] }
    |
        { <> [statements: []] }
    )

    @";"*

    {
        def allStatements = [most*, get(last, "statements")*];
        <> [last*, statements: allStatements]
    }
/};
parProgramBody(implProgramBody);

# Top-level rule to parse a program with possible error afterwards.
# Note that an empty string is a valid program.
def parProgramOrError = {/
    prog = parProgram
    (
        pending = .+
        { reportError(pending) }
    )?
    { <> prog }
/};


#
# *Layer 1* Rules
#
# This section consists of the definitions required to implement *Layer 1*,
# above and beyond the preceding section.
#
# **Note:** The grammar uses the label "pex" to denote various
# "Parser EXpression" types.
#

# Forward declaration.
def parChoicePex = forwardFunction();

# Parses a parser function.
def implParser = {/
    @"{/"
    pex = parChoicePex
    @"/}"
    { <> @[parser: pex] }
/};
parParser(implParser);

# Parses a parenthesized parsing expression.
def parParenPex = {/
    @"("
    pex = parChoicePex
    @")"
    { <> pex }
/};

# Parses a string literal parsing expression.
def parParserString = {/
    s = @string
    {
        def value = dataOf(s);
        <> ifIs { <> eq(size(value), 1) }
            { <> @[token: value] }
            { <> s }
    }
/};

# Parses a token literal parsing expression.
def parParserToken = {/
    @"@"
    type = parIdentifierString
    { <> @[token: dataOf(type)] }
/};

# Parses a string or character range parsing expression, used when defining
# sets. Yields a string per se (not a token).
def parParserSetString = {/
    s = @string
    (
        @".."
        end = @string
        {
            def startChar = dataOf(s);
            def endChar = dataOf(end);
            <> ifIs
                { <> eq(1, &eq(size(startChar), size(endChar))) }
                { <> cat(makeInclusiveRange(startChar, 1, endChar)*) }
        }
    |
        { <> dataOf(s) }
    )
/};

# Parses a set (or set complement) parsing expression.
def parParserSet = {/
    @"["

    type = (
        @"!" { <> "[!]" }
    |
        { <> "[]" }
    )

    terminals = (
        strings = parParserSetString+
        { <> [cat(strings*)*] }
    |
        tokens = parParserToken+
        { <> filter(tokens, dataOf) }
    |
        { <> [] }
    )

    @"]"

    { <> @[(type): terminals] }
/};

# Parses a code block parsing expression.
def parParserCode = {/
    closure = parNullaryClosure
    { <> @["{}": dataOf(closure) ] }
/};

# Parses an atomic parsing expression.
def parParserAtom = {/
    @"."
|
    @"("
    @")"
    { <> @"()" }
|
    parVarRef | parParserString | parParserToken | parParserSet |
    parParserCode | parParenPex
/};

# Parses a repeat (or not) parsing expression.
def parRepeatPex = {/
    atom = parParserAtom
    (
        repeat = [@"?" @"*" @"+"]
        { <> @[typeOf(repeat): atom] }
    |
        { <> atom }
    )
/};

# Parses a lookahead (or not) parsing expression. This covers both lookahead
# success and lookahead failure.
def parLookaheadPex = {/
    (
        lookahead = [@"&" @"!"]
        pex = parRepeatPex
        { <> @[typeOf(lookahead): pex] }
    )
|
    parRepeatPex
/};

# Parses a name (or not) parsing expression.
def parNamePex = {/
    (
        name = @identifier
        @"="
        pex = parLookaheadPex
        { <> @[varDef: [name: dataOf(name), value: pex]] }
    )
|
    parLookaheadPex
/};

# Parses a sequence parsing expression. This includes sequences of length
# one, but it does *not* parse empty (zero-length) sequences.
def parSequencePex = {/
    items = parNamePex+
    { <> @[sequence: items] }
/};

# Parses a choice parsing expression. This includes a single choice.
def implChoicePex = {/
    one = parSequencePex
    rest = (@"|" parSequencePex)*
    { <> @[choice: [one, rest*]] }
/};
parChoicePex(implChoicePex);


#
# Layer 2 Definitions and Rules
#

# Helper for string interpolation: Parses the two kinds of interpolation,
# yielding an appropriate expression node if syntactically valid, including
# verification that all input was consumed.
def parStringInterpolation = {/
    &@"("
    ex = parAtom
    !.
    { <> ex }
|
    &@"{"
    block = parNullaryClosure
    !.
    { <> makeCall(block) }
/};

# Parses an interpolated string. The payload of an interpolated string
# token is a list with elements being either simple strings or lists of
# tokens. The token lists are delimited either with parentheses or braces.
# Parenthesized lists are taken to be expressions to be evaluated. Braced
# lists are taken to be thunks to be evaluated-and-called. The translation
# is along these lines:
#
# ```
# @[interpolatedString: [
#     "string",
#     [format: "formatStr", tokens: [@"(", exprToken, ..., @")"]],
#     [format: "formatStr", tokens: [@"{", blockToken, ..., @"}"]]
# ]]
# ```
# =>
# ```
# cat("string", fmt1((expr...)?*), fmt2({ block... }()?*))
# ```
#
def parInterpolatedString = {/
    token = @interpolatedString

    {
        # Convert each of the payload items into the proper form.
        # This includes recursive parser calls to convert list forms
        # into appropriate node types.
        def elems = filterAll(dataOf(token)) { elem ::
            <> ifIs { <> isString(elem) }
                { <> makeLiteral(elem) }
                {
                    def tokens = get(elem, "tokens");

                    def formatter = ifValue { <> get(elem, "format") }
                        { format ::
                            <> makeCallName("formatterFromString",
                                makeLiteral(format))
                        }
                        { <> makeVarRef("formatValue") };

                    def call = ifValueOr
                        { <> pegApply(parStringInterpolation, tokens) }
                        { io0Die("Invalid syntax in string interpolation.") };

                    <> makeCall(formatter,
                        makeInterpolate(makeOptValueExpression(call)))
                }
        };

        <> makeCallName("cat", elems*)
    }
/};

# Parses a single generator definition, for use in comprehensions and
# `for` loops. This yields a map of the form `[init: ..., formal: ...]`,
# with `init` bound to an initializer expression and `formal` bound to
# a formal argument declaration.
def parGeneratorDef = {/
    formal = (
        name = @identifier
        { <> [name: dataOf(name)] }
    |
        "."
        { <> [:] }
    )

    @in
    init = parExpression

    { <> [formal: formal, init: init] }
/};

# Parses a comma-separated list of generator definitions, for use in
# comprehensions and `for` loops. This yields a map of the form
# `[formals: ..., inits: ...]`, with `formals` bound to a formal
# argument declaration corresponding to the names given to each of the
# generators, and `inits` bound to a list of generator initializer
# expressions.
def parGeneratorList = {/
    one = parGeneratorDef
    rest = ("," parGeneratorDef)*

    {
        def gens = [one, rest*];
        def formals = filterAll(gens) { gen <> get(gen, "formal") };
        def inits = filterAll(gens) { gen <> get(gen, "init") };

        <> [formals: formals, inits: inits]
    }
/};

# Helper for `parComprehension`, which parses the body of a comprehension,
# yielding appropriate arguments for a call to either `makeFilterGenerator`
# or `filterAll`.
def parComprehensionBody = {/
    genList = parGeneratorList
    (@"::" | &@"<>")
    filterBody = parProgramBody

    {
        def genFormals = get(genList, "formals");
        def genInits = get(genList, "inits");

        <> [@[closure: [filterBody*, formals: genFormals]], genInits*]
    }
/};

# Parses a comprehension atom, which can result in either a
# list or a generator, depending on choice of delimiter.
#
# The translation is along the lines of:
#
# ```
# (name1 in expr1, name2 in expr2 :: filterBody)
# ```
# =>
# ```
# makeFilterGenerator(expr1, expr2)
#     { name1, name2 :: filterBody }
# ```
#
# ```
# [name1 in expr1, name2 in expr2 :: filterBody]
# ```
# =>
# ```
# filterAll(expr1, expr2)
#     { name1, name2 :: filterBody }
# ```
def parComprehension = {/
    @"("
    body = parComprehensionBody
    @")"

    { <> makeCallName("makeFilterGenerator", body*) }
|
    @"["
    body = parComprehensionBody
    @"]"

    { <> makeCallName("filterAll", body*) }
/};

# Parses the `atom` variants introduced in *Layer 2*.
def implAtom2 = {/
    parInterpolatedString
|
    parComprehension
/};
parAtom2(implAtom2);

# Parses a nonlocal exit / return. All of the form matched by this rule
# have the dual properties of (a) necessarily being at the end of a code
# block, and (b) being represented as a function call in the underlying
# function representation of code blocks.
def implNonlocalExit = {/
    name = (
        @"<"
        n = parVarRef
        @">"
        { <> n }
    |
        op = [@break @continue @return]
        { <> makeVarRef(typeOf(op)) }
    )

    value = (
        ex = parExpression
        {
            # The test for a valued `continue` is done explicitly here
            # (rather than just letting the rule fail) in order to make the
            # error message more sensible.
            ifIs { <> eq(dataOf(name), "continue") }
                { io0Die("Invalid use of continue with value.") };
            <> ex
        }
    )?

    { <> makeCallNonlocalExit(name, value*) }
/};
parNonlocalExit(implNonlocalExit);

# Parses a unary prefix operator. This yields a function (per se) that
# takes a node and yields a call to the appropriate operator function.
def implPrefixOperator = {/
    operator = [@"+" @"-" @"!!!"]
    {
        def name = get(UNARY_OPERATORS, typeOf(operator));
        <> { node <> makeCall(name, node) }
    }
|
    # This one is specially converted, since it's a control construct,
    # not just a simple function application.
    @"!"
    { <> { node <> makeCallNameThunks("ifNot", node, makeLiteral(true)) } }
/};
parPrefixOperator(implPrefixOperator);

# Parses a unary postfix operator. This yields a function (per se) to call
# in order to construct a node that represents the appropriate ultimate
# function call.
def implPostfixOperator = {/
    actuals = parActualsList
    { <> { node <> makeCall(node, actuals*) } }
|
    # The lookahead failure here is to make the grammar prefer `*` to be
    # treated as a binary op.
    @"*" !parExpression
    { <> { node <> makeInterpolate(node) } }
|
    @"?"
    { <> { node <> makeOptValueExpression(node) } }
|
    @"**"
    { <> { node <> makeCall(get(UNARY_OPERATORS, "**"), node) } }
|
    @"??"
    {
        <> { node ::
            <> makeCallNameThunks("ifIs",
                node, makeLiteral(true), makeLiteral(false))
        }
    }
|
    @"["
    exprs = parUnadornedList
    @"]"

    (
        { <> eq(exprs, []) }
        { io0Die("Missing index value(s) from index expression.") }
    |
        { <> { node <> makeMethodCall(node, makeLiteral("get"), exprs*) } }
    )
|
    # This translates as something like:
    # * `expr.name` => `methodGet(DISPATCH, expr, "name")`
    # * `expr.(nameExpr)` => `methodGet(DISPATCH, expr, nameExpr)`
    # * `expr.name(arg, ...)` => `methodCall(DISPATCH, expr, "name", arg, ...)`
    @"."
    name = (
        n = parIdentifierString
        { <> makeLiteral(dataOf(n)) }
    |
        parAtom
    )

    (
        actuals = parActualsList
        { <> { node <> makeMethodCall(node, name, actuals*) } }
    |
        {
            <> { node ::
                <> makeCallName("methodGet", makeVarRef("DISPATCH"), node, name)
            }
        }
    )
/};
parPostfixOperator(implPostfixOperator);

# Parses a range expression.
def parRangeExpression = {/
    base = parUnaryExpression

    (
        # Not actually a range expression.
        ![@".." @"..!" @"..+"]
        { <> base }
    |
        increment = (
            @".."
            inc = parUnaryExpression
            &[@".." @"..!" @"..+"] # So this won't match a limit expression.
            { <> inc }
        |
            { <> makeLiteral(1) }
        )

        result = (
            op = [@".." @"..!"]
            limit = parUnaryExpression
            {
                <> makeCall(get(BINARY_OPERATORS, typeOf(op)),
                    base, increment, limit)
            }
        |
            @"..+"
            { <> makeCall(get(BINARY_OPERATORS, "..+"), base, increment) }
        )

        (
            # Any additional range-ish operators cause an explicit error.
            [@".." @"..!" @"..+"]
            { io0Die("Invalid form for range expression.") }
        |
            { <> result }
        )
    )
/};

# Parses a multiplicative expression.
def parMulExpression = {/
    firstEx = parRangeExpression
    opExes = (
        op = [@"*" @"/" @"%" @"//" @"%%" @"<<<" @">>>"]
        ex = parRangeExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses an additive expression.
def parAddExpression = {/
    firstEx = parMulExpression
    opExes = (
        op = [@"+" @"-" @"&&&" @"|||" @"^^^"]
        ex = parMulExpression
        { <> [op, ex] }
    )*

    { <> makeBinaryCalls(firstEx, opExes) }
/};

# Parses a comparison expression. The syntax here is the mathematical
# style of `x < y < z` meaning `(x < y) & (y < z)`. This semantics
# falls naturally out of the left-associativity of the expression
# along with the value-or-void logic model, as defined by the language.
def parCompareExpression = {/
    firstEx = parAddExpression
    opExes = (
        op = [
            @"=="   @"!="   @"<"   @">"   @"<="   @">="
            @"\\==" @"\\!=" @"\\<" @"\\>" @"\\<=" @"\\>="
        ]
        ex = parAddExpression
        { <> [op, ex] }
    )*

    # Third argument here indicates that the inner calls need to be made
    # voidable.
    { <> makeBinaryCalls(firstEx, opExes, true) }
/};

# Parses a parenthesized test clause, yielding a map of the form
# @[formal: ..., test: ...], with `formal` bound to a formal argument
# declaration and `test` bound to the test expression. If no formal was
# parsed, `formal` is bound to `[:]`.
def parTestClause = {/
    @"("

    formal = (
        name = @identifier
        @":="
        { <> [name: dataOf(name)] }
    |
        { <> [:] }
    )

    test = parExpression
    @")"

    { <> [formal: formal, test: test] }
/};

# Parses a clause in a logical-and expression. This is just like
# `parTestClause` above, except that it also allows for unparenthesized
# `compareExpression`s.
def parLogicAndClause = {/
    parTestClause
|
    test = parCompareExpression
    { <> [formal: [:], test: test] }
/};

# Parses a short-circuit logical-and expression. The translation is along
# the lines of:
#
# ```
# (var1 = expr1) & expr2 & expr3
# ```
# =>
# ```
# ifValue { <> expr1 }
#     { var1 :: ifIs { <> expr2 } { <> expr3 } }
# ```
#
# That is, with a name binding, `ifValue` is used, and without a name
# binding, `ifIs` is used.
def parLogicAndExpression = {/
    # This is done with the `*` on the list head (that is, most-then-last
    # instead of the more usual arrangement of first-then-rest), since the
    # last clause is special in that it can't be an assignment. The last
    # clause is also the base case for the `doReduce1` call.
    most = (
        clause = parLogicAndClause
        @"&"
        { <> clause }
    )*
    last = parCompareExpression

    {
        <> doReduce1(reverse(most), last)
            { clause, result ::
                def formal = get(clause, "formal");
                def test = makeThunk(get(clause, "test"));
                def resultThunk = makeThunk(result);
                <> ifIs { <> eq(formal, [:]) }
                    { <> makeCallName("ifIs", test, resultThunk) }
                    {
                        <> makeCallName("ifValue",
                            test,
                            closureWithFormals(resultThunk, formal))
                    }
            }
    }
/};

# Parses a short-circuit logical-or expression. The translation is along
# the lines of:
#
# ```
# expr1 | expr2 | expr3
# ```
# =>
# ```
# ifValueOr { <> expr1 }
#     { ifValueOr { <> expr2 } { <> expr3 } }
# ```
def parLogicOrExpression = {/
    one = parLogicAndExpression
    rest = (@"|" parLogicAndExpression)*

    (
        # This handles the case of not actually being a logical-or expression.
        {
            <> ifIs { <> eq(rest, []) }
                { <> one }
        }
    |
        {
            def allExprs = reverse([one, rest*]);
            <> doReduce1(butFirst(allExprs), first(allExprs))
                { ex, result ::
                    <> makeCallName("ifValueOr",
                        makeThunk(ex), makeThunk(result))
                }
        }
    )
/};

# Parses an if expression. The translation is along the lines of:
#
# ```
# if <out> (name1 = expr1) {
#     thenStat1
# } else if (name2 = expr2) {
#     thenStat2
# } else {
#     elseStat
# }
# ```
# =>
# ```
# { <out> ::
#     <> ifValue { <> expr1 }
#         { name1 :: thenStat1 }
#         {
#             ifValue { <> expr2 }
#                 { name2 :: thenStat2 }
#                 { elseStat }
#         }
# }()
# ```
#
# with:
# * the outer thunk-call omitted if there was no yield definition.
# * the `elseStat` block as `{}` (that is yield-void) if there was no
#   `else` clause.
# * `ifIs` instead of `ifValue` and no then-clause argument declaration for
#   any clause where no name binding was present.
# * arbitrary nesting of additional clauses.
def parIfExpression = {/
    @if
    yieldDef = parOptYieldDef
    firstCondition = parTestClause
    firstThen = parCodeOnlyClosure

    elseIfThens = (
        @else
        @if
        condition = parTestClause
        then = parCodeOnlyClosure
        { <> [condition*, then: then] }
    )*

    finalElse = (
        @else
        parCodeOnlyClosure
    |
        { <> YIELD_VOID_THUNK }
    )

    mainThunk = {
        # This builds the full expression from back to front (inner to outer).
        def clauses = reverse(
            [[firstCondition*, then: firstThen], elseIfThens*]);

        # To keep things simple, partial results are always thunks, so that
        # they can be slotted directly into place as the third argument to
        # an enclosing `ifValue` or `ifIs`. At the end -- in the last parser
        # clause of the rule, below -- we either add a yield def to the
        # thunk and wrap it in a call, or unwrap it into a straight call,
        # depending on if the original `if` has a yield def or not.
        <> doReduce1(clauses, finalElse) { clause, result ::
            def formal = get(clause, "formal");
            def test = makeThunk(get(clause, "test"));
            def then = get(clause, "then");
            def ifCall = ifIs { <> eq(formal, [:]) }
                { <> makeCallName("ifIs", test, then, result) }
                {
                    <> makeCallName("ifValue",
                        test,
                        closureWithFormals(then, formal),
                        result)
                };
            <> makeThunk(ifCall)
        }
    }

    {
        <> ifIs { <> eq(yieldDef, [:]) }
            { <> get(dataOf(mainThunk), "yield") }
            {
                # There was a yield def. Add the yield def to the thunk,
                # and wrap that in a call.
                def mainClosure =
                    closureWithYieldDef(mainThunk, mappingValue(yieldDef));
                <> makeCall(mainClosure)
            }
    }
/};

# Parses the optional yield definition that's associated with the `break`
# exit of a loop. This always results in a list, which is empty if there
# is no yield definition present, or is a single-element list of an
# appropriate variable definition and assignment.
def parOptBreakDef = {/
    (
        y = parYieldDef
        { <> makeVarDef(y, makeVarRef("break")) }
    )?
/};

# Helper for switch expressions: Parse a single case, including
# `default` and `else` cases. Returns a map that binds `keys` and
# `code`.
def parSwitchCase = {/
    keys = (
        [@default @else]
    |
        k = parMapKey
        { <> @[expression: k] }
    )

    @":"
    code = parCodeOnlyClosure

    { <> [code: code, keys: keys] }
/};

# Tree for the second argument to the `ifValue` inside a `switch` translation.
# This expression is constant across all switches, and it's most easily
# constructed by using the built-in parser.
def SWITCH_DISPATCH_CLOSURE = sam0Tree("
    args ::
    <> { cases, defaultFunction, value ::
        <> ifValue { <> get(cases, value) }
            { function <> function(value) }
            { <> defaultFunction(value) }
    }(args*)");

# Parses a switch expression. The translation is along these lines:
#
# ```
# switch <out> (name = test) {
#     ex1: { stat1a; stat1b }
#     ex2: { stat2a; stat2b }
#     default: { statDefault }
#     else: { statElse }
# }
# ```
# =>
# ```
# { <\"break"> ::
#     def out = \"break";
#     <> ifValue
#         {
#             <> [
#                 [
#                     (ex1): { name :: stat1a; stat1b },
#                     (ex2): { name :: stat2a; stat2b }
#                 ],
#                 { name :: statDefault },
#                 &test
#             ]
#         }
#         { args ::
#             <> { cases, defaultFunction, value ::
#                 <> ifValue { <> get(cases, value) }
#                     { function <> function(value) }
#                     { <> defaultFunction(value) }
#             }(args*)
#         }
#         { statElse }
# }()
# ```
#
# with:
# * The initial break assignment omitted if there is no yield def.
# * Overrides of map keys switched around so the *first* key wins.
# * The `statElse` block omitted if there is no `else` clause.
# * The `statDefault` block replaced with `{ . :: }` (that is, a yield-void
#   one-arg function) if there is no `default` clause.
# * the consequent closure argument declarations changed to `.` for any
#   if no name binding was present.
#
# Note that the translation here is arranged so that the expressions to
# evaluate and all the case bodies only see the expected variable bindings,
# and not any "implementation detail" local variables.
def parSwitchExpression = {/
    @switch
    breakDef = parOptBreakDef
    testClause = parTestClause

    @"{"

    cases = parSwitchCase*

    @"}"

    {
        def formal = get(testClause, "formal");
        def test = get(testClause, "test");

        def optDefault = filterAll(cases) { case ::
            <> ifIs { <> eq(get(case, "keys"), @default) }
                { <> closureWithFormals(get(case, "code"), formal) }
        };

        def optElse = filterAll(cases) { case ::
            <> ifIs { <> eq(get(case, "keys"), @else) }
                { <> get(case, "code") }
        };

        def regularCases = filterAll(cases) { case ::
            def keys = get(case, "keys");
            <> ifIs { <> eq(typeOf(keys), "expression") }
                {
                    <> makeCallName("makeValueMap",
                        dataOf(keys),
                        closureWithFormals(get(case, "code"), formal))
                }
        };

        ifIs { <> gt(size(optDefault), 1) }
            { io0Die("Multiple default cases in switch.") };

        ifIs { <> gt(size(optElse), 1) }
            { io0Die("Multiple else cases in switch.") };

        # Notes:
        #
        # * The cases are constructed in the somewhat-convoluted way that
        #   they are in order to preserve the left-to-right evaluation order
        #   of the apparent text, even though the key/case override semantics
        #   is the opposite of what `cat(map)` defines.
        #
        # * The `test` is wrapped in a `voidable` node to make the
        #   "logic nature" of the expression operate as expected (that is,
        #   not cause a runtime error if the test is logical-false, instead
        #   running the `else` block if any). The test is furthermore wrapped
        #   in an `expression` node in case it happens to be an interpolation,
        #   which will have to have expression and not argument semantics.
        def testBody = makeThunk(
                makeCallName("makeList",
                    ifIs { <> eq(regularCases, []) }
                        { <> makeLiteral([:]) }
                        {
                            <> makeCallName("cat",
                                makeInterpolate(
                                    makeCallName("reverse",
                                        makeCallName("makeList",
                                            regularCases*))))
                        },
                    ifValue { <> optDefault* }
                        { value <> closureWithFormals(value, formal) }
                        { <> YIELD_VOID_FN_1 },
                    @[voidable: @[expression: test]]));

        def ifCall = makeCallName("ifValue",
            testBody,
            SWITCH_DISPATCH_CLOSURE,
            optElse*);

        def mainClosure = @[closure: [
            formals: [],
            yieldDef: "break",
            statements: [breakDef*],
            yield: ifCall
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a while expression. The translation is along these lines:
#
# ```
# while <out> (name = test) { <next> :: stat1; stat2 }
# ```
# =>
# ```
# { <\"break"> ::
#     def out = \"break";
#     loop { <\"continue"> ::
#         ifValue { <> test }
#             { <next> name :: stat1; stat2 }
#             { <\"break"> }
#     }
# }()
# ```
#
# with:
# * the initial break assignment omitted if there is no yield def.
# * the body argument declaration changed to `.` if there is no
#   test expression name binding.
def parWhileExpression = {/
    @while
    breakDef = parOptBreakDef
    testClause = parTestClause
    code = parNullaryClosure

    {
        def formal = get(testClause, "formal");
        def test = get(testClause, "test");

        def loopClosure = @[closure: [
            formals: [],
            yieldDef: "continue",
            statements: [
                makeCallName("ifValue",
                    makeThunk(test),
                    closureWithFormals(code, formal),
                    makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
            ]
        ]];

        def mainClosure = @[closure: [
            formals: [],
            yieldDef: "break",
            statements: [breakDef*, makeCallName("loop", loopClosure)]
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a do expression. The translation is along these lines:
#
# ```
# do <out> { <next> :: stat1; stat2 } while (expr)
# ```
# =>
# ```
# { <\"break"> ::
#     def out = \"break";
#     loop { <\"continue"> ::
#         { <next> :: stat1; stat2 }();
#         ifNot { <> expr }
#             { <\"break"> }
#     }
# }()
# ```
#
# with the initial break assignment omitted if there is no yield def, and
# with the `ifNot` statement omitted if there is no `while` at the end
# of the `do`.
def parDoExpression = {/
    @do
    breakDef = parOptBreakDef
    code = parNullaryClosure
    condition = (
        @while
        ex = parParenExpression
        {
            <> makeCallName("ifNot",
                makeThunk(ex),
                makeThunk(makeCallNonlocalExit(makeVarRef("break"))))
        }
    )?

    {
        def loopClosure = @[closure: [
            formals: [],
            yieldDef: "continue",
            statements: [makeCall(code), condition*]
        ]];

        def mainClosure = @[closure: [
            formals: [],
            yieldDef: "break",
            statements: [breakDef*, makeCallName("loop", loopClosure)]
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a for expression. The translation is along these lines:
#
# ```
# for <out> (name1 in expr1, name2 in expr2) { <next> :: stat1; stat2 }
# ```
# =>
# ```
# { <\"break"> ::
#     def out = \"break";
#     filterPump(expr1, expr2) { <\"continue"> name1, name2 ::
#         def next = \"continue";
#         stat1; stat2
#     }
# }()
# ```
#
# with:
# * the break assignment omitted if there is no outer yield def.
# * the continue assignment omitted if there is no inner yield def
def parForExpression = {/
    @for
    breakDef = parOptBreakDef
    @"("
    genList = parGeneratorList
    @")"
    code = parNullaryClosure

    {
        def genFormals = get(genList, "formals");
        def genInits = get(genList, "inits");

        def codePayload = dataOf(code);
        def continueDef = ifValue { <> get(codePayload, "yieldDef") }
            { name <> [makeVarDef(name, makeVarRef("continue"))] }
            { <> [] };

        def loopClosure = @[closure: [
            formals: genFormals,
            yieldDef: "continue",
            statements: [continueDef*, get(codePayload, "statements")*]
        ]];

        def mainClosure = @[closure: [
            formals: [],
            yieldDef: "break",
            statements: [
                breakDef*,
                makeCallName("filterPump", loopClosure, genInits*)
            ]
        ]];

        <> makeCall(mainClosure)
    }
/};

# Parses a general expression.
def implExpression = {/
    # This one's the top level "regular-looking" expression (in that it
    # covers the territory of C-style expressions).
    parLogicOrExpression
|
    # This one is only nominally "regular-looking" (in that not many C
    # family languages have function expressions).
    parFnExpression
|
    # These are "statement-like" expressions, in that they look like
    # similar statements in many (most?) C-derived languages.
    parDoExpression | parForExpression |
    parIfExpression | parSwitchExpression | parWhileExpression
/};
parExpression(implExpression);

# Parses a statement.
def implStatement = {/
    parVarDef | parFnDef | parExpression
/};
parStatement(implStatement);


#
# Exported Definitions
#

# Documented in Samizdat Layer 1 spec.
fn sam2Tree(program) {
    def tokens = ifIs { <> isString(program) }
        { <> sam2Tokenize(program) }
        { <> program };

    <> pegApply(parProgramOrError, tokens)
};

<> [
    sam2Tree: sam2Tree
]
