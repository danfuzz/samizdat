# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# PEG (Parsing Expression Grammar) support
#


#
# Helper functions
#

# Constructs a generator for the given input. This special-cases
# strings to make them into single-character token generators. Other than
# that, this is the same as `generatorFromValue`.
fn generatorFromInput(input) {
    <> ifIs { <> isString(input) }
        { <> tokenGenerator(input) }
        { <> generatorFromValue(input) }
};

# Helper for `pegMake*Set*`, which takes a `sense` argument and produces the
# desired rule.
fn genericMakeTokenSet(sense, types) {
    ifIs { <> eq(types, []) }
        {
            # Trivial case: Empty set. Return an appropriate absolute rule.
            return ifIs { <> eq(sense, true) }
                { <> pegRuleFail }
                { <> pegRuleAny }
        };

    # This is implemented as, in effect, `(token=. { check(token) })`, which
    # allows us to keep the main matcher function here much simpler.

    def set = [types*: true]; # A set-like map of all the token types.
    def matcher = ifIs { <> eq(sense, true) }
        {
            <> { item ::
                <> ifIs { <> mapGet(set, typeOf(item)) }
                    { <> item }
            }
        }
        {
            <> { item ::
                <> ifNot { <> mapGet(set, typeOf(item)) }
                    { <> item }
            }
        };

    <> pegMakeMainSequence(pegRuleAny, pegMakeCode(matcher))
};


#
# Exported functions
#

#
# Simple rules
#

# Documented in Samizdat Layer 0 spec.
fn pegRuleAny(box, input, .*) {
    <> input(box)
};

# Documented in Samizdat Layer 0 spec.
fn pegRuleEmpty(box, input, .*) {
    boxSet(box, null);
    <> input
};

# Documented in Samizdat Layer 0 spec.
fn pegRuleFail(box, input, .*) {
    boxSet(box)
};

# Documented in Samizdat Layer 0 spec.
fn pegRuleEof(box, input, .*) {
    <> ifIs { <> input(nullBox) }
        { boxSet(box) }
        {
            boxSet(box, null);
            <> input
        }
};

# Documented in Samizdat Layer 0 spec.
fn pegRuleLookaheadAny(box, input, .*) {
    <> ifIs { <> input(box) }
        { <> input }
};


#
# Rule constructors
#

# Documented in Samizdat Layer 0 spec.
fn pegMakeCharSet(strings*) {
    # Make a list of all the strings' characters, passing it to the
    # general token set constructor.
    <> genericMakeTokenSet(true, [stringAdd(strings*)*])
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeCharSetComplement(strings*) {
    # See comment in `pegMakeCharSet`.
    <> genericMakeTokenSet(false, [stringAdd(strings*)*])
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeChoice(rules*) {
    # Trivial case: No rules. Return the failure rule.
    ifIs { <> eq(rules, []) }
        { return pegRuleFail };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(coreSizeOf(rules), 1) }
        { return rules* };

    # The general case.
    <> { <out> box, input, items* ::
        doFilter(rules) { rule ::
            def innerBox = yieldBox();
            <> ifValue { <> rule(innerBox, input, items*) }
                { newInput ::
                    boxSet(box, boxGet(innerBox));
                    <out> newInput
                }
        };

        # No rule succeeded.
        boxSet(box)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeCode(function) {
    <> { box, input, items* ::
        <> ifValue { <> function(items*) }
            { result ::
                boxSet(box, result);
                <> input
            }
            { boxSet(box) };
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeLookaheadFailure(rule) {
    # Optimiziation: Representation of `!.`.
    ifIs { <> eq(rule, pegRuleAny) }
        { return pegRuleEof };

    # Optimization: Representation of `!()`.
    ifIs { <> eq(rule, pegRuleEmpty) }
        { return pegRuleFail };

    # The general case.
    <> { box, input, items* ::
        <> ifIs { <> rule(nullBox, input, items*) }
            { boxSet(box) }
            {
                boxSet(box, null);
                <> input
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeLookaheadSuccess(rule) {
    <> { box, input, items* ::
        <> ifIs { <> rule(box, input, items*) }
            { <> input }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeMainChoice(rules*) {
    def subRule = pegMakeChoice(rules*);

    <> { box, input, .* ::
        <> subRule(box, input)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeMainSequence(rules*) {
    def subRule = pegMakeSequence(rules*);

    <> { box, input, .* ::
        <> subRule(box, input)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeOpt(rule) {
    <> { box, input, items* ::
        def innerBox = yieldBox();
        <> ifValue { <> rule(innerBox, input, items*) }
            { newInput ::
                boxSet(box, [boxGet(innerBox)]);
                <> newInput
            }
            {
                boxSet(box, []);
                <> input
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakePlus(rule) {
    # This is implemented as, in effect, `(elems=rule* { <> ne([], elems) })`.
    # This allows us to minimize code duplication. Note: We can't impose a
    # "main sequence" boundary here -- which is tempting as that would make
    # the size check code slightly more straightforward -- because `rule` may
    # contain back-references which would thereby get lopped off.

    fn checkSize(items*) {
        # Note: Argument order is significant here, in that `ne` returns
        # its second argument on logical-true.
        def starMatch = listLast(items);
        <> ne([], starMatch)
    };

    <> pegMakeSequence(pegMakeStar(rule), pegMakeCode(checkSize))
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeSequence(rules*) {
    # Trivial case: No rules. Return the empty rule.
    ifIs { <> eq(rules, []) }
        { return pegRuleEmpty };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(coreSizeOf(rules), 1) }
        { return rules* };

    # The general case. Each rule after the first gets passed as additional
    # arguments the matched results of all the previous rules, in order.
    <> { <out> box, input, items* ::
        def reduction = doReduce([rules], [input, items])
            { rule, input, items ::
                def innerBox = yieldBox();
                <> ifValue { <> rule(innerBox, input, items*) }
                    { newInput ::
                        def newItems = [items*, boxGet(innerBox)];
                        <> [newInput, newItems]
                    }
                    {
                        # Propagate the failure.
                        boxSet(box);
                        <out>
                    }
            };

        def newInput = listFirst(reduction);
        def results = listLast(reduction);
        boxSet(box, listLast(results));
        <> newInput
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeStar(rule) {
    <> { <out> box, input, items* ::
        loopReduce(input, [])
            { input, values ::
                def innerBox = yieldBox();
                <> ifValue { <> rule(innerBox, input, items*) }
                    { newInput ::
                        def newValues = [values*, boxGet(innerBox)];
                        <> [newInput, newValues]
                    }
                    {
                        boxSet(box, values);
                        <out> input
                    }
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeString(string) {
    # Trivial case: Empty string. Return an always-successful yield of `""`.
    ifIs { <> eq(string, "") }
        { return pegMakeCode { <> "" } };

    # Trivial case: One-char string. Return a simple one-char rule.
    ifIs { <> eq(coreSizeOf(string), 1) }
        { return pegMakeToken(string) };

    # This is implemented as, in effect, `("1" "2" ... { <> string })`,
    # which allows us to minimize code duplication.

    # Make a list of rules per character.
    def chars = collectFilter(string) { ch <> pegMakeToken(ch) };

    <> pegMakeSequence(chars*, pegMakeCode { .* <> @[(string)] })
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeToken(type) {
    # This is implemented as, in effect, `(token=. { check(token) })`, which
    # allows us to keep the main matcher function here much simpler.

    fn match(item) {
        <> ifIs { <> eq(typeOf(item), type) }
            { <> item }
    };

    <> pegMakeMainSequence(pegRuleAny, pegMakeCode(match))
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeTokenSet(tokens*) {
    <> genericMakeTokenSet(true, tokens)
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeTokenSetComplement(tokens*) {
    <> genericMakeTokenSet(false, tokens)
};


#
# Top-level driver functions
#

# Documented in Samizdat Layer 0 spec.
fn pegApply(rule, input) {
    def generator = generatorFromInput(input);
    def box = yieldBox();

    <> ifIs { <> rule(box, generator) }
        { <> boxGet(box) }
};

# Documented in Samizdat Layer 0 spec.
fn pegGenerator(rule, input) {
    fn pegGenerator1(gen) {
        <> { box ::
            <> ifValue { <> rule(box, gen) }
                { nextGen <> pegGenerator1(nextGen) }
        }
    };

    <> pegGenerator1(generatorFromInput(input))
};


#
# Export mechanics
#

<> [
    pegApply:                  pegApply,
    pegGenerator:              pegGenerator,
    pegMakeCharSet:            pegMakeCharSet,
    pegMakeCharSetComplement:  pegMakeCharSetComplement,
    pegMakeChoice:             pegMakeChoice,
    pegMakeCode:               pegMakeCode,
    pegMakeLookaheadFailure:   pegMakeLookaheadFailure,
    pegMakeLookaheadSuccess:   pegMakeLookaheadSuccess,
    pegMakeMainChoice:         pegMakeMainChoice,
    pegMakeMainSequence:       pegMakeMainSequence,
    pegMakeOpt:                pegMakeOpt,
    pegMakePlus:               pegMakePlus,
    pegMakeSequence:           pegMakeSequence,
    pegMakeStar:               pegMakeStar,
    pegMakeString:             pegMakeString,
    pegMakeToken:              pegMakeToken,
    pegMakeTokenSet:           pegMakeTokenSet,
    pegMakeTokenSetComplement: pegMakeTokenSetComplement,
    pegRuleAny:                pegRuleAny,
    pegRuleEmpty:              pegRuleEmpty,
    pegRuleEof:                pegRuleEof,
    pegRuleFail:               pegRuleFail,
    pegRuleLookaheadAny:       pegRuleLookaheadAny
]
