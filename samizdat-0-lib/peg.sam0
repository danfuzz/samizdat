# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# PEG (Parsing Expression Grammar) support
#


#
# Exported functions
#

#
# Simple rules
#

# Peg rule that matches, consumes, and yields an arbitrary terminal item.
fn pegRuleAny(yield, state, .*) {
    <> ifValue { <> listFirst(state) }
        { item ::
            boxSet(yield, item);
            <> listButFirst(state);
        }
        { boxSet(yield) }
};

# Peg rule that always succeeds, yielding `null` and consuming no input.
fn pegRuleEmpty(yield, state, .*) {
    boxSet(yield, null);
    <> state
};

# Peg rule that always fails.
fn pegRuleFail(yield, state, .*) {
    boxSet(yield)
};

# Peg rule that matches at eof, yielding `null`. This is the equivalent
# of `!.` in usual peg syntax.
fn pegRuleEof(yield, state, .*) {
    <> ifIs { <> eq(state, []) }
        {
            boxSet(yield, null);
            <> state;
        }
        { boxSet(yield) }
};

# Peg rule that matches anywhere but eof, yielding the next terminal but
# not consuming it. This is the equivalent of `&.` in usual peg syntax,
# hence the name.
fn pegRuleLookaheadAny(yield, state, .*) {
    <> ifValue { <> listFirst(state) }
        { item ::
            boxSet(yield, item);
            <> state
        }
        { boxSet(yield) }
};


#
# Rule constructors
#

# The following are all listed out of (sort) order, because they are
# used as helpers in the implementation of subsequent rule constructors.

# Documented in Samizdat Layer 0 spec.
fn pegMakeCode(function) {
    <> { yield, state, items* ::
        <> ifValue { <> function(items*) }
            { result ::
                boxSet(yield, result);
                <> state
            }
            { boxSet(yield) };
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeSequence(rules*) {
    # Trivial case: No rules. Return the empty rule.
    ifIs { <> eq(rules, []) }
        { return pegRuleEmpty };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(lowSize(rules), 1) }
        { return rules* };

    # The general case. Each rule after the first gets passed as additional
    # arguments the matched results of all the previous rules, in order.
    <> { <out> yield, state, items* ::
        def reduction = listReduce([state, items], rules)
            { results, ., rule ::
                def state = listNth(results, 0);
                def values = listNth(results, 1);
                def ybox = yieldBox();
                <> ifValue
                    { <> rule(ybox, state, values*) }
                    { newState ::
                        def newValues = [values*, boxGet(ybox)];
                        <> [newState, newValues]
                    }
                    {
                        # Propagate the failure.
                        boxSet(yield);
                        <out>
                    }
            };

        def newState = listNth(reduction, 0);
        def results = listNth(reduction, 1);
        boxSet(yield, listLast(results));
        <> newState
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeMainSequence(rules*) {
    def subRule = pegMakeSequence(rules*);

    <> { yield, state, .* ::
        <> subRule(yield, state)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeStar(rule) {
    <> { <out> yield, state, items* ::
        loopReduce([state, []])
            { results ::
                def state = listNth(results, 0);
                def values = listNth(results, 1);
                def ybox = yieldBox();
                <> ifValue { <> rule(ybox, state, items*) }
                    { newState ::
                        def newValues = [values*, boxGet(ybox)];
                        <> [newState, newValues]
                    }
                    {
                        boxSet(yield, values);
                        <out> state
                    }
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeToken(type) {
    # This is implemented as, in effect, `(&. &@token .)`, which
    # allows us to keep the main matcher function here much simpler.

    fn match(item) {
        <> ifIs { <> eq(tokenType(item), type) }
            { <> item }
    };

    <> pegMakeMainSequence(pegRuleLookaheadAny, pegMakeCode(match), pegRuleAny)
};

# Helper for `pegMake*Set*`, which takes a `sense` argument and produces the
# desired rule.
fn genericMakeTokenSet(sense, types) {
    def oppositeSense = not(sense);

    # Make a set-like map of all the token types.
    def set = listReduce([:], types)
        { result, ., type :: <> [result*, (type): sense] };

    # Trivial case: Empty set. Return an appropriate absolute rule.
    ifIs { <> eq(lowSize(set), 0) }
        {
            return ifIs { <> logicFromBoolean(sense) }
                { <> pegRuleFail }
                { <> pegRuleAny }
        };

    # This is implemented as, in effect, `(&. &set .)`, which
    # allows us to keep the main matcher function here much simpler.

    fn match(item) {
        <> ifIs { <> logicFromBoolean(mapGet(set, tokenType(item), oppositeSense)) }
            { <> item }
    };

    <> pegMakeMainSequence(pegRuleLookaheadAny, pegMakeCode(match), pegRuleAny)
};

# The following are built partially in terms of the preceding
# rule constructors.

# Helper for `pegMakeCharSet` and `pegMakeCharSetComplement`, which
# takes a `sense` argument and produces the desired rule.
fn genericMakeCharSet(sense, strings*) {
    # Make a list of all the strings' characters as tokens.
    def types = stringReduce([], stringAdd(strings*))
        { result, ., ch :: <> [result*, ch] };

    <> genericMakeTokenSet(sense, types)
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeCharSet(strings*) {
    <> genericMakeCharSet(true, strings*)
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeCharSetComplement(strings*) {
    <> genericMakeCharSet(false, strings*)
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeChoice(rules*) {
    # Trivial case: No rules. Return the failure rule.
    ifIs { <> eq(rules, []) }
        { return pegRuleFail };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(lowSize(rules), 1) }
        { return rules* };

    # The general case.
    <> { <out> yield, state, items* ::
        listForEach(rules)
            { ., rule ::
                def ybox = yieldBox();
                <> ifValue { <> rule(ybox, state, items*) }
                    { newState ::
                        boxSet(yield, boxGet(ybox));
                        <out> newState
                    }
            };

        # No rule succeeded.
        boxSet(yield)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeLookaheadSuccess(rule) {
    <> { yield, state, items* ::
        <> ifValue { <> rule(yield, state, items*) }
            { <> state }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeLookaheadFailure(rule) {
    # Optimiziation: Representation of `!.`.
    ifIs { <> eq(rule, pegRuleAny) }
        { return pegRuleEof };

    # Optimization: Representation of `!()`.
    ifIs { <> eq(rule, pegRuleEmpty) }
        { return pegRuleFail };

    # The general case.
    <> { yield, state, items* ::
        def ybox = yieldBox();
        <> ifValue { <> rule(ybox, state, items*) }
            { boxSet(yield) }
            {
                boxSet(yield, null);
                <> state
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeOpt(rule) {
    <> { yield, state, items* ::
        def ybox = yieldBox();
        <> ifValue { <> rule(ybox, state, items*) }
            { newState ::
                boxSet(yield, [boxGet(ybox)]);
                <> newState
            }
            {
                boxSet(yield, []);
                <> state
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakePlus(rule) {
    # This is implemented as, in effect,
    # `(def items=rule* { ... lowSize(match) ... })`, which allows us to
    # minimize code duplication. Note: We can't impose a "main sequence"
    # boundary here -- which is tempting as that would make the size
    # check code slightly more straightforward -- because `rule` may
    # contain back-references which would thereby get lopped off.

    fn checkSize(items*) {
        def starMatch = listLast(items);
        <> ifIs { <> ne(lowSize(starMatch), 0) }
            { <> starMatch }
    };

    <> pegMakeSequence(pegMakeStar(rule), pegMakeCode(checkSize))
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeString(string) {
    # Trivial case: Empty string. Return the empty rule.
    ifIs { <> eq(string, "") }
        { return pegRuleEmpty };

    # Trivial case: One-char string. Return a simple one-char rule.
    ifIs { <> eq(lowSize(string), 1) }
        { return pegMakeToken(string) };

    # This is implemented as, in effect, `("1" "2" ... { <> string })`,
    # which allows us to minimize code duplication.

    # Make a list of rules per character.
    def chars = stringReduce([], string)
        { result, ., ch :: <> [result*, pegMakeToken(ch)] };

    <> pegMakeMainSequence(chars*, pegMakeCode { .* :: <> @[(string)] })
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeTokenSet(tokens*) {
    <> genericMakeTokenSet(true, tokens)
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeTokenSetComplement(tokens*) {
    <> genericMakeTokenSet(false, tokens)
};


#
# Top-level driver
#

# Documented in Samizdat Layer 0 spec.
fn pegApply(rule, input) {
    def inputList = ifIs { <> isString(input) }
        {
            # Make a list of each character as a separate token.
            <> stringReduce([], input)
                { result, ., ch :: <> [result*, @[(ch)]] }
        }
        { <> input };

    ifNot { <> isList(inputList) }
        { io0Die("Attempt to parse non-list.") };

    def ybox = yieldBox();
    <> ifValue { <> rule(ybox, inputList) }
        { <> boxGet(ybox) }
};


#
# Export mechanics
#

<> [
    pegApply: pegApply,
    pegMakeCharSet: pegMakeCharSet,
    pegMakeCharSetComplement: pegMakeCharSetComplement,
    pegMakeChoice: pegMakeChoice,
    pegMakeCode: pegMakeCode,
    pegMakeLookaheadFailure: pegMakeLookaheadFailure,
    pegMakeLookaheadSuccess: pegMakeLookaheadSuccess,
    pegMakeMainSequence: pegMakeMainSequence,
    pegMakeOpt: pegMakeOpt,
    pegMakePlus: pegMakePlus,
    pegMakeSequence: pegMakeSequence,
    pegMakeStar: pegMakeStar,
    pegMakeString: pegMakeString,
    pegMakeToken: pegMakeToken,
    pegMakeTokenSet: pegMakeTokenSet,
    pegMakeTokenSetComplement: pegMakeTokenSetComplement,
    pegRuleAny: pegRuleAny,
    pegRuleEmpty: pegRuleEmpty,
    pegRuleEof: pegRuleEof,
    pegRuleFail: pegRuleFail,
    pegRuleLookaheadAny: pegRuleLookaheadAny
]
