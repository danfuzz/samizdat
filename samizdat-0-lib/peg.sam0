# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# PEG (Parsing Expression Grammar) support
#


#
# Exported functions
#

#
# Simple rules
#

# Peg rule that matches, consumes, and yields an arbitrary terminal item.
fn pegRuleAny(box, input, .*) {
    <> input(box)
};

# Peg rule that always succeeds, yielding `null` and consuming no input.
fn pegRuleEmpty(box, input, .*) {
    boxSet(box, null);
    <> input
};

# Peg rule that always fails, consuming no input.
fn pegRuleFail(box, input, .*) {
    boxSet(box)
};

# Peg rule that matches at eof, yielding `null`. This is the equivalent
# of `!.` in usual peg syntax.
fn pegRuleEof(box, input, .*) {
    <> ifValue { <> input(nullBox) }
        { . :: boxSet(box) }
        {
            boxSet(box, null);
            <> input
        }
};

# Peg rule that matches anywhere but eof, yielding the next terminal but
# not consuming it. This is the equivalent of `&.` in usual peg syntax,
# hence the name.
fn pegRuleLookaheadAny(box, input, .*) {
    <> ifValue { <> input(box) }
        { . :: <> input }
};


#
# Rule constructors
#

# The following are all listed out of (sort) order, because they are
# used as helpers in the implementation of subsequent rule constructors.

# Documented in Samizdat Layer 0 spec.
fn pegMakeCode(function) {
    <> { box, input, items* ::
        <> ifValue { <> function(items*) }
            { result ::
                boxSet(box, result);
                <> input
            }
            { boxSet(box) };
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeSequence(rules*) {
    # Trivial case: No rules. Return the empty rule.
    ifIs { <> eq(rules, []) }
        { return pegRuleEmpty };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(lowSize(rules), 1) }
        { return rules* };

    # The general case. Each rule after the first gets passed as additional
    # arguments the matched results of all the previous rules, in order.
    <> { <out> box, input, items* ::
        def reduction = listReduce([input, items], rules)
            { results, ., rule ::
                def input = listNth(results, 0);
                def values = listNth(results, 1);
                def innerBox = yieldBox();
                <> ifValue
                    { <> rule(innerBox, input, values*) }
                    { newInput ::
                        def newValues = [values*, boxGet(innerBox)];
                        <> [newInput, newValues]
                    }
                    {
                        # Propagate the failure.
                        boxSet(box);
                        <out>
                    }
            };

        def newInput = listNth(reduction, 0);
        def results = listNth(reduction, 1);
        boxSet(box, listLast(results));
        <> newInput
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeMainSequence(rules*) {
    def subRule = pegMakeSequence(rules*);

    <> { box, input, .* ::
        <> subRule(box, input)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeStar(rule) {
    <> { <out> box, input, items* ::
        loopReduce(input, [])
            { input, values ::
                def innerBox = yieldBox();
                <> ifValue { <> rule(innerBox, input, items*) }
                    { newInput ::
                        def newValues = [values*, boxGet(innerBox)];
                        <> [newInput, newValues]
                    }
                    {
                        boxSet(box, values);
                        <out> input
                    }
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeToken(type) {
    # This is implemented as, in effect, `(&. &@token .)`, which
    # allows us to keep the main matcher function here much simpler.

    fn match(item) {
        <> ifIs { <> eq(tokenType(item), type) }
            { <> item }
    };

    <> pegMakeMainSequence(pegRuleLookaheadAny, pegMakeCode(match), pegRuleAny)
};

# Helper for `pegMake*Set*`, which takes a `sense` argument and produces the
# desired rule.
fn genericMakeTokenSet(sense, types) {
    # Trivial case: Empty set. Return an appropriate absolute rule.
    ifIs { <> eq(lowSize(types), 0) }
        {
            return ifIs { <> logicFromBoolean(sense) }
                { <> pegRuleFail }
                { <> pegRuleAny }
        };


    def set = [types*: sense]; # A set-like map of all the token types.
    def oppositeSense = not(sense);

    # This is implemented as, in effect, `(&. &set .)`, which
    # allows us to keep the main matcher function here much simpler.

    fn match(item) {
        <> ifIs { <> logicFromBoolean(mapGet(set, tokenType(item), oppositeSense)) }
            { <> item }
    };

    <> pegMakeMainSequence(pegRuleLookaheadAny, pegMakeCode(match), pegRuleAny)
};

# The following are built partially in terms of the preceding
# rule constructors.

# Documented in Samizdat Layer 0 spec.
fn pegMakeCharSet(strings*) {
    # Make a list of all the strings' characters, passing it to the
    # general token set constructor.
    <> genericMakeTokenSet(true, [stringAdd(strings*)*])
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeCharSetComplement(strings*) {
    # See comment in `pegMakeCharSet`.
    <> genericMakeTokenSet(false, [stringAdd(strings*)*])
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeChoice(rules*) {
    # Trivial case: No rules. Return the failure rule.
    ifIs { <> eq(rules, []) }
        { return pegRuleFail };

    # Trivial case: One rule. Return that rule directly.
    ifIs { <> eq(lowSize(rules), 1) }
        { return rules* };

    # The general case.
    <> { <out> box, input, items* ::
        doFilter(rules) { rule ::
            def innerBox = yieldBox();
            <> ifValue { <> rule(innerBox, input, items*) }
                { newInput ::
                    boxSet(box, boxGet(innerBox));
                    <out> newInput
                }
        };

        # No rule succeeded.
        boxSet(box)
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeLookaheadSuccess(rule) {
    <> { box, input, items* ::
        <> ifValue { <> rule(box, input, items*) }
            { <> input }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeLookaheadFailure(rule) {
    # Optimiziation: Representation of `!.`.
    ifIs { <> eq(rule, pegRuleAny) }
        { return pegRuleEof };

    # Optimization: Representation of `!()`.
    ifIs { <> eq(rule, pegRuleEmpty) }
        { return pegRuleFail };

    # The general case.
    <> { box, input, items* ::
        <> ifValue { <> rule(nullBox, input, items*) }
            { boxSet(box) }
            {
                boxSet(box, null);
                <> input
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeOpt(rule) {
    <> { box, input, items* ::
        def innerBox = yieldBox();
        <> ifValue { <> rule(innerBox, input, items*) }
            { newInput ::
                boxSet(box, [boxGet(innerBox)]);
                <> newInput
            }
            {
                boxSet(box, []);
                <> input
            }
    }
};

# Documented in Samizdat Layer 0 spec.
fn pegMakePlus(rule) {
    # This is implemented as, in effect,
    # `(def items=rule* { ... lowSize(match) ... })`, which allows us to
    # minimize code duplication. Note: We can't impose a "main sequence"
    # boundary here -- which is tempting as that would make the size
    # check code slightly more straightforward -- because `rule` may
    # contain back-references which would thereby get lopped off.

    fn checkSize(items*) {
        def starMatch = listLast(items);
        <> ifIs { <> ne(lowSize(starMatch), 0) }
            { <> starMatch }
    };

    <> pegMakeSequence(pegMakeStar(rule), pegMakeCode(checkSize))
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeString(string) {
    # Trivial case: Empty string. Return the empty rule.
    ifIs { <> eq(string, "") }
        { return pegRuleEmpty };

    # Trivial case: One-char string. Return a simple one-char rule.
    ifIs { <> eq(lowSize(string), 1) }
        { return pegMakeToken(string) };

    # This is implemented as, in effect, `("1" "2" ... { <> string })`,
    # which allows us to minimize code duplication.

    # Make a list of rules per character.
    def chars = collectFilter(string) { ch :: <> pegMakeToken(ch) };

    <> pegMakeMainSequence(chars*, pegMakeCode { .* :: <> @[(string)] })
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeTokenSet(tokens*) {
    <> genericMakeTokenSet(true, tokens)
};

# Documented in Samizdat Layer 0 spec.
fn pegMakeTokenSetComplement(tokens*) {
    <> genericMakeTokenSet(false, tokens)
};


#
# Top-level driver
#

# Documented in Samizdat Layer 0 spec.
fn pegApply(rule, input) {
    def generator = ifValue { <> isString(input) }
        { . ::
            # Generate single-character tokens instead of single-character
            # strings.
            <> tokenGenerator(input)
        }
        { <> generatorFromValue(input) };

    def box = yieldBox();
    <> ifValue { <> rule(box, generator) }
        { . :: <> boxGet(box) }
};


#
# Export mechanics
#

<> [
    pegApply: pegApply,
    pegMakeCharSet: pegMakeCharSet,
    pegMakeCharSetComplement: pegMakeCharSetComplement,
    pegMakeChoice: pegMakeChoice,
    pegMakeCode: pegMakeCode,
    pegMakeLookaheadFailure: pegMakeLookaheadFailure,
    pegMakeLookaheadSuccess: pegMakeLookaheadSuccess,
    pegMakeMainSequence: pegMakeMainSequence,
    pegMakeOpt: pegMakeOpt,
    pegMakePlus: pegMakePlus,
    pegMakeSequence: pegMakeSequence,
    pegMakeStar: pegMakeStar,
    pegMakeString: pegMakeString,
    pegMakeToken: pegMakeToken,
    pegMakeTokenSet: pegMakeTokenSet,
    pegMakeTokenSetComplement: pegMakeTokenSetComplement,
    pegRuleAny: pegRuleAny,
    pegRuleEmpty: pegRuleEmpty,
    pegRuleEof: pegRuleEof,
    pegRuleFail: pegRuleFail,
    pegRuleLookaheadAny: pegRuleLookaheadAny
]
