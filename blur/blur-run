#!/bin/bash
#
# Copyright 2014 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>


#
# Directory and program name detection
#

# Preserve the original working dir as origDir.
origDir="${PWD}"

# Set progName to the program name, progDir to its directory, and baseDir
# to progDir's directory. Follows symlinks.
prog="$0"
while [[ -h ${prog} ]]; do
    [[ "$(/bin/ls -ld "${prog}")" =~ .*' -> '(.*)$ ]]
    newProg="${BASH_REMATCH[1]}"
    if [[ ${newProg} =~ ^/ ]]; then
        prog="${newProg}"
    else
        prog="$(dirname "${prog}")/${newProg}"
    fi
done
progName="$(basename "${prog}")"
progDir="$(dirname "${prog}")"
cd "${progDir}"
progDir="${PWD}"
cd ..
baseDir="${PWD}"
cd "${origDir}"
unset prog
unset newProg


#
# Argument parsing
#

# Error flag.
error=0

# File to find rules in.
rulesFile='-'

while [[ $1 != '' ]]; do
    opt="$1"
    if [[ ${opt} == '--' ]]; then
        shift
        break
    elif [[ ${opt} == '--help' ]]; then
        error='usage'
    elif [[ ${opt} =~ ^--rules=(.*) ]]; then
        rulesFile="${BASH_REMATCH[1]}"
    elif [[ ${opt} =~ ^- ]]; then
        echo "Unknown option: ${opt}" 1>&2
        error=1
    else
        break
    fi
    shift
done
unset opt

# Initial targets (files or named ids).
targets=("$@")

if [[ ${error} != 0 ]]; then
    echo 1>&2 "${progName} [--rules=<file>] (target-file | id) ..."
    if [[ ${error} == 'usage' ]]; then
        error=0
    fi
    exit ${error}
fi

if [[ ${rulesFile} == '-' ]]; then
    rulesFile='/dev/stdin'
fi


#
# OS detection
#

# OS flavor; either `bsd` or `linux`.
OS_FLAVOR=linux

if ! ls --version > /dev/null 2>&1; then
    OS_FLAVOR=bsd
fi


#
# Logging / spew
#

# Current depth
DEPTH=0

# Increase status message depth.
function enterLayer {
    (( DEPTH++ ))
}

# Decrease status message depth.
function leaveLayer {
    (( DEPTH-- ))
}

# Emit a status message.
function msg {
    local i
    for (( i = 0; i < DEPTH; i++ )); do
        printf '  '
    done

    echo "$@"
}


#
# Helper functions
#

# Gets the modification time of the given file.
function modTime {
    local file="$1"

    if [[ ${OS_FLAVOR} == bsd ]]; then
        stat -f %m "${file}"
    else
        stat --format=%Y "${file}"
    fi
}

# Makes an absolute path out of the given path, which might be either absolute
# or relative. This does not resolve symlinks but does flatten away `.` and
# `..` components.
function absPath {
    local path="$1"

    if [[ ! ${path} =~ ^/ ]]; then
        path="${PWD}/${path}"
    fi

    local result=() at=0
    while [[ ${path} != '' ]]; do
        if [[ ${path} =~ ^// ]]; then
            path="${path:1}"
        elif [[ ${path} =~ ^/\./ ]]; then
            path="${path:2}"
        elif [[ ${path} == '/.' ]]; then
            path=''
        elif [[ ${path} =~ ^/\.\./ ]]; then
            if (( at > 0 )); then
                (( at-- ))
            fi
            path="${path:3}"
        elif [[ ${path} == '/..' ]]; then
            if (( at > 0 )); then
                (( at-- ))
            fi
            path=''
        elif [[ ${path} == '/' ]]; then
            result[$at]=''
            path=''
            (( at++ ))
        else
            [[ ${path} =~ /([^/]*)(.*) ]]
            result[$at]="${BASH_REMATCH[1]}"
            path="${BASH_REMATCH[2]}"
            (( at++ ))
        fi
    done

    printf '/%s' "${result[@]}"
    printf '\n'
}

# Unquotes the given string.
function unquote {
    local s="$1"

    if [[ $s == "''" ]]; then
        # Empty string.
        return
    fi

    if [[ $s =~ ^"$'"(.*)"'"$ ]]; then
        # Remove `$'...'` cladding.
        s="${BASH_REMATCH[1]}"
    fi

    if [[ ! $s =~ '\' ]]; then
        # Easy out: No escapes.
        printf '%s' "$s"
        return
    fi

    local i result=''

    for (( i = 0; i < ${#s}; i++ )); do
        local c="${s:$i:1}"
        if [[ $c == '\' ]]; then
            ((i++))
            c="${s:$i:1}"
            case "$c" in
                ('n') c=$'\n' ;;
                ('r') c=$'\r' ;;
                ('t') c=$'\t' ;;
                (' '|'"'|"'") ;; # Pass through as-is.
                (*)
                    echo "Unknown character escape: ${c}" 1>&2
                    exit 1
                    ;;
            esac
        fi
        result+="$c"
    done

    printf '%s' "${result}"
}

# Combines `unquote` and `absPath`.
function unquoteAbs {
    absPath "$(unquote "$1")"
}

# Exits success if the given word is a defined id.
function isId {
    local id="$1"
    local i

    for (( i = 0; i < ${#IDS[@]}; i++ )); do
        if [[ "${IDS[$i]}" == "${id}" ]]; then
            return 0
        fi
    done

    return 1
}

# Collects all the rules into the `RULES` array (one element per rule). This
# also canonicalizes the spacing of rules, so that there's no initial indent,
# and one space after the command. Finally, this also sets up the `IDS` array,
# which lists all named ids.
RULES=()
IDS=()
function rulesInit {
    local cmd rest space curRule=()

    while read -r cmd rest; do
        if [[ ${rest} != '' ]]; then
            space=' '
        else
            space=''
        fi
        curRule+=("${cmd}${space}${rest}")
        case "${cmd}" in
            (start)
                curRule=()
                ;;
            (end)
                unset curRule[$((${#curRule[@]} - 1))]
                RULES+=("$(printf '%s\n' "${curRule[@]}")")
                curRule=()
                ;;
            (id)
                local id=("$(unquote "${rest}")")
                if ! isId "${id}"; then
                    IDS+=("${id}")
                fi
                ;;
        esac
    done < "${rulesFile}"
}

# Outputs a newline-separated list of all indices into `RULES` for rules
# associated with the given target.
function rulesFor {
    local target="$1"
    local i cmd rest cmdMatch=target

    if isId "${target}"; then
        cmdMatch=id
    fi

    for (( i = 0; i < ${#RULES[@]}; i++ )); do
        while read -r cmd rest; do
            if [[ ${cmd} != ${cmdMatch} ]]; then
                continue
            fi

            if [[ ${cmd} == id ]]; then
                if [[ "$(unquote "${rest}")" == ${target} ]]; then
                    echo "$i"
                fi
            else
                if [[ "$(unquoteAbs "${rest}")" == ${target} ]]; then
                    echo "$i"
                fi
            fi
        done <<< "${RULES[$i]}"
    done
}

# Runs the given rule if any of:
# * it has no sources
# * it has no targets
# * at least one target doesn't exist
# * at least one existing target has an older modification time than at least
#   one source
function runIfNeeded {
    # Split the rule into an array of lines.
    local rule=()
    IFS=$'\n' rule=($1)

    local newestSource=-1 oldestTarget=-1 line stamp cmd rest
    local runIt=no

    for line in "${rule[@]}"; do
        [[ ${line} =~ ^' '*([^ ]*)' '*(.*)$ ]]
        cmd="${BASH_REMATCH[1]}"
        rest="${BASH_REMATCH[2]}"
        case "${cmd}" in
            (source)
                rest="$(unquoteAbs "${rest}")"
                if [[ ! -e "${rest}" ]]; then
                    echo "Missing source: ${rest}" 1>&2
                    return 1
                fi
                stamp="$(modTime "${rest}")"
                if (( stamp > newestSource )); then
                    newestSource="${stamp}"
                fi
                ;;
            (target)
                rest="$(unquoteAbs "${rest}")"
                if [[ ! -e "${rest}" ]]; then
                    # Missing target. Means that we need to run the rule.
                    newestSource=-1
                    oldestTarget=-1
                    break
                fi
                stamp="$(modTime "${rest}")"
                if (( oldestTarget == -1 || stamp < oldestTarget )); then
                    oldestTarget="${stamp}"
                fi
                ;;
        esac
    done

    if (( newestSource > 0 && oldestTarget > 0 )); then
        if (( newestSource < oldestTarget )); then
            # Everything is up-to-date.
            return
        fi
    fi

    # Need to run the associated commands.

    for line in "${rule[@]}"; do
        [[ ${line} =~ ^' '*([^ ]*)' '*(.*)$ ]]
        cmd="${BASH_REMATCH[1]}"
        rest="${BASH_REMATCH[2]}"
        if [[ "${cmd}" == cmd ]]; then
            msg '$' "${rest}"
            bash -c "${rest}"
            local status="$?"
            if [[ ${status} != 0 ]]; then
                echo "Non-zero exit status: ${status}" 1>&1
                echo "On command:" 1>&2
                echo '  $' "${rest}" 1>&2
                return 1
            fi
        fi
    done
}

# Attempts to satisfy the indicated target. The target can be either a file
# name or a named id. This works by finding all the sources associated with
# the target, attempting (recursively) to satisfy them, and then running any
# commands associated with the target.
#
# If a target has already been satisfied at least once during this run,
# then it will not be tried again.
SATISFIED=()
function satisfyTarget {
    local target="$1"
    local i

    if ! isId "${target}"; then
        target="$(absPath "${target}")"
    fi

    for (( i = 0; i < ${#SATISFIED[@]}; i++ )); do
        if [[ ${target} == ${SATISFIED[$i]} ]]; then
            # The target has already been satisfied due to earlier activity.
            msg "!! ${target}"
            return
        fi
    done

    local rules=($(rulesFor "${target}"))

    if [[ ${#rules[@]} == 0 ]]; then
        if [[ ! -e "${target}" ]]; then
            echo 'No rules defined for non-existent target:' 1>&2
            echo "  ${target}" 1>&2
            return 1
        else
            msg "== ${target}"
            return
        fi
    fi

    msg ">> ${target}"
    enterLayer

    local error=no

    for (( i = 0; i < "${#rules[@]}"; i++ )); do
        if [[ ${error} == yes ]]; then
            break
        fi

        while read -r cmd rest; do
            if [[ ${cmd} == source ]]; then
                satisfyTarget "$(unquote "${rest}")"
                if [[ $? != 0 ]]; then
                    error=yes
                    break
                fi
            fi
        done <<< "${RULES[${rules[$i]}]}"
    done

    for (( i = 0; i < "${#rules[@]}"; i++ )); do
        if [[ ${error} == yes ]]; then
            break
        fi

        runIfNeeded "${RULES[${rules[$i]}]}"
        if [[ $? != 0 ]]; then
            error=yes
        fi
    done

    leaveLayer
    msg "<< ${target}"

    SATISFIED+=(${target})

    if [[ ${error} == yes ]]; then
        return 1
    fi
}


#
# Main script
#

rulesInit

for (( i = 0; i < ${#targets[@]}; i++ )); do
    satisfyTarget "${targets[$i]}"
    if [[ $? != 0 ]]; then
        exit 1
    fi
done
