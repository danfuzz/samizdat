Blur
====

Blur is a very simple build system.

"Blur" doesn't stand for anything, and it's certainly not a reference to
the tool's blazing fast speed. It's just a description of how
the stream of tears affects my vision whenever I contemplate having
to use Make... or do build system work in general.


Philosophy
----------

### "I'd rather write shell scripts than Makefiles."

I'm not going to claim that this is the be-all end-all of build
systems. However, it does have the nice properties of:

* Not requiring anything but a baseline OS installation, with Bash 3.2
  or later. (Notably, this is what OS X ships with, as of this writing.)

* Using the tried and true method of file timestamp comparison to figure out
  "freshness" of generated files with respect to dependencies. Sure, this
  has shortcomings, but at least those shortcomings are well understood,
  with known workarounds.

* Being a thin veneer on top of (or perhaps underneath) straight shell
  scripting, which -- face it! -- you end up having to do anyway when you're
  trying to define any nontrivial build, no matter what build system you're
  using.

* More specifically, having no invasive build syntax. A build file is just
  a rule-generator script, and rules are generated by calling commands,
  passing arguments just like one would do with any other shell commands.
  To the extent that there's syntax, it is like how the standard `find`
  command has syntax.

Rather than relegating scripts to an awkward corner of the build system,
and having a whole 'nother layer of syntax to layer it within, Blur flips
the relationship, so that rule definition is just a regular-looking command
invocation, embedded in a programming environment which you very likely
already know (if not love).


Summary
-------

Blur is invoked, unsurprisingly as:

```
blur [--<option> ...] [--] [<target> ...]
```

It takes the following options:

* `--in-dir=<dir>` &mdash; What directory to build in. Defaults to the
  current directory

* `--quiet` &mdash; Suppress all output other than errors.

* `--verbose=<level>` &mdash; Set output spew to be limited to the given
  level. `0` is the same as `--quiet`. `1` is the default. `2` through `4`
  also work and are (respectively) more and more spew-y.

* `--dump` &mdash; Causes all the rules to be dumped (printed) to stdout
  before proceeding with the main show.

* `--depth=<n>` &mdash; Sets up logging to be at the indicated depth. This
  is used when Blur recurses on itself, so that logging within inner
  invocations maintains consistent indentation with its outer environment.

Any other options get passed to the rule generation script (see below).

The `<target>`s are which targets to build. Targets can be either file
names (if non-absolute, relative to the directory being built) or
named ids. If no target is specified, it defaults to `build`.

On a given run, Blur will only ever attempt to run the commands associated
with a given rule at most once, no matter how many times that rule is
"activated" (via dependencies).

Rules are set up by writing a Bash script named `blur.sh`, and
placing it at the base directory of the source. Blur runs that file
while `cd`ed to its directory, with the Blur utility functions already
defined in its environment. It is passed as arguments any options
not understood by Blur itself. The file is responsible for writing a
set of build rules to stdout.

The rules script is also provided with the following environement
variables:

* `PROJECT_DIR` &mdash; Full path to the directory in which the rules
  script is located.
* `PROJECT_NAME` &mdash; Final path component of `PROJECT_DIR`.
* `BASE_DIR` &mdash; Parent directory of `PROJECT_DIR`.

The main utility function available to rules scripts is called `rule`.
`rule` is called as:

```
rule <type> [--<option> ...] [--] [<arg> ...]
```

Options and arguments vary with the type, except that every type accepts
these options:

* `--id=<name>` &mdash; Indicate that this rule can be required by using
  the indicated name.

* `--req=<target>` &mdash; Indicate that this rule requires the given target
  to be satisfied / built before it can proceed. `<target>` must be a file
  name (if non-absolute, relative to the directory being built).

* `--req-id=<id>` &mdash; Indicate that this rule requires the given named
  id to be satisfied / built before it can proceed.

* `--target=<file>` &mdash; Indicate that this rule produces the named target
  file.

* `--value=<string>` &mdash; Adds an arbitrary value passed to commands, when
  the targets are out-of-date. This is most useful within a req/target group.

* `--msg=<string>` &mdash; Causes the given message to be emitted when the
  rule is considered out-of-date.

* `--moot=<cmd>` &mdash; Runs the command when determining if the rule is
  out-of-date. If the command succeeds, then the rule is considered up-to-date,
  and so will not be run.

* `--assert=<cmd>` &mdash; Runs the command when determining if the rule is
  out-of-date. If the command fails, then the rule is considered to have
  failed.

* `--cmd=<cmd>` &mdash; Runs the command, when the rule is considered
  out-of-date. Array variables `STALE_TARGETS`, `NEW_REQS`, and `VALUES` are
  available to commands.

* `--build-in-dir=<dir>` &mdash; Runs Blur in the given directory, when the
  rule is considered out-of-date. Passes all stale targets to the command.

* `(` &hellip; `)` &mdash; Can be used to group
  together related sets of reqs and targets. When used, the staleness of a
  target only depends on the reqs in its group. It is only valid to used
  `--req=`, `--target=`, and `--value=` options within a group. Furthermore,
  if a rule has any groups, then *all* `--req=`, `--target=`, and `--value=`
  options must be in some group or other.

Some types accept one or more of these options:

* `--in-dir=<dir>` &mdash; Indicates that relative file name arguments
  should be taken to be in the given directory. By default, relative paths
  are taken to be relative to the source base directory (where the rules
  script is stored).

* `--out-dir=<dir>` &mdash; If the rule uses relative file names for both
  reqs and targets, this is how to specify the relative base for the
  targets.

When a rule is run, the following takes place, in this order:

* Rules for each of the reqs are run (recursively).
* Moots and asserts are run, in the order specified by the rule.
* Reqs that name files (as opposed to ones that are named ids) are checked
  for existence. It is a fatal error at this point if any file req doesn't
  exist. (Reqs get created by recursively attempting to satisfy them before
  rules are run. See below.)
* The timestamps of all reqs and targets are collected.
* If any target doesn't exist, or if any target is older than any req
  (limited to reqs in its group, if it is in a group), then the rule is
  considered out-of-date. Caveat: Timestamps on directories are ignored.
* If the rule has no targets at all, or has no reqs at all, it is always
  considered out-of-date.
* If the rule is considered out-of-date (per above), then its messages
  and commands are run, in the order specified by the rule.

The rule types are as follows:

* `body` &mdash; Catch-all. Has no semantics beyond the general rule
  semantics defined above.

* `copy --out-dir=<dir> [--in-dir=<dir>] [--chmod=<mode>] [--] <name> ...`
  &mdash; Copies files from a tree rooted in the indicated `in-dir` to a
  tree rooted in the indicated `out-dir` (which must be specified). Each of
  the `<name>`s must be a relative path within the directories. And each
  file copy operation is represented by its own rule. If `--chmod` is
  specified, each target is `chmod`ed to the indicated `mode` once copied.

* `mkdir <name> ...` &mdash; Makes directories with the given names. Each
  directory creation is its own rule.

* `rm [--in-dir=<dir>] <name> ...` &mdash; Removes files or directories with
  the given names. If `--in-dir` is specified, then relative paths are with
  respect to that directory (and not the source base directory).
  Each file removal is its own rule. Unless explicitly added, the emitted
  rules have no reqs and no targets. However, the rules are all automatically
  mooted with a check for the non-existence of the named files.

See the file `blur-utils.sh` for information about the other available
utilities.

Satisfying a Target
-------------------

The main operation of Blur is to "satisfy" the targets named on its
command-line. Each named target is satisfied, in order, as a separate
operation. (That is, Blur does not attempt to simultaneously satisfy
multiple targets, though that may happen as a byproduct of how rule
dependencies happen to be set up.)

Satisfying a target takes place in the following manner:

* All rules are selected which name the target as `target` file (per se) or
  a named id.

* The selected rules are iterated, in the order that they were specified
  by the original rules generation script. For each rule that has not yet
  been run, its `req`s are iterated over, in order. Target satisfaction is
  run on each `req`. (That is, this procedure is invoked recursively on each
  `req`.)

* The selected rules are iterated, in the order that they were specified
  by the original rules generation script. Each rule that has not yet
  been run is run, per the description of `rule` above, and then it is
  noted to have run.

Per the above, once a rule has been run once, it will not be run again.


Limitations
-----------

Blur has very few built-in rule types. Should it turn into a long-term
viable product, it is likely that the set of rule types will be expanded.

Blur has trouble with file names that end with newlines. (Embedded
newlines are just fine, though.) This is because of the shell semantics
around command substitution, which silently drops any end-of-output newlines.
It is possible to fix Blur with respect to this problem, but at the time of
this writing it was not considered worth the trouble.

If a req (dependency) and target have exactly the same timestamp, Blur
assumes that the target is up-to-date. Since timestamps have one-second
(not sub-second) granularity, it is possible for a target to be undetectably
out-of-date in some circular dependency situations. Of course, circular
dependency is a bad idea.
