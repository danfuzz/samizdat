Blur
====

Blur is a very simple build system.

"Blur" doesn't stand for anything. It's just a description of how
the stream of tears affects my vision whenever I contemplate having
to use Make... or do build system work in general.


Philosophy
----------

I'm not going to claim that this is the be-all end-all of build
systems. However, it does have the nice properties of:

* Not requiring anything but a baseline OS installation, with Bash 3.2
  or later. (Notably, this is what OS X ships with, as of this writing.)

* Using the tried and true method of file timestamp comparison to figure out
  "freshness" of generated files with respect to dependencies. Sure, this
  has shortcomings, but at least those shortcomings are well understood,
  with known workarounds.

* Being a thin veneer on top of (or perhaps underneath) straight shell
  scripting, which -- face it! -- you end up having to do anyway when you're
  trying to define any nontrivial build, no matter what build system you're
  using.

* More specifically, having no actual build syntax. A build file is just
  a rule-generator script, and rules are generated by calling a function,
  passing it arguments just like one would do with any other shell function.

Rather than relegating scripts to an awkward corner of the build system,
and having a whole 'nother layer of syntax to layer it within, Blur flips
the relationship, so that rule definition is just a regular-looking command
invocation, embedded in a programming environment which you very likely
already know (if not love).


Summary
-------

Blur is invoked, unsurprisingly as:

```
blur [--<option> ...] [--] [<target> ...]
```

It takes the following options:

* `--dir=<dir>` &mdash; What directory to build in. Defaults to the
  current directory

* `--quiet` &mdash; Suppress all output other than errors.

* `--verbose=<level>` &mdash; Set output spew to be limited to the given
  level. `0` is the same as `--quiet`. `1` is the default. `2` and `3`
  also work and are (respectively) more and more spew-y.

Any other options get passed to the rule generation script (see below).

The `<target>`s are which targets to build. Targets can be either file
names (if non-absolute, relative to the directory being built) or
named ids. If no target is specified, it defaults to `build`.

On a given run, Blur will only ever attempt to satisfy a given target
at most once, no matter how many times that target is mentioned on the
commandline or in rules being invoked.

Rules are set up by writing a Bash script named `blur.sh`, and
placing it at the base directory of the source. Blur runs that file
`cd`ed to its directory, with the Blur utility functions already
defined in its environment. It is passed as arguments any options
not understood by Blur itself. The file is responsible for writing a
set of build rules to stdout.

The main utility function available to rules scripts is called `rule`.
`rule` is called as:

```
rule <type> [--<option> ...] [--] [<arg> ...]
```

Options and arguments vary with the type, except that every type accepts
these options:

* `--id=<name>` &mdash; Indicate that this rule can be required by using
  the indicated name.

* `--req=<target>` &mdash; Indicate that this rule requires the given target
  to be satisfied / built before it can proceed. `<target>` can be either
  a file name (if non-absolute, relative to the directory being built) or
  a named id.

* `--target=<file>` &mdash; Indicate that this rule produces the named target
  file.

* `--msg=<string>` &mdash; Causes the given message to be emitted when the
  rule is considered out-of-date.

* `--moot=<cmd>` &mdash; Runs the command when determining if the rule is
  out-of-date. If the command succeeds, then the rule is considered up-to-date,
  and so will not be run.

* `--assert=<cmd>` &mdash; Runs the command when determining if the rule is
  out-of-date. If the command fails, then the rule is considered to have
  failed.

* `--cmd=<cmd>` &mdash; Runs the command when the rule is considered
  out-of-date.

When a rule is run, the following takes place, in this order:

* Rules for each reqs are run (recursively).
* Moots and asserts are run, in the order specified by the rule.
* Reqs are checked for existence. It is a fatal error at this point if
  any req doesn't exist.
* The timestamps of all reqs and targets are collected.
* If any target doesn't exist, or if any target is older than any req,
  then the rule is considered out-of-date. Caveat: Timestamps on directories
  are ignored.
* If the rule has no targets at all, or has no reqs at all, it is always
  considered out-of-date.
* If the rule is considered out-of-date (per above), then its messages
  and commands are run, in the order specified by the rule.

The rule types are as follows:

* `body` &mdash; Catch-all. Has no semantics beyond the general rule
  semantics defined above.

* `mkdir <name> ...` &mdash; Makes directories with the given names. Each
  directory creation is its own rule.

* `copy [--from-dir=<dir>] [--to-dir=<dir>] [--] <name> ...` &mdash;
  Copies files from a tree rooted in the indicated `from-dir` to a
  tree rooted in the indicated `to-dir`. Each of the `<name>`s must
  be a relative path within the directories. And each file copy operation
  is represented by its own rule.

See the file `blur-utils.sh` for information about the other available
utilities.


Limitations
-----------

Blur has very few built-in rule types. Should it turn into a long-term
viable product, it is likely that the set of rule types will be expanded.

Blur has trouble with file names that end with newlines. (Embedded
newlines are just fine, though.) This is because of the shell semantics
around command substitution, which silently drops end-of-response newlines.
It is possible to fix Blur, but at the time of this writing not considered
worth the trouble.

If a req (dependency) and target have exactly the same timestamp, Blur
assumes that the target is up-to-date. Since timestamps have one-second
(not sub-second) granularity, it is possible for a target to be undetectably
out-of-date in some circular dependency situations. Of course, circular
dependency is a bad idea.
