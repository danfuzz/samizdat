Blur
====

Blur is a very simple build system.

"Blur" doesn't stand for anything, and it's certainly not a reference to
the tool's blazing fast speed. It's just a description of how
the stream of tears affects my vision whenever I contemplate having
to use Make... or do build system work in general.


Philosophy
----------

I'm not going to claim that this is the be-all end-all of build
systems. However, it does have the nice properties of:

* Not requiring anything but a baseline OS installation, with Bash 3.2
  or later. (Notably, this is what OS X ships with, as of this writing.)

* Using the tried and true method of file timestamp comparison to figure out
  "freshness" of generated files with respect to dependencies. Sure, this
  has shortcomings, but at least those shortcomings are well understood,
  with known workarounds.

* Being a thin veneer on top of (or perhaps underneath) straight shell
  scripting, which -- face it! -- you end up having to do anyway when you're
  trying to define any nontrivial build, no matter what build system you're
  using.

* More specifically, having no invasive build syntax. A build file is just
  a rule-generator script, and rules are generated by calling commands,
  passing arguments just like one would do with any other shell commands.
  To the extent that there's syntax, it is like how the standard `find`
  command has syntax.

Rather than relegating scripts to an awkward corner of the build system,
and having a whole 'nother layer of syntax to layer it within, Blur flips
the relationship, so that rule definition is just a regular-looking command
invocation, embedded in a programming environment which you very likely
already know (if not love).


Summary
-------

Blur is invoked, unsurprisingly as:

```
blur [--<option> ...] [--] [<target> ...]
```

It takes the following options:

* `--in-dir=<dir>` &mdash; What directory to build in. Defaults to the
  current directory

* `--quiet` &mdash; Suppress all output other than errors.

* `--verbose=<level>` &mdash; Set output spew to be limited to the given
  level. `0` is the same as `--quiet`. `1` is the default. `2` and `3`
  also work and are (respectively) more and more spew-y.

* `--dump` &mdash; Causes all the rules to be dumped (printed) to stdout
  before proceeding with the main show.

Any other options get passed to the rule generation script (see below).

The `<target>`s are which targets to build. Targets can be either file
names (if non-absolute, relative to the directory being built) or
named ids. If no target is specified, it defaults to `build`.

On a given run, Blur will only ever attempt to satisfy a given target
at most once, no matter how many times that target is mentioned on the
commandline or in rules being invoked.

Rules are set up by writing a Bash script named `blur.sh`, and
placing it at the base directory of the source. Blur runs that file
`cd`ed to its directory, with the Blur utility functions already
defined in its environment. It is passed as arguments any options
not understood by Blur itself. The file is responsible for writing a
set of build rules to stdout.

The rules script is also provided with the following environement
variables:

* `PROJECT_DIR` &mdash; Full path to the directory in which the rules
  script is located.
* `PROJECT_NAME` &mdash; Final path component of `PROJECT_DIR`.
* `BASE_DIR` &mdash; Parent directory of `PROJECT_DIR`.

The main utility function available to rules scripts is called `rule`.
`rule` is called as:

```
rule <type> [--<option> ...] [--] [<arg> ...]
```

Options and arguments vary with the type, except that every type accepts
these options:

* `--id=<name>` &mdash; Indicate that this rule can be required by using
  the indicated name.

* `--req=<target>` &mdash; Indicate that this rule requires the given target
  to be satisfied / built before it can proceed. `<target>` must be a file
  name (if non-absolute, relative to the directory being built).

* `--req-id=<id>` &mdash; Indicate that this rule requires the given named
  id to be satisfied / built before it can proceed.

* `--target=<file>` &mdash; Indicate that this rule produces the named target
  file.

* `--msg=<string>` &mdash; Causes the given message to be emitted when the
  rule is considered out-of-date.

* `--moot=<cmd>` &mdash; Runs the command when determining if the rule is
  out-of-date. If the command succeeds, then the rule is considered up-to-date,
  and so will not be run.

* `--assert=<cmd>` &mdash; Runs the command when determining if the rule is
  out-of-date. If the command fails, then the rule is considered to have
  failed.

* `--cmd=<cmd>` &mdash; Runs the command when the rule is considered
  out-of-date. Array variables `STALE_TARGETS` and `NEW_REQS` are available
  to commands.

* `(` &hellip; `)` &mdash; Can be used to group
  together related sets of reqs and targets. When used, staleness of a target
  only depends on the reqs in its group. It is only valid to used `--req=`
  and `--target=` options within a group. Furthermore, if a rule has any
  groups, then all `--req=` and `--target=` options must be in a group.

Some types accept one or more of these options:

* `--in-dir=<dir>` &mdash; Indicates that relative file name arguments
  should be taken to be in the given directory. By default, relative paths
  are taken to be relative to the source base directory (where the rules
  script is stored).

* `--out-dir=<dir>` &mdash; If the rule uses relative file names for both
  reqs and targets, this is how to specify the relative base for the
  targets.

When a rule is run, the following takes place, in this order:

* Rules for each of the reqs are run (recursively).
* Moots and asserts are run, in the order specified by the rule.
* Reqs are checked for existence. It is a fatal error at this point if
  any req doesn't exist. (Reqs get created by recursively attempting to
  satisfy them before rules are run. See below.)
* The timestamps of all reqs and targets are collected.
* If any target doesn't exist, or if any target is older than any req,
  then the rule is considered out-of-date. Caveat: Timestamps on directories
  are ignored.
* If the rule has no targets at all, or has no reqs at all, it is always
  considered out-of-date.
* If the rule is considered out-of-date (per above), then its messages
  and commands are run, in the order specified by the rule.

The rule types are as follows:

* `body` &mdash; Catch-all. Has no semantics beyond the general rule
  semantics defined above.

* `copy --out-dir=<dir> [--in-dir=<dir>] [--chmod=<mode>] [--] <name> ...`
  &mdash; Copies files from a tree rooted in the indicated `from-dir` to a
  tree rooted in the indicated `out-dir` (which must be specified). Each of
  the `<name>`s must be a relative path within the directories. And each
  file copy operation is represented by its own rule. If `--chmod` is
  specified, each target is `chmod`ed to the indicated `mode`.

* `mkdir <name> ...` &mdash; Makes directories with the given names. Each
  directory creation is its own rule.

* `rm [--in-dir=<dir>] <name> ...` &mdash; Removes files or directories with
  the given names. If `--in-dir` is specified, then relative paths are with
  respect to that directory (and not the source base directory).
  Each file is its own rule. Unless explicitly added, the emitted rules have
  no reqs and no targets. However, the rules are all automatically mooted with
  a check for the non-existence of the named files.

See the file `blur-utils.sh` for information about the other available
utilities.

Satisfying a Target
-------------------

The main operation of Blur is to "satisfy" the targets named on its
command-line. Each named target is satisfied, in order, as a separate
operation. (That is, Blur does not attempt to simultaneously satisfy
multiple targets, though that may happen as a byproduct of how rule
dependencies happen to be set up.) Once a target is considered satisfied,
Blur will not attempt to re-satisfy it during a single run of the program.

Satisfying a target takes place in the following manner:

* All rules are selected which name the target as `target` file (per se) or
  a named id.

* If the target is a named id, then further rules are selected if there
  are any others that have `target`s in common with the `target`s of rules
  already selected. This additional rule selection repeats with any
  newly-selected rules, and so on, until a full transitive closure of rules
  is found.

* The selected rules are iterated, in the order that they were specified
  by the original rules generation script. For each rule, its `req`s are
  iterated over, in order. Target satisfaction is run on each `req`. (That is,
  this procedure is invoked recursively on each `req`.)

* The selected rules are iterated, in the order that they were specified
  by the original rules generation script. Each rule is run, per the
  description of `rule`, above.


Limitations
-----------

Blur has very few built-in rule types. Should it turn into a long-term
viable product, it is likely that the set of rule types will be expanded.

Blur has trouble with file names that end with newlines. (Embedded
newlines are just fine, though.) This is because of the shell semantics
around command substitution, which silently drops end-of-response newlines.
It is possible to fix Blur, but at the time of this writing not considered
worth the trouble.

If a req (dependency) and target have exactly the same timestamp, Blur
assumes that the target is up-to-date. Since timestamps have one-second
(not sub-second) granularity, it is possible for a target to be undetectably
out-of-date in some circular dependency situations. Of course, circular
dependency is a bad idea.
