# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Unary operator demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper Definitions
#

# Prints out the given value.
fn msg(value) {
    io0Note("\%q(value)");
};

fn weirdSize(value) {
    def payload = dataOf(value);
    <> first(payload)
};

fn weirdNth(value, n) {
    ifIs { <> lt(n, 0) }
        { return };

    def payload = dataOf(value);
    def size = weirdSize(value);

    ifIs { <> ge(n, size) }
        { return };

    <> nth(payload, add(n, 1))
};

# Method dispatch table. This is implicitly referenced (by name) by the
# `.` and `[]` ops.
def DISPATCH = [
    (List): [
        get:  nth,
        nth:  nth,
        size: size
    ],
    (Map): [
        get:  get,
        nth:  nth,
        size: size
    ],
    Weird: [
        get:  weirdNth,
        nth:  weirdNth,
        size: weirdSize
    ]
];


#
# Main Tests
#

io0Note("\nList");
msg([1, 2].size());
msg(["zero", "one", "two"].get(0));
msg(["zero", "one", "two"].nth(1));
msg(["zero", "one", "two"][2]);

io0Note("\nMap");
msg([a: "aardvark"].size());
msg([a: "aardvark", b: "bear"].get("a"));
msg([a: "aardvark", b: "bear"].nth(1));
msg([a: "aardvark", b: "bear", c: "capybara"]["c"]);

io0Note("\nWeird");
def weirdValue = @[Weird: [3, @x, @y, @z, @p, @d, @q]];
msg(weirdValue.size());
msg(weirdValue.get(2));
msg(weirdValue.nth(4)?);
msg(weirdValue[0]);

io0Note("\nExpression syntax for name");
msg(weirdValue."size"());
msg(weirdValue.(cat("s", "ize"))());

io0Note("\nGetting raw methods");
def method1 = [1, 2, 3].size;
msg(method1());

def method2 = [4, 5, 6].(cat("n", "th"));
msg(method2(1));

<> 0
