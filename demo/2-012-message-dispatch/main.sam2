# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Unary operator demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper Definitions
#

# Prints out the given value.
fn msg(value) {
    io0Note("\%q(value)");
};

fn weirdSizeOf(value) {
    def payload = dataOf(value);
    <> first(payload)
};

fn weirdNth(value, n) {
    ifIs { <> lt(n, 0) }
        { return };

    def payload = dataOf(value);
    def size = weirdSize(value);

    ifIs { <> ge(n, size) }
        { return };

    <> nth(payload, add(n, 1))
};

# Method dispatch table. This is implicitly referenced (by name) by the
# `.` and `[]` ops.
def DISPATCH = [
    (List): [
        get:    nth,
        nth:    nth,
        sizeOf: sizeOf
    ],
    (Map): [
        get:  get,
        nth:  nth,
        sizeOf: sizeOf
    ],
    Weird: [
        get:    weirdNth,
        nth:    weirdNth,
        sizeOf: weirdSizeOf
    ]
];


#
# Main Tests
#

io0Note("\nList");
msg([1, 2].sizeOf());
msg(["zero", "one", "two"].get(0));
msg(["zero", "one", "two"].nth(1));
msg(["zero", "one", "two"][2]);

io0Note("\nMap");
msg([a: "aardvark"].sizeOf());
msg([a: "aardvark", b: "bear"].get("a"));
msg([a: "aardvark", b: "bear"].nth(1));
msg([a: "aardvark", b: "bear", c: "capybara"]["c"]);

io0Note("\nWeird");
def weirdValue = @[Weird: [3, @x, @y, @z, @p, @d, @q]];
msg(weirdValue.sizeOf());
msg(weirdValue.get(2));
msg(weirdValue.nth(4)?);
msg(weirdValue[0]);

io0Note("\nExpression syntax for name");
msg(weirdValue."sizeOf"());
msg(weirdValue.(cat("size", "Of"))());

io0Note("\nGetting raw methods");
def method1 = [1, 2, 3].sizeOf;
msg(method1());

def method2 = [4, 5, 6].(cat("n", "th"));
msg(method2(1));

<> 0
