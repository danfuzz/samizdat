# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Generator function demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper Definitions
#

# Prints the given value, indented slightly.
fn msg(value) {
    io0Note(cat("  ", sourceString(value)))
};

# Outputs all generated values, with an initial header, followed by
# the listification of the generator, all followed by an extra newline
# at the end.
fn msgAll(header, gen) {
    io0Note(header);

    { <done> ::
        loopReduce(gen) { gen ::
            def box = makeYieldBox();
            <> ifValue { <> gen(box) }
                { nextGen ::
                    msg(fetch(box));
                    <> [nextGen]
                }
                { <done> }
        }
    }();

    io0Note("  [all]");
    msg(collectGenerator(gen));
    io0Note("")
};



#
# Main Tests
#

msgAll("Empty list", generatorFromValue([]));
msgAll("Empty map", generatorFromValue([:]));
msgAll("Empty string", generatorFromValue(""));
msgAll("Empty paraGenerator", paraGenerator());
msgAll("Empty seqGenerator", seqGenerator());

msgAll("List", generatorFromValue([101, 33, 5555, "blort"]));
msgAll("Map",
    generatorFromValue([one: 1, two: 2, three: 3, four: 4, five: "fizmo"]));
msgAll("String", generatorFromValue("Happy string!"));

msgAll("Single-item paraGenerator",
    paraGenerator(["blort", "igram", "fizmo"]));

msgAll("All-finite paraGenerator",
    paraGenerator(
        [1, 2, 3],
        "abcdefg",
        [a: "a!", b: "b!", c: "c!", d: "d!", e: "e!"]));

msgAll("Paragenerator with opt element",
    paraGenerator(
        optGenerator([1, 2, 3]),
        "abcdefg",
        [a: "a!", b: "b!", c: "c!", d: "d!", e: "e!"]));

msgAll("Filter generator (square even numbers)",
    filterGenerator([1, 2, 3, 4, 5, 6, 7, 8, 9])
        { value ::
            <> ifIs { <> eq(mod(value, 2), 0) }
                { <> mul(value, value) }
        });

io0Note("doGenerator on filter");
doGenerator(
    filterGenerator([1, 2, 3, 4])
        { value :: io0Note(cat("    Yay ", sourceString(value))) });
io0Note("");

msgAll("Token generator", tokenGenerator("Tokens!"));

msgAll("Inclusive range 5..10",
    inclusiveRange(5, 1, 10));

msgAll("Inclusive range 10..-2..1",
    inclusiveRange(10, -2, 1));

msgAll("Inclusive range \"a\"..5..\"z\"",
    inclusiveRange("a", 5, "z"));

msgAll("Exclusive range 5..10",
    exclusiveRange(5, 1, 10));

msgAll("Exclusive range 10..-2..1",
    exclusiveRange(10, -2, 1));

msgAll("Exclusive range \"a\"..5..\"z\"",
    exclusiveRange("a", 5, "z"));

msgAll("ParaGenerator with open ranges",
    paraGenerator(
        openRange("a", 1),
        openRange(100, 10),
        [1, 2, 3, 4, 5, 6, 7]));

msgAll("Zero-increment int range",
    inclusiveRange(10, 0, 20));

msgAll("Zero-increment character range",
    inclusiveRange("x", 0, "a"));

msgAll("Size one SeqGenerator",
    seqGenerator([a: 10, b: 20, c: 30]));

msgAll("Size two SeqGenerator",
    seqGenerator(
        [a: 10, b: 20, c: 30],
        "defg"));

msgAll("Size five SeqGenerator (with a couple pre-voided generators)",
    seqGenerator("abc", [], [], ["def", "ghi"], []));

msgAll("Single-generator reduceGenerator",
    reduceGenerator([[1, 2, 3, 4]], [0])
        { elem, result <> [add(elem, result)] });

def doRedA = doReduce([[1, 2, 3, 4]], [0])
    { elem, result <> [add(elem, result)] };
io0Note(cat("  corresponding doReduce: ", sourceString(doRedA)));
def doRedA1 = doReduce1([1, 2, 3, 4], 0)
    { elem, result <> add(elem, result) };
io0Note(cat("  corresponding doReduce1: ", sourceString(doRedA1)));
io0Note("");

msgAll("Two-generator reduceGenerator",
    reduceGenerator([["like", "hate"], ["biscuits", "fish sticks"]], [""])
        { verb, noun, result ::
            <> [cat(result, "I ", verb, " ", noun, ". ")]
        });

def doRedB = doReduce([["like", "hate"], ["biscuits", "fish sticks"]], [""])
    { verb, noun, result ::
        <> [cat(result, "I ", verb, " ", noun, ". ")]
    };
io0Note(cat("  corresponding doReduce: ", sourceString(doRedB)));
io0Note("");

msgAll("Two-reduction reduceGenerator",
    reduceGenerator([[1, 2, 3, 4]], [0, 1])
        { num, sum, product <> [add(sum, num), mul(product, num)] });

def doRedC = doReduce([[1, 2, 3, 4]], [0, 1])
    { num, sum, product <> [add(sum, num), mul(product, num)] };
io0Note(cat("  corresponding doReduce: ", sourceString(doRedC)));
io0Note("");

io0Note("mapFromGenerator on filter");
def outMap = mapFromGenerator(
    filterGenerator(inclusiveRange(0, 2, 4))
        { value ::
            <> [(value): value, add(value, 1): value, blort: value]
        });
io0Note(cat("    ", sourceString(outMap)));
io0Note("");


<> 0
