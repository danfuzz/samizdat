# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Demo / scratch code
#


# This declares the arguments to the program itself.
SELF_PATH ARGS* ::


#
# Helper definitions
#

# Example of self-recursion using `yCombinator`. This is how a simple
# self-recursive Samizdat function might end up looking when coverted
# into Samizdat Layer 0 form.
#
# Returns a list with int contents that count down from `n`,
# generated recursively. The "main" function literal here is wrapped
# in an outer function layer, whose argument is used to achieve
# recursion.
countDown = yCombinator { countDown ::
    <> { n ::
        <> ifTrue { <> ge(n, 0) }
            { <> listPrepend(n, countDown(isub(n, 1))) }
            { <> [] }
    }
};

# Example of mutual recursion using `yStarCombinator`. See discussion
# above.
countDowns = yStarCombinator
    { f1 f2 ::
        <> { n ::
            <> ifTrue { <> gt(n, 0) }
                { <> listPrepend(n, f2(isub(n, 1))) }
                { <> [0] }
        }
    }
    { f1 f2 ::
        <> { n :: <> listPrepend("and", f1(n)) }
    };
countDown2 = listNth(countDowns, 0);

# Demo of formal argument repeat modifiers. Also of quoted identifiers.
blort = { foo bar? \"weird name"? more* ::
    io0Note(format("%q %q %q %q", foo, bar, \"weird name", more))
};

# Demo of `+` argument repeat modifier.
stuff = { items+ ::
    io0Note(format("stuff: %q", items))
};

# Demo of reading a sibling file through a sandboxed reader.
sibling = {
    reader = io0SandboxedReader(listButLast(SELF_PATH));
    text = reader(["sibling.txt"]);
    io0Note(text);
};

# Demo of nonlocal exit.
exiter = { foo <out> ::
    ifTrue { <> eq(foo, 1) }
        { <out> "one" }
        { <out> }
};

# Demo of `mutableBox`.
boxer = {
    box = mutableBox(10);

    listForEach([1 2 3]) { . n :: box(iadd(box(), n)) };
    <> box()
};

# Emits the stringified version of the given value to the console.
process = { value ::
    io0Note(sourceString(value));

    # Test of explicit void yield.
    <>
};


#
# Main function
#

main = { selfPath name rest* ::
    # Be welcoming.

    ifTrue { <> eq(name, "danfuzz") }
        { io0Note("Hello, Danfuzz!\n") }
        { io0Note("Hello, Самиздат!\n") };

    process(selfPath);
    process(rest);
    process(0);
    process(98765);
    process(-12345);
    process([]);
    process([(-1)]);
    process(listButFirst([0 1 (-2)]));
    process(listReverse(listButLast([(-1) 2 300 999])));
    process(listButFirst([], ""));
    process(listButLast([], "Самиздат"));
    process("\"Blort.\" \\ \0 \n");
    process(stringSlice("muffins", 1, 6));
    process([=]);
    process([1=2]);
    process([1=2 888=1]);
    process(["fizmo"="omzif" "igram"="margi" "blort"="trolb"]);
    process(@["null"]);
    process(@"null");
    process(@null);
    process(null);
    process(false);
    process(true);
    process(@blort);
    process(@"%fizmo%");
    process(@@);
    process(countDown(10));
    process(countDown2(5));
    process(boxer());
    process(metaFunctions(LIBRARY, "blort.sam0"));
    process(io0PathFromFlat("///foo//////./bar/../baz"));
    process(io0FlatFromPath(["fizmo" "igram" "blort" ""]));

    sibling();

    blort(1);
    blort(1, 2);
    blort(1, 2, 3);
    blort(1, 2, 3, 4);
    blort(1, 2, 3, 4, 5);
    partialApply(blort, 1, [2 3 4])(5, 6);
    stuff(1);
    stuff(1, 2);

    process(exiter(1));
    ifValue { <> exiter(0) }
        { value :: io0Note(format("Unexpected! %q", value)) }
        { io0Note "The void." };
};

<> apply(main, SELF_PATH, ARGS)
