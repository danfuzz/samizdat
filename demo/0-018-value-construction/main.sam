## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Demo of value construction
##

#= language core.Lang0


##
## Private Definitions
##

## Expects the two values to be `eq`.
fn expectSame(v1, v2) {
    ifIs { eq(v1, v2) }
        { note("Yes.") }
        {
            note("Different: ",
                $Format::source(v1), ", ", $Format::source(v2))
        }
};

## Expects the two values to be `ne`.
fn expectDifferent(v1, v2) {
    ifIs { ne(v1, v2) }
        { note("Yes.") }
        { note("Same: ", $Format::source(v1)) }
};

## Expects the value to be a core value.
fn expectCore(v) {
    ifIs { hasType(v, DerivedData) }
        { note("Derived: ", $Format::source(v)) }
        {
            ifValue { <> dataOf(v) }
                { data -> note("Bad data: ", $Format::source(data)) }
                { note("Yes.") }
        }
};

## Expects the value to be a derived data value.
fn expectDerived(v) {
    ifIs { hasType(v, DerivedData) }
        { note("Yes.") }
        { note("Opaque: ", $Format::source(v)) }
};


##
## Main Tests
##
## Expect everything to be a "yes."
##

## Int

note("Int");

expectSame(0, 0);
expectSame(100, 100);
expectSame(-1000, -1000);
expectSame(12345678, 12345678);
expectSame(0, -0);
expectSame($Number::add(1, 10), 11);
expectSame($Number::add(99998880, 8), 99998888);

expectDifferent(0, 1);
expectDifferent(99998888, -99998888);

expectCore(0);
expectCore(-1);
expectCore(987654321);


## List

note("\nList");

expectSame([], []);
expectSame([0], [0]);
expectSame([[]], [[]]);
expectSame([0, 0, 0], [0, 0, 0]);
expectSame([[]*, 1], [1]);
expectSame([1, 2, [3, 4]*], [1, [2, 3]*, 4]);
expectSame(cat([9, 8, 7], [6, 5, 4]), [9, 8, 7, 6, 5, 4]);
expectSame($Sequence::sliceInclusive([1], 1), []);

expectDifferent([], [[]]);
expectDifferent([1], [2]);

expectCore([]);
expectCore([1]);
expectCore([1, 2, [3, 4, 5]]);


## Map

note("\nMap");

expectSame({}, {});
expectSame({a: 10}, {a: 10});
expectSame({a: 10}, {"a": 10});
expectSame({{}: {}}, {{}: {}});
expectSame({x: 5, y: 7}, {y: 7, x: 5});
expectSame({["x", "y", "z"]*: "blort"}, {x: "blort", y: "blort", z: "blort"});
expectSame({{a: 1}*, b: 2}, {a: 1, b: 2});
expectSame(cat({10: 1}, {30: 3}, {20: 2}), {10: 1, 20: 2, 30: 3});
expectSame($Collection::nthMapping({a: 10, b: 20}, 0), {a: 10});

expectDifferent({["x"]: "blort"}, {"x": "blort"});

## The first map's keys are strings in the following.
expectDifferent({null: 1}, {(null): 1});
expectDifferent({true: 1}, {(true): 1});
expectDifferent({false: 1}, {(false): 1});

expectCore({});
expectCore({0: 0});
expectCore({blort: "fizmo"});


## String

note("\nString");

expectSame("", "");
expectSame("x", "x");
expectSame("blort", "blort");
expectSame(cat("blort", "-fizmo", "-igram"), "blort-fizmo-igram");
expectSame(nth("frotz", 4), "z");

expectDifferent("blort", "Blort");
expectDifferent("blort", "blort ");
expectDifferent("blort", "blort\0");

expectCore("");
expectCore("x");
expectCore("muffins");


## Uniqlet

note("\nUniqlet");

def uniq1 = makeUniqlet();
def uniq2 = makeUniqlet();

expectSame(uniq1, uniq1);
expectSame(uniq2, uniq2);
expectDifferent(uniq1, uniq2);
expectDifferent(uniq2, uniq1);
expectCore(uniq1);
expectCore(uniq2);


## Function

note("\nFunction");

def fn1 = { x <> x };
def fn2 = { x <> x };

expectSame(fn1, fn1);
expectSame(fn2, fn2);
expectDifferent(fn1, fn2);
expectDifferent(fn2, fn1);
expectCore(fn1);
expectCore(fn2);


## Derived values

note("\nDerived values");

expectSame(@boo, @boo);
expectSame(@boo, @"boo");
expectSame(@boo, @(@@"boo"));
expectSame(null, @Null);
expectSame(null, @"Null");
expectSame(null, @(@@Null));
expectSame(false, @Boolean(0));
expectSame(true, @Boolean(1));
expectSame(@eek(10), @(@@eek)(10));
expectSame(@eek(10), @eek($Number::add(5, 5)));
expectSame(@eek(10), @(@@(cat("ee", "k")))(10));

expectDifferent(@x, @x(1));
expectDifferent(@x(1), @x(2));
expectDifferent(@x(1), @y(1));

## The first value's type names are strings in the following.
expectDifferent(@null(1), @(@@(null))(1));
expectDifferent(@true(1), @(@@(true))(1));
expectDifferent(@false(1), @(@@(false))(1));

expectDerived(@blort);
expectDerived(@fizmo("igram"));
expectDerived(null);
expectDerived(false);
expectDerived(true);
