# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Demo / scratch code
#


# This declares the arguments to the program itself.
ARGS* ::


#
# Helper definitions
#

# Self-recursion helper function. This function takes another function as
# its argument, in return yielding a function of one fewer argument.
# When the resulting function is called, it in turn calls the original
# function, prepending a new first argument. The new first argument is a
# function which, when called, performs a recursive call on the original
# function.
#
# Per Wikipedia [Fixed-point
# combinator](http://en.wikipedia.org/wiki/Fixed-point_combinator),
# this is an example of the "X combinator", which is the call-by-value
# cousin of the better-known "Y combinator".
#
# Although it is written here using a variable assignment, it's just
# for readability and not strictly necessary. That is, the definition
# of `applicator` doesn't directly refer to the variable `applicator`.
#
xCombinator = { func ::
    applicator = { selfRef ::
        <> { rest* :: <> apply func (selfRef selfRef) rest }
    };

    <> applicator applicator;
};

# Returns a listlet with intlet contents that count down from `n`,
# generated recursively. The function literal here takes one extra
# argument than the "exposed" function, namely an initial argument
# that is used for achieving recursion. See `fuzzCombinator` above.
countDown = xCombinator { countDown n ::
    <> ifTrue { <> ge n @0 }
        { <> listletPrepend n (countDown (isub n @1)) }
        { <> @[] }
};

# Emits the stringified version of the given value to the console.
process = { value ::
    io0Note (sourceStringlet value)
};

#
# Main function
#

main = { selfPath name rest* ::
    # Be welcoming.

    if { <> eq name @danfuzz } {
        io0Note @"Hello, Danfuzz!\n"
    } else {
        io0Note @"Hello, Самиздат!\n"
    };

    process selfPath;
    process rest;
    process @0;
    process @98765;
    process @-12345;
    process @[];
    process @[@-1];
    process @[@1 @-2];
    process @[@-1 @2 @300];
    process @"";
    process @"\"Blort.\" \n";
    process @[=];
    process @[@1=@2];
    process @[@1=@2 @888=@1];
    process @[@fizmo=@omzif @igram=@margi @blort=@trolb];
    process null;
    process false;
    process true;
    process @@;
    process (countDown @10);
};

<> apply main ARGS
