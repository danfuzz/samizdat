# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Demo / scratch code
#


# This declares the arguments to the program itself.
ARGS* ::


#
# Helper definitions
#

# Self-recursion helper function.
#
# Short version: If you want to make a recursive function, you can write
# it like this:
#
# ```
# myRecursiveFunction = xCombinator { selfCall ::
#     # Inner function.
#     <> { myArg1 myArg2 ... ::
#         ... my code ...
#         selfCall args ...
#         ... my code ...
#     }
# };
# ```
#
# In the example above, a call to `selfCall` will end up recursively
# calling into the (so-labeled) inner function.
#
# Long version:
#
# This function takes another function as its argument, called the
# "wrapper" function. That function must take a single argument, which itself
# is a function, called the "recurser" function. The "wrapper" function must
# return yet another function, called the "inner" function. The return value
# of this function, called the "result" function, is a function which, when
# called, ends up calling the wrapper function and then calling the inner
# function that the wrapper function returned.
#
# The inner function is an arbitrary function, taking arbitrary arguments,
# returning anything including void, and performing any arbitrary
# actions in its body. In particular, it can be written to call the
# "recurser" argument passed to its wrapper. If it does so, that will in
# turn result in a recursive call to itself.
#
# This function is used to write recursive functions without relying
# on use-before-def variable binding.
#
# Per Wikipedia [Fixed-point
# combinator](http://en.wikipedia.org/wiki/Fixed-point_combinator),
# this is a variation of the "X combinator", which is the call-by-value
# cousin of the better-known "Y combinator".
#
# Although it is coded here using a variable assignment, it's just
# for readability and not strictly necessary. That is, the definition
# of `applicator` doesn't directly refer to the variable `applicator`.
#
xCombinator = { function ::
    uCombinator = { x :: <> x x };
    applicator = { selfRef ::
        <> { args* :: <> apply (function (uCombinator selfRef)) args }
    };

    <> applicator applicator;
};

# Returns a listlet with intlet contents that count down from `n`,
# generated recursively. The "main" function literal here is wrapped
# in an outer function layer, whose argument is used to achieve
# recursion. See `xCombinator` above.
countDown = xCombinator { countDown ::
    <> { n ::
        <> ifTrue { <> ge n @0 }
            { <> listletPrepend n (countDown (isub n @1)) }
            { <> @[] }
    }
};

# Emits the stringified version of the given value to the console.
process = { value ::
    io0Note (sourceStringlet value)
};


#
# Main function
#

main = { selfPath name rest* ::
    # Be welcoming.

    if { <> eq name @danfuzz } {
        io0Note @"Hello, Danfuzz!\n"
    } else {
        io0Note @"Hello, Самиздат!\n"
    };

    process selfPath;
    process rest;
    process @0;
    process @98765;
    process @-12345;
    process @[];
    process @[@-1];
    process @[@1 @-2];
    process @[@-1 @2 @300];
    process @"";
    process @"\"Blort.\" \n";
    process @[=];
    process @[@1=@2];
    process @[@1=@2 @888=@1];
    process @[@fizmo=@omzif @igram=@margi @blort=@trolb];
    process null;
    process false;
    process true;
    process @@;
    process (countDown @10);
};

<> apply main ARGS
