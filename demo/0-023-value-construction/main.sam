## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Demo of value construction
##

#= language core.Lang0


##
## Private Definitions
##

## Expects the two values to be `eq`.
fn expectSame(v1, v2) {
    ifIs { eq(v1, v2) }
        { note("Yes.") }
        {
            die("Different: ",
                $Format::source(v1), ", ", $Format::source(v2))
        }
};

## Expects the two values to be `ne`.
fn expectDifferent(v1, v2) {
    ifIs { ne(v1, v2) }
        { note("Yes.") }
        { die("Same: ", $Format::source(v1)) }
};

## Expects the value to be a core value.
fn expectCore(v) {
    ifIs { hasClass(v, DerivedData) }
        { die("Derived: ", $Format::source(v)) }
        { note("Yes.") }
};

## Expects the value to be a derived data value.
fn expectDerived(v) {
    ifIs { hasClass(v, DerivedData) }
        { note("Yes.") }
        { die("Opaque: ", $Format::source(v)) }
};


##
## Main Tests
##
## Expect everything to be a "yes."
##

## Null

note("Null");

expectSame(null, null);

expectCore(null);


## Bool

note("Bool");

expectDifferent(false, true);

expectCore(false);
expectCore(true);


## Int

note("\nInt");

expectSame(0, 0);
expectSame(100, 100);
expectSame(-1000, -1000);
expectSame(12345678, 12345678);
expectSame(0, -0);
expectSame((1).add(10), 11);
expectSame((99998880).add(8), 99998888);

expectDifferent(0, 1);
expectDifferent(99998888, -99998888);

expectCore(0);
expectCore(-1);
expectCore(987654321);


## List

note("\nList");

expectSame([], []);
expectSame([0], [0]);
expectSame([[]], [[]]);
expectSame([0, 0, 0], [0, 0, 0]);
expectSame([[]*, 1], [1]);
expectSame([1, 2, [3, 4]*], [1, [2, 3]*, 4]);
expectSame([9, 8, 7].cat([6, 5, 4]), [9, 8, 7, 6, 5, 4]);
expectSame([1].sliceInclusive(1), []);

expectDifferent([], [[]]);
expectDifferent([1], [2]);

expectCore([]);
expectCore([1]);
expectCore([1, 2, [3, 4, 5]]);


## Map

note("\nMap");

expectSame({}, {});
expectSame({a: 10}, {a: 10});
expectSame({a: 10}, {@a: 10});
expectSame({{}: {}}, {{}: {}});
expectSame({x: 5, y: 7}, {y: 7, x: 5});
expectSame({[@x, @y, @z]*: "blort"}, {x: "blort", y: "blort", z: "blort"});
expectSame({{a: 1}*, b: 2}, {a: 1, b: 2});
expectSame({10: 1}.cat({30: 3}, {20: 2}), {10: 1, 20: 2, 30: 3});
expectSame({a: 10, b: 20}.nthMapping(0), {a: 10});

expectDifferent({[@x]: "blort"}, {x: "blort"});

## The first map's keys are strings in the following.
expectDifferent({null: 1}, {(null): 1});
expectDifferent({true: 1}, {(true): 1});
expectDifferent({false: 1}, {(false): 1});

expectCore({});
expectCore({0: 0});
expectCore({blort: "fizmo"});


## String

note("\nString");

expectSame("", "");
expectSame("x", "x");
expectSame("blort", "blort");
expectSame("blort".cat("-fizmo", "-igram"), "blort-fizmo-igram");
expectSame("frotz".nth(4), "z");

expectDifferent("blort", "Blort");
expectDifferent("blort", "blort ");
expectDifferent("blort", "blort\0");

expectCore("");
expectCore("x");
expectCore("muffins");


## Function

note("\nFunction");

def fn1 = { x -> x };
def fn2 = { x -> x };

expectSame(fn1, fn1);
expectSame(fn2, fn2);
expectDifferent(fn1, fn2);
expectDifferent(fn2, fn1);
expectCore(fn1);
expectCore(fn2);


## Symbol

note("\nSymbols");

expectSame(@boo, @boo);
expectSame(@boo, @"boo");

expectCore(@boo);


## Derived values

note("\nDerived values");

expectSame(@eek{x: 10}, @(@@eek){x: 10});
expectSame(@eek{x: 10}, @eek{x: (5).add(5)});
expectSame(@eek{x: 10}, @(@@("eek".toSymbol())){x: 10});

expectDifferent(@x{}, @x{a: 1});
expectDifferent(@x{a: 1}, @x{a: 2});
expectDifferent(@x{a: 1}, @y{a: 1});

expectDerived(@fizmo{});
