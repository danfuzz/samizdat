# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operator demo. Also demos hex and binary numbers, and "digit spaces".
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ->


#
# Helper Definitions
#

# Prints out the given value.
fn msg(value) {
    io0Note(sourceString(value))
};

# Prints out the given value in hex.
fn msgHex(value) {
    io0Note("\%x(value)")
};

# Returns void.
fn returnVoid() {
    <>
};


#
# Main Tests
#

# Different bases, and digit spaces.
io0Note("Literals");
msg(1);
msg(1_234);
msg(0x1004);
msg(0b1111_1010);

# Operators.
io0Note("\nInt operators");
msg(1 + 2);
msg(2 - 1);
msg(3 * 4);
msg(6 / 3);
msg(5 % 2);
msg(6 // 3);
msg(5 %% 2);
msg(1 + 2 * 3);
msg((1 + 2) * 3);
msg(2 * 3 * 4 + 5);

msgHex(0xfff0 &&& 0x0fff);
msgHex(0xfff0 ||| 0x0fff);
msgHex(0xfff0 ^^^ 0x0fff);
msgHex(0x00ff <<< 0x8);
msgHex(0xff00 >>> 0x8);

# Ordering. The ones expected to be "falsey" are surrounded by `??` to
# make them easily printable.

io0Note("\nPer-type Order 1");
msg(1 == 1);
msg(1 != 2);
msg(1 < 3);
msg(5 > 4);
msg(1 <= 5);
msg(6 >= 6);
msg("a" == "a");
msg("a" != "b");
msg("a" < "c");

io0Note("\nPer-type Order 2");
msg((1 != 1)??);
msg((1 == 2)??);
msg((1 >= 2)??);
msg((2 <= 1)??);
msg((1 > 2)??);
msg((2 < 2)??);
msg(([1] > [1])??);
msg(([1] <= [0])??);
msg(([1] >= [2])??);

io0Note("\nPer-type Order 3");
msg(1 < 2 < 20);
msg(100 == 100 > 21);
msg(10 >= 5 < 22);
msg(2 != 3 != 23);
msg((1 != 1 < 2)??);
msg((2 > 3 == 3)??);
msg((4 < 5 == 6)??);
msg((9 < 10 < 11 < 12 != 12)??);

io0Note("\nTotal Order 1");
msg(1 \== 1);
msg(1 \!= 2);
msg(1 \< 3);
msg(5 \> 4);
msg(1 \<= 5);
msg(6 \>= 6);
msg("a" \== "a");
msg("a" \!= "b");
msg("a" \< "c");

io0Note("\nTotal Order 2");
msg((1 \!= 1)??);
msg((1 \== 2)??);
msg((1 \>= 2)??);
msg((2 \<= 1)??);
msg((1 \> 2)??);
msg((2 \< 2)??);
msg(([1] \> [1])??);
msg(([1] \<= [0])??);
msg(([1] \>= [2])??);

io0Note("\nTotal Order 3");
msg(1 \< 2 \< 20);
msg(100 \== 100 \> 21);
msg(10 \>= 5 \< 22);
msg(2 \!= 3 \!= 23);
msg((1 \!= 1 \< 2)??);
msg((2 \> 3 \== 3)??);
msg((4 \< 5 \== 6)??);
msg((9 \< 10 \< 11 \< 12 \!= 12)??);

io0Note("\nTotal Order 4");
msg(0 \== 0);
msg(1 \!= "1");
msg([1] \!= "2");
msg({1: 1} \!= "3");
msg("1" \!= 4);
msg(1 \< [5]);
msg(1 \< [6: 6]);
msg(1 \< "7");
msg([1] \< [8: 8]);
msg([1] \< "9");
msg({1: 1} \< "10");
msg("1" \> 11);
msg(1 \<= [12]);
msg("1" \>= {13: 13});

# Logical ops. The ones expected to be "falsey" are surrounded by `??` to
# make them easily printable.
io0Note("\nLogic 1");
msg(1 & 2);
msg(1 & 2 & "three");
msg((1 == 1) & (4 == 4));
msg((1 == 1) & (2 == 2) & (5 == 5));
msg((1 == 1) & (2 == 2) & (3 == 3) & (6 == 6));

msg((returnVoid() & "a")??);
msg((returnVoid() & returnVoid())??);
msg((returnVoid() & returnVoid() & returnVoid())??);
msg((returnVoid() & returnVoid() & returnVoid() & "a")??);
msg(((1 == 1) & (1 == 2))??);
msg(((1 == 1) & (1 == 2) & (3 == 3))??);
msg(((1 == 2) & (2 == 2) & (3 == 3))??);
msg(((1 == 1) & (2 == 2) & (3 == 4))??);

msg((x := 1) & neg(x));
msg((foo := 1) & (bar := neg(foo)) & add(-foo, bar));
msg((blort := "th") & (1 == 1) & (fizmo := "ree") & cat(blort, fizmo));

io0Note("\nLogic 2");
msg(10 | true);
msg(20 | returnVoid());
msg(returnVoid() | 30);
msg(returnVoid() | 40 | returnVoid());
msg(returnVoid() | returnVoid() | 50 | returnVoid());
msg(returnVoid() | returnVoid() | returnVoid() | 60);

msg((returnVoid() | returnVoid())??);
msg((returnVoid() | returnVoid() | returnVoid())??);
msg((returnVoid() | returnVoid() | returnVoid() | returnVoid())??);

<> 0
