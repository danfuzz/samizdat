## Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Generator function demo
##

def Io0 = moduleUse({name: ["core", "Io0"]});


##
## Helper Definitions
##

## Prints the given value, indented slightly.
fn msg(value) {
    Io0::note(cat("  ", Format::source(value)))
};

## Outputs all generated values, with an initial header, followed by
## the listification of the generator, all followed by an extra newline
## at the end.
fn msgAll(header, gen) {
    Io0::note(header);

    { <done> ->
        loopReduce(gen) { gen ->
            def box = Box::makePromise();
            <> ifValue { <> Generator::nextValue(gen, box) }
                { nextGen ->
                    msg(Box::fetch(box));
                    <> [nextGen]
                }
                { <done> }
        }
    }();

    Io0::note("  [all]");
    msg(Generator::collect(gen));
    Io0::note("")
};



##
## Main Tests
##

msgAll("Empty list", []);
msgAll("Empty map", {});
msgAll("Empty string", "");
msgAll("NullGenerator", Generator::nullGenerator);
msgAll("Empty ListWrapGenerator", Generator::makeListWrapGenerator([]));
msgAll("Empty ParaGenerator", Generator::makeParaGenerator());
msgAll("Empty SerialGenerator", Generator::makeSerialGenerator());
msgAll("Empty RepeatGenerator", Generator::makeRepeatGenerator(0));
msgAll("RepeatGenerator with default value",
    Generator::makeRepeatGenerator(7));
msgAll("RepeatGenerator with string value",
    Generator::makeRepeatGenerator(3, "blort"));

msgAll("List", [101, 33, 5555, "blort"]);
msgAll("Map", {one: 1, two: 2, three: 3, four: 4, five: "fizmo"});
msgAll("String", "Happy string!");

msgAll("ListWrapGenerator", Generator::makeListWrapGenerator("frotz"));

msgAll("Single-item ParaGenerator",
    Generator::makeParaGenerator(["blort", "igram", "fizmo"]));

msgAll("All-finite ParaGenerator",
    Generator::makeParaGenerator(
        [1, 2, 3],
        "abcdefg",
        {a: "a!", b: "b!", c: "c!", d: "d!", e: "e!"}));

msgAll("ParaGenerator with opt element and ValueGenerator",
    Generator::makeParaGenerator(
        Generator::makeOptGenerator([1, 2, 3]),
        Generator::makeValueGenerator("blort"),
        "abcdefg",
        {a: "a!", b: "b!", c: "c!", d: "d!", e: "e!"}));

msgAll("FilterGenerator (square even numbers)",
    Generator::makeFilterGenerator([1, 2, 3, 4, 5, 6, 7, 8, 9])
        { value ->
            <> ifIs { <> eq(Number::mod(value, 2), 0) }
                { <> Number::mul(value, value) }
        });

Io0::note("generatorPump on FilterGenerator");
Generator::generatorPump(
    Generator::makeFilterGenerator([1, 2, 3, 4])
        { value -> Io0::note(cat("    Yay ", Format::source(value))) });
Io0::note("");

msgAll("ParaGenerator with open ranges",
    Generator::makeParaGenerator(
        Range::makeOpenRange("a"),
        Range::makeOpenRange(100, 10),
        [1, 2, 3, 4, 5, 6, 7]));

msgAll("Size one SerialGenerator",
    Generator::makeSerialGenerator({a: 10, b: 20, c: 30}));

msgAll("Size two SerialGenerator",
    Generator::makeSerialGenerator(
        {a: 10, b: 20, c: 30},
        "defg"));

msgAll("Size six SerialGenerator (with a couple pre-voided generators)",
    Generator::makeSerialGenerator(
        "abc",
        [],
        [],
        Generator::nullGenerator,
        ["def", "ghi"],
        []));

Io0::note("collectAsMap on a FilterGenerator");
def outMap = Generator::collectAsMap(
    Generator::makeFilterGenerator(Range::makeInclusiveRange(0, 4, 2))
        { value ->
            <> {(value): value, (Number::add(value, 1)): value, blort: value}
        });
Io0::note(cat("    ", Format::source(outMap)));
Io0::note("");


<> 0
