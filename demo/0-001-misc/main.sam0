# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Demo / scratch code
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ->

def Io0 = moduleGet({name: ["core", "Io0"]});


#
# Helper Definitions
#

# Demo of `+` argument repeat modifier.
fn stuff(items+) {
    Io0::note(cat("stuff: ", Format::source(items)))
};

# Demo of formal argument repeat modifiers. Also of quoted identifiers.
fn blort(foo, bar?, \"weird name"?, more*) {
    stuff(foo, bar, \"weird name", more)
};

# Emits the stringified version of the given value to the console.
fn process(value) {
    Io0::note(Format::source(value));

    # Test of explicit void yield.
    <>
};


#
# Main Tests
#

fn main(selfPath, name?, rest*) {
    # Be welcoming.

    ifIs { <> eq(&(name*), "danfuzz") }
        { Io0::note("Hello, Danfuzz!\n") }
        { Io0::note("Hello, Самиздат!\n") };

    process(selfPath);
    process(rest);
    process(0);
    process(98765);
    process(-12345);
    process([]);
    process([(-1)]);
    process(Collection::butFirst([0, 1, -2]));
    process(Sequence::reverse(Collection::butLast([-1, 2, 300, 999])));
    process(Sequence::reverse("!niffuM"));
    process("\"Blort.\" \\ \0 \n");
    process(slice("^muffins^", 1, 8));
    process(slice(["x", "y", "muffins", "biscuits"], 2));
    process(slice({a: "apple", b: "biscuit", s: "scones"}, 2, 3));
    process(del("mufxfins", 3));
    process(del(["pie", "fishburgers", "croissants"], 1));
    process(del({one: 1, two: 2, three: 3}, "two"));
    process(put("bizcuits", 2, "s"));
    process(put(["scones", "natto"], 1, "ice cream"));
    process(put({one: 1, two: 2, three: 3}, "four", 4));
    process(keyList([@a, @b, @c]));
    process(keyList("abcde"));
    process(keyList({a: "apple", b: "butter"}));
    process({});
    process({1: 2});
    process({1: 2, 888: 1});
    process({fizmo: "omzif", igram: "margi", blort: "trolb"});
    process({"#stuff": "muff", ["x", "y"]: "zee"});
    process(@["Null"]);
    process(@"Null");
    process(@Null);
    process(null);
    process(false);
    process(true);
    process(@blort);
    process(@"%fizmo%");
    process(@[potion: "blort"]);
    process(@["^zorch^": ["scorch"]]);
    process(@def); # Demos that keywords can be used as token types.
    process(@[fn]); # Ditto.
    process({def: "defined", fn: "done"}); # Likewise, for map keys.
    process(@[(null)]);
    process(makeUniqlet());
    process(blort);
    process(LIBRARY::cat);
    process(LIBRARY::ne);
    process(ENVIRONMENT::HOME);
    process(Format::int(71, 2));
    process(Format::int(71, 10));
    process(Format::int(71, 16));
    process(Format::int(71, 36));
    process(cat(toString(1), toString(31), toString(127)));

    blort(1);
    blort(1, 2);
    blort(1, 2, 3);
    blort(1, 2, 3, 4);
    blort(1, 2, 3, 4, 5);
    stuff(1);
    stuff(1, 2);
};

<> main(SELF_PATH, ARGS*)
