# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Demo / scratch code
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper Definitions
#

# Demo of `+` argument repeat modifier.
fn stuff(items+) {
    io0Note(cat("stuff: ", sourceString(items)))
};

# Demo of formal argument repeat modifiers. Also of quoted identifiers.
fn blort(foo, bar?, \"weird name"?, more*) {
    stuff(foo, bar, \"weird name", more)
};

# Demo of reading a sibling file through a sandboxed reader.
fn sibling() {
    def reader = io0SandboxedReader(butLast(SELF_PATH));
    def text = reader(["sibling.txt"]);
    io0Note(text);
};

# Demo of nonlocal exit.
fn <out> exiter(foo) {
    ifIs { <> eq(foo, 1) }
        { <out> "one" }
        { <out> }
};

# Demo of `makeMutableBox`.
fn boxer() {
    def box = makeMutableBox(10);

    doFilter([1, 2, 3]) { n :: store(box, add(fetch(box), n)) };
    <> fetch(box)
};

# Emits the stringified version of the given value to the console.
fn process(value) {
    io0Note(sourceString(value));

    # Test of explicit void yield.
    <>
};


#
# Main Tests
#

fn main(selfPath, name?, rest*) {
    # Be welcoming.

    ifIs { <> eq(&(name*), "danfuzz") }
        { io0Note("Hello, Danfuzz!\n") }
        { io0Note("Hello, Самиздат!\n") };

    process(selfPath);
    process(rest);
    process(0);
    process(98765);
    process(-12345);
    process([]);
    process([(-1)]);
    process(butFirst([0, 1, -2]));
    process(reverse(butLast([-1, 2, 300, 999])));
    process(reverse("!niffuM"));
    process("\"Blort.\" \\ \0 \n");
    process(slice("^muffins^", 1, 8));
    process(slice(["x", "y", "muffins", "biscuits"], 2));
    process(slice([a: "apple", b: "biscuit", s: "scones"], 2, 3));
    process(del("mufxfins", 3));
    process(del(["pie", "fishburgers", "croissants"], 1));
    process(del([one: 1, two: 2, three: 3], "two"));
    process(put("bizcuits", 2, "s"));
    process(put(["scones", "natto"], 1, "ice cream"));
    process(put([one: 1, two: 2, three: 3], "four", 4));
    process(keyList([@a, @b, @c]));
    process(keyList("abcde"));
    process(keyList([a: "apple", b: "butter"]));
    process([:]);
    process([1: 2]);
    process([1: 2, 888: 1]);
    process([fizmo: "omzif", igram: "margi", blort: "trolb"]);
    process(["#stuff": "muff", ["x", "y"]: "zee"]);
    process(@["Null"]);
    process(@"Null");
    process(@Null);
    process(null);
    process(false);
    process(true);
    process(nullBox);
    process(@blort);
    process(@"%fizmo%");
    process(@[potion: "blort"]);
    process(@["^zorch^": ["scorch"]]);
    process(@if); # Demos that keywords can be used as token types.
    process(@[while]); # Ditto.
    process([def: "defined", do: "done"]); # Likewise, for map keys.
    process(@[(null)]);
    process(makeUniqlet());
    process(boxer());
    process(metaFunctions(LIBRARY, "blort.sam0"));
    process(io0PathFromFlat("///foo//////./bar/./../baz"));
    process(io0PathFromFlat("/a/b/x/y/z/../../../c/"));
    process(io0FlatFromPath(["fizmo", "igram", "blort", ""]));
    process(formatInt(71, 2));
    process(formatInt(71, 10));
    process(formatInt(71, 16));
    process(formatInt(71, 36));
    process(cat(charFromInt(1), charFromInt(31), charFromInt(127)));

    sibling();

    blort(1);
    blort(1, 2);
    blort(1, 2, 3);
    blort(1, 2, 3, 4);
    blort(1, 2, 3, 4, 5);
    stuff(1);
    stuff(1, 2);

    process(exiter(1));
    ifValue { <> exiter(0) }
        { value :: io0Note("Unexpected!") }
        { io0Note("The void.") };
};

<> main(SELF_PATH, ARGS*)
