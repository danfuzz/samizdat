# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Demo / scratch code
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper definitions
#

# Example of self-recursion using `yCombinator`. This is how a simple
# self-recursive Samizdat function might end up looking when coverted
# into Samizdat Layer 0 form.
#
# Returns a list with int contents that count down from `n`,
# generated recursively. The "main" function literal here is wrapped
# in an outer function layer, whose argument is used to achieve
# recursion.
def countDown = yCombinator { countDown ::
    <> { n ::
        <> ifIs { <> ge(n, 0) }
            { <> [n, countDown(isub(n, 1))*] }
            { <> [] }
    }
};

# Example of mutual recursion using `yStarCombinator`. See discussion
# above.
def countDowns = yStarCombinator
    { f1, f2 ::
        <> { n ::
            <> ifIs { <> gt(n, 0) }
                { <> [n, f2(isub(n, 1))*] }
                { <> [0] }
        }
    }
    { f1, f2 ::
        <> { n :: <> ["and", f1(n)*] }
    };
def countDown2 = listNth(countDowns, 0);

# Demo of formal argument repeat modifiers. Also of quoted identifiers.
fn blort(foo, bar?, \"weird name"?, more*) {
    io0Note(format("%q %q %q %q", foo, bar, \"weird name", more))
};

# Demo of `+` argument repeat modifier.
fn stuff(items+) {
    io0Note(format("stuff: %q", items))
};

# Demo of reading a sibling file through a sandboxed reader.
fn sibling() {
    def reader = io0SandboxedReader(listButLast(SELF_PATH));
    def text = reader(["sibling.txt"]);
    io0Note(text);
};

# Demo of nonlocal exit.
fn <out> exiter(foo) {
    ifIs { <> eq(foo, 1) }
        { <out> "one" }
        { <out> }
};

# Demo of `mutableBox`.
fn boxer() {
    def box = mutableBox(10);

    listForEach([1, 2, 3]) { ., n :: boxSet(box, iadd(boxGet(box), n)) };
    <> boxGet(box)
};

# Emits the stringified version of the given value to the console.
fn process(value) {
    io0Note(sourceString(value));

    # Test of explicit void yield.
    <>
};


#
# Main function
#

fn main(selfPath, name, rest*) {
    # Be welcoming.

    ifIs { <> eq(name, "danfuzz") }
        { io0Note("Hello, Danfuzz!\n") }
        { io0Note("Hello, Самиздат!\n") };

    process(selfPath);
    process(rest);
    process(0);
    process(98765);
    process(-12345);
    process([]);
    process([(-1)]);
    process(listButFirst([0, 1, -2]));
    process(listReverse(listButLast([-1, 2, 300, 999])));
    process(listButFirst([], ""));
    process(listButLast([], "Самиздат"));
    process("\"Blort.\" \\ \0 \n");
    process(stringSlice("muffins", 1, 6));
    process([:]);
    process([1: 2]);
    process([1: 2, 888: 1]);
    process([fizmo: "omzif", igram: "margi", blort: "trolb"]);
    process(["#stuff": "muff", ["x", "y"]: "zee"]);
    process(@["null"]);
    process(@"null");
    process(@null);
    process(null);
    process(false);
    process(true);
    process(@blort);
    process(@"%fizmo%");
    process(@[potion: "blort"]);
    process(@["^zorch^": ["scorch"]]);
    process(@if); # Demos that keywords can be used as token types.
    process(@[while]); # Ditto.
    process([def: "defined", do: "done"]); # Likewise, for map keys.
    process(@[(null)]);
    process(@@);
    process(countDown(10));
    process(countDown2(5));
    process(boxer());
    process(metaFunctions(LIBRARY, "blort.sam0"));
    process(io0PathFromFlat("///foo//////./bar/../baz"));
    process(io0FlatFromPath(["fizmo", "igram", "blort", ""]));
    process(stringFromInt(71, 2));
    process(stringFromInt(71, 10));
    process(stringFromInt(71, 16));
    process(stringFromInt(71, 36));
    process(stringAdd(charFromInt(1), charFromInt(31), charFromInt(127)));

    sibling();

    blort(1);
    blort(1, 2);
    blort(1, 2, 3);
    blort(1, 2, 3, 4);
    blort(1, 2, 3, 4, 5);
    partialApply(blort, 1, 2, 3, 4)(5, 6);
    stuff(1);
    stuff(1, 2);

    process(exiter(1));
    ifValue { <> exiter(0) }
        { value :: io0Note(format("Unexpected! %q", value)) }
        { io0Note("The void.") };
};

<> main(SELF_PATH, ARGS*)
