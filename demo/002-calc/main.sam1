# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Calculator Demo
#


# This declares the arguments to the program itself.
SELF_PATH ARGS* ::


#
# Helper definitions
#

# Takes an initial value and a list of one-argument functions, and
# does a reduction by applying each of the functions in order.
applyAll = { initialValue functions ::
    <> listReduce initialValue functions
        { result . function :: <> function result }
};

digit = {/
    ch = ["0123456789"]
    { <> isub (intFromString ch) (intFromString "0") }
/};

number = {/
    digits = digit+
    {
        <> listReduce 0 digits
            { result digit :: <> iadd digit (imul result 10) }
    }
/};

atom = {/
    number
|
    "("
    ex = addExpression
    ")"
    { <> ex }
/};

unaryOp = {/
    "-" { <> ineg }
/};

unaryExpression = {/
    ops = unaryOp*
    ex = atom
    { <> applyAll ex (listReverse ops) }
/};

mulOp = {/
    "*" { <> imul }
|
    "/" { <> idiv }
/};

mulExpression = {/
    firstEx = unaryExpression
    opExes = (
        op = mulOp
        ex = unaryExpression
        { <> { n :: <> op n ex } }
    )*
    { <> applyAll firstEx opExes }
/};

addOp = {/
    "+" { <> iadd }
|
    "-" { <> isub }
/};

addExpression = {/
    firstEx = mulExpression
    opExes = (
        op = addOp
        ex = mulExpression
        { <> { n :: <> op n ex } }
    )*
    { <> applyAll firstEx opExes }
/};

main = {/
    (
        ex = addExpression
        "\n"
        {
            io0Note (format "%q" ex);
            # Explicit yield here to indicate successful parsing.
            <> null
        }
    )*
/};

calculate = { exprString ::
    # TODO
    <> 10;
};


#
# Main function
#

main = { args* ::
    exprString = listReduce "" args { result . one :: <> stringAdd result one };
    result = calculate exprString;
    io0Note (format "%q" result);
};

<> apply main ARGS
