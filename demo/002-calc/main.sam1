# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Calculator Demo
#


# This declares the arguments to the program itself.
SELF_PATH ARGS* ::


#
# Helper definitions
#

# Takes an initial value and a list of one-argument functions, and
# does a reduction by applying each of the functions in order.
applyAll = { initialValue functions ::
    <> listReduce initialValue functions
        { result . function :: <> function result }
};

# Forward declaration of `addExpression`.
addExpression = forwardFunction();

# Parses a single digit, yielding its value as an int.
digit = {/
    ch = ["0123456789"]
    { <> isub (intFromString (tokenType ch)) (intFromString "0") }
/};

# Parses a whole number (non-negative integer), yielding its value as an int.
number = {/
    digits = digit+
    {
        <> listReduce 0 digits
            { result . digit :: <> iadd digit (imul result 10) }
    }
/};

# Parses an atomic expression. In this case it's either a number or a
# parenthesized expression. Yields the number or evaluated expression result,
# respectively.
atom = {/
    number
|
    "("
    ex = addExpression
    ")"
    { <> ex }
/};

# Parses a unary (in this case, prefix) operation, yielding its corresponding
# function.
unaryOp = {/
    "-" { <> ineg }
|
    "+" { <> { x :: <> x } }
/};

# Parses a unary expression, that is, a series of unary operators followed
# by an atom, yielding the evaluated result.
unaryExpression = {/
    ops = unaryOp*
    ex = atom
    { <> applyAll ex (listReverse ops) }
/};

# Parses an infix binary multiplicative operation, yielding its corresponding
# function.
mulOp = {/
    "*" { <> imul }
|
    "/" { <> idiv }
|
    "%" { <> irem }
/};

# Parses a multiplicative expression, that is, a series of unary expressions
# separated by multiplicative operators, yielding the evaluated result.
mulExpression = {/
    firstEx = unaryExpression
    opExes = (
        op = mulOp
        ex = unaryExpression
        { <> { n :: <> op n ex } }
    )*
    { <> applyAll firstEx opExes }
/};

# Parses an infix binary additive operation, yielding its corresponding
# function.
addOp = {/
    "+" { <> iadd }
|
    "-" { <> isub }
/};

# Parses an additive expression, that is, a series of multiplicative
# expressions separated by additive operators, yielding the evaluated result.
addExpressionImpl = {/
    firstEx = mulExpression
    opExes = (
        op = addOp
        ex = mulExpression
        { <> { n :: <> op n ex } }
    )*
    { <> applyAll firstEx opExes }
/};
addExpression addExpressionImpl;

# Evaluates all the expressions passed to it, printing the evaluated results
# in order. Each expression is expected to be terminated with a newline.
evalExpressions = {/
    (
        ex = addExpression
        "\n"
        {
            io0Note (format "%q" ex);
            # Explicit yield here to indicate successful parsing.
            <> null
        }
    )*
/};


#
# Main function
#

main = { args* ::
    exprString = listReduce "" args
        { result . one :: <> stringAdd result one "\n" };
    pegApply evalExpressions exprString;
};

<> apply main ARGS
