## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Generator function demo
##

#= language core.Lang0

import core.Generator :: *;


##
## Private Definitions
##

## Prints the given value, indented slightly.
fn msg(value) {
    note("  ", $Format::source(value))
};

## Outputs all generated values, with an initial header, followed by
## the listification of the generator, all followed by an extra newline
## at the end.
fn msgAll(header, origGen) {
    note(header);

    var gen = origGen;
    { /done ->
        loop {
            def result;
            ifValue { gen.nextValue(result?) }
                { nextGen ->
                    msg(result);
                    gen := nextGen
                }
                { yield /done }
        }
    }();

    note("  [all]");
    msg(origGen.collect());
    note()
};


##
## Main Tests
##

msgAll("Empty list", []);
msgAll("Empty map", {});
msgAll("Empty string", "");
msgAll("NullGenerator", nullGenerator);
msgAll("Empty ListWrapGenerator", ListWrapGenerator.new([]));
msgAll("Empty ParaGenerator", ParaGenerator.new());
msgAll("Empty SerialGenerator", SerialGenerator.new());
msgAll("Empty RepeatGenerator", makeRepeatGenerator(0));
msgAll("RepeatGenerator with default value",
    makeRepeatGenerator(7));
msgAll("RepeatGenerator with string value",
    makeRepeatGenerator(3, "blort"));

msgAll("List", [101, 33, 5555, "blort"]);
msgAll("Map", {one: 1, two: 2, three: 3, four: 4, five: "fizmo"});
msgAll("String", "Happy string!");

msgAll("ListWrapGenerator", ListWrapGenerator.new("frotz"));

msgAll("Single-item ParaGenerator",
    ParaGenerator.new(["blort", "igram", "fizmo"]));

msgAll("All-finite ParaGenerator",
    ParaGenerator.new(
        [1, 2, 3],
        "abcdefg",
        {a: "a!", b: "b!", c: "c!", d: "d!", e: "e!"}));

msgAll("ParaGenerator with opt element and ValueGenerator",
    ParaGenerator.new(
        OptGenerator.new([1, 2, 3]),
        ValueGenerator.new("blort"),
        "abcdefg",
        {a: "a!", b: "b!", c: "c!", d: "d!", e: "e!"}));

msgAll("FilterGenerator (square even numbers)",
    makeFilterGenerator([1, 2, 3, 4, 5, 6, 7, 8, 9])
        { value ->
            ifIs { eq(value.mod(2), 0) }
                { value.mul(value) }
        });

note("generatorPump on FilterGenerator");
var pumped = generatorPump(
    makeFilterGenerator([1, 2, 3, 4])
        { value ->
            note("    Yay ", $Format::source(value));
            ifIs { eq(value, 3) }
                { value.add(100) }
        });
note("Got: ", $Format::source(pumped), "\n");

note("filterPump (one generator)");
pumped := filterPump([1, 2, 3, 4])
    { value ->
        note("    Yay ", $Format::source(value));
        ifIs { le(value, 3) }
            { value.add(100) }
    };
note("Got: ", $Format::source(pumped), "\n");

note("filterPump (two generators)");
pumped := filterPump("abcdefg", [1, 2, 3, 4])
    { ch, value ->
        note("    Yay ", ch, " ", $Format::source(value));
        ifIs { eq(value, 3) }
            { value.add(100) }
    };
note("Got: ", $Format::source(pumped), "\n");

msgAll("ParaGenerator with open ranges",
    ParaGenerator.new(
        $Range::OpenRange.new("a"),
        $Range::OpenRange.new(100, 10),
        [1, 2, 3, 4, 5, 6, 7]));

msgAll("Size one SerialGenerator",
    SerialGenerator.new({a: 10, b: 20, c: 30}));

msgAll("Size two SerialGenerator",
    SerialGenerator.new(
        {a: 10, b: 20, c: 30},
        "defg"));

msgAll("Size six SerialGenerator (with a couple pre-voided generators)",
    SerialGenerator.new(
        "abc",
        [],
        [],
        nullGenerator,
        ["def", "ghi"],
        []));
