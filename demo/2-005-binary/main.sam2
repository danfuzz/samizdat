# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operator demo. Also demos hex and binary numbers, and "digit spaces".
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper definitions
#

# Prints out the given value.
fn out(value) {
    io0Note(sourceString(value))
};

# Prints out the given value in hex.
fn outHex(value) {
    io0Note("\%x(value)")
};

# Returns void.
fn returnVoid() {
    <>
};


#
# Main tests
#

# Different bases, and digit spaces.
out(1);
out(1_234);
out(0x1004);
out(0b1111_1010);

# Operators.
out(1 + 2);
out(2 - 1);
out(3 * 4);
out(6 / 3);
out(5 % 2);
out(1 + 2 * 3);
out((1 + 2) * 3);
out(2 * 3 * 4 + 5);

outHex(0xfff0 &&& 0x0fff);
outHex(0xfff0 ||| 0x0fff);
outHex(0xfff0 ^^^ 0x0fff);
outHex(0x00ff <<< 0x8);
outHex(0xff00 >>> 0x8);

# Ordering. The ones expected to be "falsey" are surrounded by `&&` to
# make them easily printable.
out("Order 1");
out(1 == 1);
out(1 != 2);
out(1 < 3);
out(5 > 4);
out(1 <= 5);
out(6 >= 6);
out("a" \== "a");
out("a" \!= "b");
out("a" \< "c");

out("Order 2");
out(&&(1 != 1));
out(&&(1 == 2));
out(&&(1 >= 2));
out(&&(2 <= 1));
out(&&(1 > 2));
out(&&(2 < 2));
out(&&([1] \> [1]));
out(&&([1] \<= [0]));
out(&&([1] \>= [2]));

out("Order 3");
out(1 < 2 < 20);
out(100 == 100 > 21);
out(10 >= 5 < 22);
out(2 != 3 != 23);

out(&&(1 != 1 < 2));
out(&&(2 > 3 == 3));
out(&&(4 < 5 == 6));
out(&&(9 < 10 < 11 < 12 != 12));

# Booleans.
out("Boolean 1");
out(true && true);
out(true && true && true);
out(&&(1 == 1) && &&(2 == 2));
out(&&(1 == 1) && &&(2 == 2) && &&(3 == 3));
out(&&(1 == 1) && &&(2 == 2) && &&(3 == 3) && &&(4 == 4));

out(false && true);
out(false && false);
out(&&(1 == 1) && &&(1 == 2));
out(&&(1 == 1) && &&(1 == 2) && &&(3 == 3));
out(&&(1 == 2) && &&(2 == 2) && &&(3 == 3));

out("Boolean 2");
out(true || true);
out(true || false);
out(false || true || false);

out(false || false);
out(false || false || false);
out(false || false || false || false);

# Logical ops. The ones expected to be "falsey" are surrounded by `&&` to
# make them easily printable.
out("Logic 1");
out(1 & 2);
out(1 & 2 & "three");
out((1 == 1) & (4 == 4));
out((1 == 1) & (2 == 2) & (5 == 5));
out((1 == 1) & (2 == 2) & (3 == 3) & (6 == 6));

out(&& (returnVoid() & "a"));
out(&& (returnVoid() & returnVoid()));
out(&& ((1 == 1) & (1 == 2)));
out(&& ((1 == 1) & (1 == 2) & (3 == 3)));
out(&& ((1 == 2) & (2 == 2) & (3 == 3)));

out("Logic 2");
out(10 | true);
out(20 | returnVoid());
out(returnVoid() | 30 | returnVoid());

out(&& (returnVoid() | returnVoid()));
out(&& (returnVoid() | returnVoid() | returnVoid()));
out(&& (returnVoid() | returnVoid() | returnVoid() | returnVoid()));

<> 0
