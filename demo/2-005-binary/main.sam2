# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Binary operator demo. Also demos hex and binary numbers, and "digit spaces".
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper definitions
#

# Prints out the given value.
fn msg(value) {
    io0Note(sourceString(value))
};

# Prints out the given value in hex.
fn outHex(value) {
    io0Note("\%x(value)")
};

# Returns void.
fn returnVoid() {
    <>
};


#
# Main tests
#

# Different bases, and digit spaces.
msg(1);
msg(1_234);
msg(0x1004);
msg(0b1111_1010);

# Operators.
msg(1 + 2);
msg(2 - 1);
msg(3 * 4);
msg(6 / 3);
msg(5 % 2);
msg(1 + 2 * 3);
msg((1 + 2) * 3);
msg(2 * 3 * 4 + 5);

outHex(0xfff0 &&& 0x0fff);
outHex(0xfff0 ||| 0x0fff);
outHex(0xfff0 ^^^ 0x0fff);
outHex(0x00ff <<< 0x8);
outHex(0xff00 >>> 0x8);

# Ordering. The ones expected to be "falsey" are surrounded by `&&` to
# make them easily printable.
msg("Order 1");
msg(1 == 1);
msg(1 != 2);
msg(1 < 3);
msg(5 > 4);
msg(1 <= 5);
msg(6 >= 6);
msg("a" \== "a");
msg("a" \!= "b");
msg("a" \< "c");

msg("Order 2");
msg(&&(1 != 1));
msg(&&(1 == 2));
msg(&&(1 >= 2));
msg(&&(2 <= 1));
msg(&&(1 > 2));
msg(&&(2 < 2));
msg(&&([1] \> [1]));
msg(&&([1] \<= [0]));
msg(&&([1] \>= [2]));

msg("Order 3");
msg(1 < 2 < 20);
msg(100 == 100 > 21);
msg(10 >= 5 < 22);
msg(2 != 3 != 23);

msg(&&(1 != 1 < 2));
msg(&&(2 > 3 == 3));
msg(&&(4 < 5 == 6));
msg(&&(9 < 10 < 11 < 12 != 12));

# Booleans.
msg("Boolean 1");
msg(true && true);
msg(true && true && true);
msg(&&(1 == 1) && &&(2 == 2));
msg(&&(1 == 1) && &&(2 == 2) && &&(3 == 3));
msg(&&(1 == 1) && &&(2 == 2) && &&(3 == 3) && &&(4 == 4));

msg(false && true);
msg(false && false);
msg(&&(1 == 1) && &&(1 == 2));
msg(&&(1 == 1) && &&(1 == 2) && &&(3 == 3));
msg(&&(1 == 2) && &&(2 == 2) && &&(3 == 3));

msg("Boolean 2");
msg(true || true);
msg(true || false);
msg(false || true || false);

msg(false || false);
msg(false || false || false);
msg(false || false || false || false);

# Logical ops. The ones expected to be "falsey" are surrounded by `&&` to
# make them easily printable.
msg("Logic 1");
msg(1 & 2);
msg(1 & 2 & "three");
msg((1 == 1) & (4 == 4));
msg((1 == 1) & (2 == 2) & (5 == 5));
msg((1 == 1) & (2 == 2) & (3 == 3) & (6 == 6));

msg(&& (returnVoid() & "a"));
msg(&& (returnVoid() & returnVoid()));
msg(&& ((1 == 1) & (1 == 2)));
msg(&& ((1 == 1) & (1 == 2) & (3 == 3)));
msg(&& ((1 == 2) & (2 == 2) & (3 == 3)));

msg("Logic 2");
msg(10 | true);
msg(20 | returnVoid());
msg(returnVoid() | 30 | returnVoid());

msg(&& (returnVoid() | returnVoid()));
msg(&& (returnVoid() | returnVoid() | returnVoid()));
msg(&& (returnVoid() | returnVoid() | returnVoid() | returnVoid()));

<> 0
