# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# List / argument interpolation demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ->

def Io0 = moduleGet({name: ["core", "Io0"]});


#
# Helper Definitions
#

fn msg(args*) {
    Io0::note(cat("Got: ", sourceString(args)))
};

fn ten() {
    <> 10
};

fn list5() {
    <> [5]
};

fn yieldTest(x) {
    <> x*
};

fn nonlocalTest(x) {
    return x*
};


#
# Main Tests
#

msg(["a", "b", "c"]*, ["d", "e", "f", ["g"]*]*);
msg({[1, 2, 3]*: 6});
msg("blort"*);
msg({a: 10, b: "20"}*);
msg(makeInclusiveRange("a", 2, "m")*);

ifValue { <> yieldTest([]) }
    { value <> msg(value) }
    { Io0::note("(void)") };

ifValue { <> nonlocalTest([]) }
    { value <> msg(value) }
    { Io0::note("(void)") };

ifValue { <> yieldTest(["blort"]) }
    { value <> msg(value) }
    { Io0::note("(void)") };

ifValue { <> nonlocalTest(["fizmo"]) }
    { value <> msg(value) }
    { Io0::note("(void)") };

# The extra parens here force the interpolated expression not to be considered
# at function argument level.
msg((list5()*));

def five = list5()*;
msg(five);

msg({blort: list5()*});

<> 0
