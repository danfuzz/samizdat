# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# List / argument interpolation demo.
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper function
#

fn out(args*) {
    io0Note(format("Got: %q", args))
};

fn ten() {
    <> 10
};

fn list5() {
    <> [5]
};

fn yieldTest(x) {
    <> x*
};

fn nonlocalTest(x) {
    return x*
};

#
# Main tests
#

out(["a", "b", "c"]*, ["d", "e", "f", ["g"]*]*);
out([[1, 2, 3]*: 6]);
out("blort"*);
out([a: 10, b: "20"]*);
out(generatorForInclusiveRange("a", 2, "m")*);

ifValue { <> yieldTest([]) }
    { value :: <> out(value) }
    { out("void") };

ifValue { <> nonlocalTest([]) }
    { value :: <> out(value) }
    { out("void") };

ifValue { <> yieldTest(["blort"]) }
    { value :: <> out(value) }
    { out("void") };

ifValue { <> nonlocalTest(["fizmo"]) }
    { value :: <> out(value) }
    { out("void") };

# The extra parens here force the interpolated expression not to be considered
# at function argument level.
out((list5()*));

# Likewise the minus sign here (because it binds looser than the
# interpolation star).
out(-list5()*);

def five = list5()*;
out(five);

out([blort: list5()*]);

<> 0
