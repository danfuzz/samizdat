# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# List / argument interpolation demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper Definitions
#

fn msg(args*) {
    io0Note(stringAdd("Got: ", sourceString(args)))
};

fn ten() {
    <> 10
};

fn list5() {
    <> [5]
};

fn yieldTest(x) {
    <> x*
};

fn nonlocalTest(x) {
    return x*
};


#
# Main Tests
#

msg(["a", "b", "c"]*, ["d", "e", "f", ["g"]*]*);
msg([[1, 2, 3]*: 6]);
msg("blort"*);
msg([a: 10, b: "20"]*);
msg(inclusiveRange("a", 2, "m")*);
msg(11*);

ifValue { <> yieldTest([]) }
    { value <> msg(value) }
    { msg("void") };

ifValue { <> nonlocalTest([]) }
    { value <> msg(value) }
    { msg("void") };

ifValue { <> yieldTest(["blort"]) }
    { value <> msg(value) }
    { msg("void") };

ifValue { <> nonlocalTest(["fizmo"]) }
    { value <> msg(value) }
    { msg("void") };

# The extra parens here force the interpolated expression not to be considered
# at function argument level.
msg((list5()*));

# Likewise the minus sign here (because it binds looser than the
# interpolation star).
msg(-list5()*);

def five = list5()*;
msg(five);

msg([blort: list5()*]);

<> 0
