# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Calculator Demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper definitions
#

# Takes an initial value and a list of one-argument functions, and
# does a reduction by applying each of the functions in order.
fn applyAll(initialValue, functions) {
    <> listReduce(initialValue, functions)
        { result, ., function :: <> function(result) }
};

# Forward declaration of `addExpression`.
def addExpression = forwardFunction();

# Parses a single digit, yielding its value as an int.
def digit = {/
    ch = ["0".."9"]
    { <> isub(intFromChar(tokenType(ch)), intFromChar("0")) }
/};

# Parses a whole number (non-negative integer), yielding its value as an int.
def number = {/
    digits = digit+
    {
        <> listReduce(0, digits)
            { result, ., digit :: <> iadd(digit, imul(result, 10)) }
    }
/};

# Parses an atomic expression. In this case it's either a number or a
# parenthesized expression. Yields the number or evaluated expression result,
# respectively.
def atom = {/
    number
|
    "("
    ex = addExpression
    ")"
    { <> ex }
/};

# Parses a unary (in this case, prefix) operation, yielding its corresponding
# function.
def unaryOp = {/
    "-" { <> ineg }
|
    "+" { <> { x :: <> x } }
/};

# Parses a unary expression, that is, a series of unary operators followed
# by an atom, yielding the evaluated result.
def unaryExpression = {/
    ops = unaryOp*
    ex = atom
    { <> applyAll(ex, listReverse(ops)) }
/};

# Parses an infix binary multiplicative operation, yielding its corresponding
# function.
def mulOp = {/
    "*" { <> imul }
|
    "/" { <> idiv }
|
    "%" { <> irem }
/};

# Parses a multiplicative expression, that is, a series of unary expressions
# separated by multiplicative operators, yielding the evaluated result.
def mulExpression = {/
    firstEx = unaryExpression
    opExes = (
        op = mulOp
        ex = unaryExpression
        { <> { n :: <> op(n, ex) } }
    )*
    { <> applyAll(firstEx, opExes) }
/};

# Parses an infix binary additive operation, yielding its corresponding
# function.
def addOp = {/
    "+" { <> iadd }
|
    "-" { <> isub }
/};

# Parses an additive expression, that is, a series of multiplicative
# expressions separated by additive operators, yielding the evaluated result.
def addExpressionImpl = {/
    firstEx = mulExpression
    opExes = (
        op = addOp
        ex = mulExpression
        { <> { n :: <> op(n, ex) } }
    )*
    { <> applyAll(firstEx, opExes) }
/};
addExpression(addExpressionImpl);

# Evaluates all the expressions passed to it, printing the evaluated results
# in order. Each expression is expected to be terminated with a newline.
def evalExpressions = {/
    (
        ex = addExpression
        "\n"
        {
            io0Note(sourceString(ex));
            # Explicit yield here to indicate successful parsing.
            <> null
        }
    )*
/};


#
# Main function
#

fn main(args*) {
    def argFilter = filterGenerator(args) { arg :: <> stringAdd(arg, "\n") };
    def exprString = stringAdd(argFilter*);
    pegApply(evalExpressions, exprString);
};

<> main(ARGS*)
