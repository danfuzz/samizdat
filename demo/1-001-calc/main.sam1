## Copyright 2013-2014 the Samizdat Authors (Dan Bornstein et alia).
## Licensed AS IS and WITHOUT WARRANTY under the Apache License,
## Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

##
## Calculator Demo
##


##
## Helper Definitions
##

## Map from binary operation names to precedece/function maps.
def BINARY_OPS = {
    "+": {function: Number::add, precedence: 1},
    "-": {function: Number::sub, precedence: 1},
    "*": {function: Number::mul, precedence: 2},
    "/": {function: Number::div, precedence: 2},
    "%": {function: Number::mod, precedence: 2}
};

## Map from unary operation names to functions.
def UNARY_OPS = {
    "+": { x <> x },
    "-": Number::neg
};

## Takes an initial value and a list of one-argument functions, and
## does a reduction by applying each of the functions in order.
fn applyAll(initialValue, functions) {
    var result = initialValue;

    Generator::filterPump(functions) { function ->
        result := function(result)
    };

    <> result
};

## Takes an initial value and a list of maps of `{op, value}`,
## and evaluates the result using the "shunting yard" algorithm.
fn applyShuntingYard(initialValue, opValues) {
    ## Reduces the top of the given pending stack. That is, it takes the
    ## top two values, and combines them by applying the top op, and places
    ## the result back at the top of the value stack.
    fn applyTop(ops, values) {
        def valuesSizeM2 = Number::sub(get_size(values), 2);
        def function = Sequence::nthFromEnd(ops, 0)::function;
        def newValue =
            function(Sequence::sliceInclusive(values, valuesSizeM2)*);
        <> {
            ops: Sequence::sliceExclusive(ops, 0),
            values:
                [Sequence::sliceExclusive(values, 0, valuesSizeM2)*, newValue]
        }
    };

    ## Reduces the given pending stack with knowledge that the next operator
    ## to apply is of the given precedence.
    fn reducePending(origOps, origValues, precedence) {
        var ops = origOps;
        var values = origValues;
        loop { <next> ->
            ifValue { <> Sequence::nthFromEnd(ops, 0) }
                { lastOp ->
                    ifIs { <> ge(lastOp::precedence, precedence) }
                        {
                            def opVal = applyTop(ops, values);
                            ops := opVal::ops;
                            values := opVal::values;
                            <next>
                        }
                };
            return {ops, values}
        }
    };

    var ops = [];
    var values = [initialValue];

    Generator::filterPump(opValues) { opValue ->
        def op = opValue::op;
        def value = opValue::value;
        def opVal = reducePending(ops, values, op::precedence);

        ops := [opVal::ops*, op];
        values := [opVal::values*, value]
    };

    ## Use precedence `-1` to drain the op stack, leaving a single
    ## value.
    def finalResult = reducePending(ops, values, -1);
    return finalResult::values*
};

## Forward declaration of `expression`.
def expression;

## Parses a single digit, yielding its value as an int.
def digit = {:
    ch = ["0".."9"]
    { <> Number::sub(toInt(get_typeName(ch)), toInt("0")) }
:};

## Parses a whole number (non-negative integer), yielding its value as an int.
def number = {:
    digits = digit+
    {
        var result = 0;
        Generator::filterPump(digits) { digit ->
            result := Number::add(digit, Number::mul(result, 10))
        };
        <> result
    }
:};

## Parses an expression term. In this case it's either a number or a
## parenthesized expression. Yields the number or evaluated expression result,
## respectively.
def term = {:
    number
|
    "("
    ex = %expression
    ")"
    { <> ex }
:};

## Parses a unary (in this case, prefix) operation, yielding its corresponding
## function.
def unaryOp = {:
    op = ["+-"]
    { <> get(UNARY_OPS, get_typeName(op)) }
:};

## Parses a unary expression, that is, a series of unary operators followed
## by a term, yielding the evaluated result.
def unaryExpression = {:
    ops = unaryOp*
    ex = term
    { <> applyAll(ex, Sequence::reverse(ops)) }
:};

## Parses a binary operation, yielding a map of precedence and function.
def binaryOp = {:
    op = ["+-*/%"]
    { <> get(BINARY_OPS, get_typeName(op)) }
:};

## Parses a chained sequence of unary expressions separated by binary
## operators.
expression := {:
    firstValue = unaryExpression
    opValues = (
        op = binaryOp
        value = unaryExpression
        { <> {op, value} }
    )*
    { <> applyShuntingYard(firstValue, opValues) }
:};

## Evaluates all the expressions passed to it, printing the evaluated results
## in order. Each expression is expected to be terminated with a newline.
def evalExpressions = {:
    (
        ex = expression
        "\n"
        {
            note(Format::source(ex));
            ## Explicit yield here to indicate successful parsing.
            <> null
        }
    )*
:};


##
## Main Definition
##

fn main(args*) {
    def argFilter = Generator::makeFilterGenerator(args)
        { arg <> cat(arg, "\n") };
    def exprString = cat(argFilter*);
    Peg::apply(evalExpressions, exprString);
};

def args = ifValueOr { <> ne(ARGUMENTS, []) } { <> ["100+7*2-(8000/-10)"] };

<> main(args*)
