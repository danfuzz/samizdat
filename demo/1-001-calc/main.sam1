# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Calculator Demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ->


#
# Helper Definitions
#

# Map from binary operation names to precedece/function maps.
def BINARY_OPS = {
    "+": {function: add, precedence: 1},
    "-": {function: sub, precedence: 1},
    "*": {function: mul, precedence: 2},
    "/": {function: div, precedence: 2},
    "%": {function: mod, precedence: 2}
};

# Map from unary operation names to functions.
def UNARY_OPS = {
    "+": { x <> x },
    "-": neg
};

# Takes an initial value and a list of one-argument functions, and
# does a reduction by applying each of the functions in order.
fn applyAll(initialValue, functions) {
    <> doReduce1(functions, initialValue)
        { function, result <> function(result) }
};

# Takes an initial value and a list of maps of `[op, value]`,
# and evaluates the result using the "shunting yard" algorithm.
fn applyShuntingYard(initialValue, opValues) {
    # Reduces the top of the given pending stack. That is, it takes the
    # top two values, and combines them by applying the top op, and places
    # the result back at the top of the value stack.
    fn applyTop(ops, values) {
        def valuesSizeM2 = sub(sizeOf(values), 2);
        def function = last(ops)::function;
        def newValue = function(slice(values, valuesSizeM2)*);
        <> [
            butLast(ops),
            [slice(values, 0, valuesSizeM2)*, newValue]
        ]
    };

    # Reduces the given pending stack with knowledge that the next operator
    # to apply is of the given precedence.
    fn reducePending(ops, values, precedence) {
        loopReduce(ops, values)
            { <next> ops, values ->
                ifValue { <> last(ops) }
                    { lastOp ->
                        ifIs { <> ge(lastOp::precedence, precedence) }
                            { <next> applyTop(ops, values) }
                    };
                return [ops, values]
            }
    };

    loopReduce([], [initialValue], opValues) { ops, values, opValues ->
        ifIs { <> eq(opValues, []) }
            {
                # Use precedence `-1` to drain the op stack, leaving a single
                # value.
                def finalResult = reducePending(ops, values, -1);
                return last(last(finalResult))
            };

        def nextOpValue = first(opValues);
        def nextOp = nextOpValue::op;
        def nextVal = nextOpValue::value;
        def newPending = reducePending(ops, values, nextOp::precedence);
        <> [
            [first(newPending)*, nextOp],
            [last(newPending)*, nextVal],
            butFirst(opValues)
        ]
    }
};

# Forward declaration of `expression`.
def expression = makeParseForwarder();

# Parses a single digit, yielding its value as an int.
def digit = {/
    ch = ["0".."9"]
    { <> sub(toInt(typeOf(ch)), toInt("0")) }
/};

# Parses a whole number (non-negative integer), yielding its value as an int.
def number = {/
    digits = digit+
    {
        <> doReduce1(digits, 0)
            { digit, result <> add(digit, mul(result, 10)) }
    }
/};

# Parses an expression term. In this case it's either a number or a
# parenthesized expression. Yields the number or evaluated expression result,
# respectively.
def term = {/
    number
|
    "("
    ex = expression
    ")"
    { <> ex }
/};

# Parses a unary (in this case, prefix) operation, yielding its corresponding
# function.
def unaryOp = {/
    op = ["+-"]
    { <> get(UNARY_OPS, typeOf(op)) }
/};

# Parses a unary expression, that is, a series of unary operators followed
# by a term, yielding the evaluated result.
def unaryExpression = {/
    ops = unaryOp*
    ex = term
    { <> applyAll(ex, reverse(ops)) }
/};

# Parses a binary operation, yielding a map of precedence and function.
def binaryOp = {/
    op = ["+-*/%"]
    { <> get(BINARY_OPS, typeOf(op)) }
/};

# Parses a chained sequence of unary expressions separated by binary
# operators.
def expressionImpl = {/
    firstValue = unaryExpression
    opValues = (
        op = binaryOp
        value = unaryExpression
        { <> {op: op, value: value} }
    )*
    { <> applyShuntingYard(firstValue, opValues) }
/};
store(expression, expressionImpl);

# Evaluates all the expressions passed to it, printing the evaluated results
# in order. Each expression is expected to be terminated with a newline.
def evalExpressions = {/
    (
        ex = expression
        "\n"
        {
            io0Note(sourceString(ex));
            # Explicit yield here to indicate successful parsing.
            <> null
        }
    )*
/};


#
# Main Definition
#

fn main(args*) {
    def argFilter = makeFilterGenerator(args) { arg <> cat(arg, "\n") };
    def exprString = cat(argFilter*);
    Peg::apply(evalExpressions, exprString);
};

def args = ifIs { <> ne(ARGS, []) } { <> ARGS} { <> ["100+7*2"] };
<> main(args*)
