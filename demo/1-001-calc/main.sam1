# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Calculator Demo
#


# This declares the arguments to the program itself.
SELF_PATH, ARGS* ::


#
# Helper Definitions
#

# Map from binary operation names to precedece/function maps.
def BINARY_OPS = [
    "+": [function: add, precedence: 1],
    "-": [function: isub, precedence: 1],
    "*": [function: imul, precedence: 2],
    "/": [function: div, precedence: 2],
    "%": [function: mod, precedence: 2]
];

# Map from unary operation names to functions.
def UNARY_OPS = [
    "+": { x <> x },
    "-": neg
];

# Takes an initial value and a list of one-argument functions, and
# does a reduction by applying each of the functions in order.
fn applyAll(initialValue, functions) {
    <> doReduce1(functions, initialValue)
        { function, result <> function(result) }
};

# Takes an initial value and a list of maps of `[op, value]`,
# and evaluates the result using the "shunting yard" algorithm.
fn applyShuntingYard(initialValue, opValues) {
    # Reduces the top of the given pending stack. That is, it takes the
    # top two values, and combines them by applying the top op, and places
    # the result back at the top of the value stack.
    fn applyTop(ops, values) {
        def valuesSizeM2 = isub(coreSizeOf(values), 2);
        def function = mapGet(listLast(ops), "function");
        def newValue = function(listSlice(values, valuesSizeM2)*);
        <> [
            listButLast(ops),
            [listSlice(values, 0, valuesSizeM2)*, newValue]
        ]
    };

    # Reduces the given pending stack with knowledge that the next operator
    # to apply is of the given precedence.
    fn reducePending(ops, values, precedence) {
        loopReduce(ops, values)
            { <next> ops, values ::
                ifValue { <> listLast(ops) }
                    { lastOp ::
                        ifIs { <> ge(mapGet(lastOp, "precedence"), precedence) }
                            { <next> applyTop(ops, values) }
                    };
                return [ops, values]
            }
    };

    loopReduce([], [initialValue], opValues) { ops, values, opValues ::
        ifIs { <> eq(opValues, []) }
            {
                # Use precedence `-1` to drain the op stack, leaving a single
                # value.
                def finalResult = reducePending(ops, values, -1);
                return listLast(listLast(finalResult))
            };

        def nextOpValue = listFirst(opValues);
        def nextOp = mapGet(nextOpValue, "op");
        def nextValue = mapGet(nextOpValue, "value");
        def newPending =
            reducePending(ops, values, mapGet(nextOp, "precedence"));
        <> [
            [listFirst(newPending)*, nextOp],
            [listLast(newPending)*, nextValue],
            listButFirst(opValues)
        ]
    }
};

# Forward declaration of `expression`.
def expression = forwardFunction();

# Parses a single digit, yielding its value as an int.
def digit = {/
    ch = ["0".."9"]
    { <> isub(intFromChar(typeOf(ch)), intFromChar("0")) }
/};

# Parses a whole number (non-negative integer), yielding its value as an int.
def number = {/
    digits = digit+
    {
        <> doReduce1(digits, 0)
            { digit, result <> add(digit, imul(result, 10)) }
    }
/};

# Parses an atomic expression. In this case it's either a number or a
# parenthesized expression. Yields the number or evaluated expression result,
# respectively.
def atom = {/
    number
|
    "("
    ex = expression
    ")"
    { <> ex }
/};

# Parses a unary (in this case, prefix) operation, yielding its corresponding
# function.
def unaryOp = {/
    op = ["+-"]
    { <> mapGet(UNARY_OPS, typeOf(op)) }
/};

# Parses a unary expression, that is, a series of unary operators followed
# by an atom, yielding the evaluated result.
def unaryExpression = {/
    ops = unaryOp*
    ex = atom
    { <> applyAll(ex, listReverse(ops)) }
/};

# Parses a binary operation, yielding a map of precedence and function.
def binaryOp = {/
    op = ["+-*/%"]
    { <> mapGet(BINARY_OPS, typeOf(op)) }
/};

# Parses a chained sequence of unary expressions separated by binary
# operators.
def expressionImpl = {/
    firstValue = unaryExpression
    opValues = (
        op = binaryOp
        value = unaryExpression
        { <> [op: op, value: value] }
    )*
    { <> applyShuntingYard(firstValue, opValues) }
/};
expression(expressionImpl);

# Evaluates all the expressions passed to it, printing the evaluated results
# in order. Each expression is expected to be terminated with a newline.
def evalExpressions = {/
    (
        ex = expression
        "\n"
        {
            io0Note(sourceString(ex));
            # Explicit yield here to indicate successful parsing.
            <> null
        }
    )*
/};


#
# Main Definition
#

fn main(args*) {
    def argFilter = filterGenerator(args) { arg <> stringCat(arg, "\n") };
    def exprString = stringCat(argFilter*);
    pegApply(evalExpressions, exprString);
};

def args = ifIs { <> ne(ARGS, []) } { <> ARGS} { <> ["100+7*2"] };
<> main(args*)
