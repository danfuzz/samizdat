# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tree parser
#


#
# Helper functions
#

# Object service function used by `makeForwardDeclaration`.
forwardService = { yield state value? ::
    <> ifTrue { <> eq value [] }
        { yield state }
        {
            yield();
            <> listNth value 0
        }
};

# Simple value storage box, to effectively implement forward declaration
# of parser rules. Call the result with a value to set it, or with no
# argument to get the previously-set value.
makeForwardDeclaration = {
    <> object forwardService null;
};

# Returns a `call` node.
makeCall = { function actuals* ::
    <> @["call" ["function"=function "actuals"=actuals]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @["varRef" name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name actuals* ::
    <> @["call" ["function"=(makeVarRef name) "actuals"=actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @["literal" value]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* and *Samizdat Layer 1* specifications.
#

#
# Samizdat Layer 0 definitions
#

# Forward declarations for atom, expression, function, and parser.

fwdAtom = makeForwardDeclaration();
fwdExpression = makeForwardDeclaration();
fwdFunction = makeForwardDeclaration();
fwdParser = makeForwardDeclaration();

parseAtom = { args* :: <> apply (fwdAtom()) args };
parseExpression = { args* :: <> apply (fwdExpression()) args };
parseFunction = { args* :: <> apply (fwdFunction()) args };
parseParser = { args* :: <> apply (fwdParser()) args };

# Documented in Samizdat Layer 0 spec.
parseInt = pegMakeMainSequence
    (pegMakeToken "int")
    (pegMakeCode { int :: <> makeLiteral (tokenValue int) });

# Documented in Samizdat Layer 0 spec.
parseString = pegMakeMainSequence
    (pegMakeToken "string")
    (pegMakeCode { string :: <> makeLiteral (tokenValue string) });

# Documented in Samizdat Layer 0 spec.
parseEmptyList = pegMakeMainSequence
    (pegMakeToken "[")
    (pegMakeToken "]")
    (pegMakeCode { . . :: <> makeLiteral [] });

# Documented in Samizdat Layer 0 spec.
parseList = pegMakeMainSequence
    (pegMakeToken "[")
    (pegMakeStar parseAtom)
    (pegMakeToken "]")
    (pegMakeCode { . atoms . :: <> apply makeCallName "makeList" atoms });

# Documented in Samizdat Layer 0 spec.
parseEmptyMap = pegMakeMainSequence
    (pegMakeToken "[")
    (pegMakeToken "=")
    (pegMakeToken "]")
    (pegMakeCode { . . . :: <> makeLiteral [=] });

# Documented in Samizdat Layer 0 spec.
parseBinding = pegMakeMainSequence
    parseAtom
    (pegMakeToken "=")
    parseAtom
    (pegMakeCode { key . value :: <> [key value] });

# Documented in Samizdat Layer 0 spec.
parseMap = pegMakeMainSequence
    (pegMakeToken "[")
    (pegMakePlus parseBinding)
    (pegMakeToken "]")
    (pegMakeCode { . bindings . ::
        <> apply makeCallName "makeMap" (apply listAdd bindings)
    });

# Documented in Samizdat Layer 0 spec.
parseToken = pegMakeMainSequence
    (pegMakeToken "@")
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeToken "[")
            parseAtom
            (pegMakeOpt parseAtom)
            (pegMakeToken "]")
            (pegMakeCode { . type value . ::
                <> apply makeCallName "makeToken" type value
            }))
        (pegMakeMainSequence
            (pegMakeTokenSet "string" "identifier")
            (pegMakeCode { type ::
                <> makeCallName "makeToken" (makeLiteral (tokenValue type))
            })));

# Documented in Samizdat Layer 0 spec.
parseUniqlet = pegMakeMainSequence
    (pegMakeToken "@@")
    (pegMakeCode { . :: <> makeCallName "makeUniqlet" });

# Documented in Samizdat Layer 0 spec.
parseVarRef = pegMakeMainSequence
    (pegMakeToken "identifier")
    (pegMakeCode { name :: <> makeVarRef (tokenValue name) });

# Documented in Samizdat Layer 0 spec.
parseVarDef = pegMakeMainSequence
    (pegMakeToken "identifier")
    (pegMakeToken "=")
    parseExpression
    (pegMakeCode { name . ex ::
        <> @["varDef" ["name"=(tokenValue name) "value"=ex]]
    });

# Documented in Samizdat Layer 0 spec.
parseParenExpression = pegMakeMainSequence
    (pegMakeToken "(")
    parseExpression
    (pegMakeToken ")")
    (pegMakeCode { . ex . :: <> ex });

# Documented in Samizdat Layer 0 spec and Samizdat Layer 1 spec.
implAtom = pegMakeMainSequence
    (pegMakeChoice
        parseVarRef parseInt parseString
        parseEmptyList parseList parseEmptyMap parseMap
        parseUniqlet parseToken parseFunction
        parseParenExpression
        # Defined by Samizdat Layer 1. The lookahead is just to make
        # it clear what is required to "jump into" Layer 1 parsing.
        (pegMakeSequence
            (pegMakeLookaheadSuccess (pegMakeToken "{/"))
            parseParser));
fwdAtom implAtom;

# Documented in Samizdat Layer 0 spec.
parseCallExpression = pegMakeMainSequence
    parseAtom
    (pegMakePlus parseAtom)
    (pegMakeCode { function args :: <> apply makeCall function args });

# Documented in Samizdat Layer 0 spec.
parseUnaryCallExpression = pegMakeMainSequence
    parseAtom
    (pegMakePlus (pegMakeToken "()"))
    (pegMakeCode { function calls ::
        <> listReduce function calls
            { result :: <> makeCall result }
    });

# Documented in Samizdat Layer 0 spec.
parseUnaryExpression = pegMakeMainSequence
    (pegMakeChoice parseUnaryCallExpression parseAtom);

# Documented in Samizdat Layer 0 spec.
implExpression = pegMakeMainSequence
    (pegMakeChoice parseCallExpression parseUnaryExpression);
fwdExpression implExpression;

# Documented in Samizdat Layer 0 spec.
parseStatement = pegMakeMainSequence
    (pegMakeChoice parseVarDef parseExpression);

# Documented in Samizdat Layer 0 spec.
parseNonlocalExit = pegMakeMainSequence
    (pegMakeToken "<")
    parseVarRef
    (pegMakeToken ">")
    (pegMakeOpt parseExpression)
    (pegMakeCode { . name . ex :: <> apply makeCall name ex });

# Documented in Samizdat Layer 0 spec.
parseYield = pegMakeMainSequence
    (pegMakeToken "<>")
    (pegMakeChoice
        (pegMakeMainSequence
            parseExpression
            (pegMakeCode { ex :: <> ["yield" = ex] }))
        (pegMakeMainSequence
            (pegMakeCode { :: <> [=] })));

# Documented in Samizdat Layer 0 spec.
parseYieldDef = pegMakeMainSequence
    (pegMakeToken "<")
    (pegMakeToken "identifier")
    (pegMakeToken ">")
    (pegMakeCode { . name . :: <> tokenValue name });

# Documented in Samizdat Layer 0 spec.
parseFormal = pegMakeMainSequence
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeToken "identifier")
            (pegMakeCode { n :: <> ["name" = (tokenValue n)] }))
        (pegMakeMainSequence
            (pegMakeToken ".")
            (pegMakeCode { . :: <> [=] })))
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeTokenSet "?" "*" "+")
            (pegMakeCode { r :: <> ["repeat" = (tokenType r)] }))
        (pegMakeMainSequence
            (pegMakeCode { <> [=] })))
    (pegMakeCode { name repeat :: <> mapAdd name repeat });

# Documented in Samizdat Layer 0 spec.
parseProgramBody = pegMakeMainSequence
    (pegMakeStar (pegMakeToken ";"))
    (pegMakeStar
        (pegMakeMainSequence
            parseStatement
            (pegMakePlus (pegMakeToken ";"))
            (pegMakeCode { s . :: <> s })))
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeChoice parseStatement parseNonlocalExit)
            (pegMakeCode { s :: <> ["statements" = [s]] }))
        (pegMakeMainSequence
            parseYield
            (pegMakeCode { y :: <> mapAdd ["statements" = []] y }))
        (pegMakeMainSequence
            (pegMakeCode { :: <> ["statements" = []] })))
    (pegMakeStar (pegMakeToken ";"))
    (pegMakeCode { . most last . ::
        allStatements = listAdd most (mapGet last "statements");
        <> mapPut last "statements" allStatements
    });

# Documented in Samizdat Layer 0 spec.
parseProgramDeclarations = pegMakeMainSequence
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakePlus parseFormal)
            (pegMakeCode { fs :: <> ["formals" = fs] }))
        (pegMakeMainSequence
            (pegMakeCode { <> [=] })))
    (pegMakeChoice
        (pegMakeMainSequence
            parseYieldDef
            (pegMakeCode { y :: <> ["yieldDef" = y] }))
        (pegMakeMainSequence
            (pegMakeCode { <> [=] })))
    (pegMakeToken "::")
    (pegMakeCode { formals yieldDef . :: <> mapAdd formals yieldDef });

# Documented in Samizdat Layer 0 spec.
parseProgram = pegMakeMainSequence
    (pegMakeChoice
        parseProgramDeclarations
        (pegMakeCode { <> [=] }))
    parseProgramBody
    (pegMakeCode { decls body :: <> @["function" (mapAdd decls body)] });

# Documented in Samizdat Layer 0 spec.
implFunction = pegMakeMainSequence
    (pegMakeToken "{")
    parseProgram
    (pegMakeToken "}")
    (pegMakeCode { . prog . :: <> prog });
fwdFunction implFunction;


#
# Samizdat Layer 1 definitions
#

# `choicePex` is the top-level parsing expression node type.
fwdChoicePex = makeForwardDeclaration();
parseChoicePex = { args* :: <> apply (fwdChoicePex()) args };

implParser = pegMakeMainSequence
    (pegMakeToken "{/")
    parseChoicePex
    (pegMakeToken "/}")
    (pegMakeCode { . pex . :: <> @["parser" pex] });
fwdParser implParser;

parseParenPex = pegMakeMainSequence
    (pegMakeToken "(")
    parseChoicePex
    (pegMakeToken ")")
    (pegMakeCode { . pex . :: <> pex });

parseParserString = pegMakeMainSequence
    (pegMakeToken "string")
    (pegMakeCode { s ::
        value = tokenValue s;
        <> ifTrue { <> eq (lowSize value) 1 }
            { <> @["token" value] }
            { <> s }
    });

parseParserToken = pegMakeMainSequence
    (pegMakeToken "@")
    (pegMakeTokenSet "identifier" "string")
    (pegMakeCode { . type :: <> (tokenValue type) });

parseParserSet = pegMakeMainSequence
    (pegMakeToken "[")
    (pegMakeChoice
        (pegMakeSequence
            (pegMakeToken "!")
            (pegMakeCode { <> "[!]" }))
        (pegMakeCode { <> "[]" }))
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeStar (pegMakeToken "string"))
            (pegMakeCode { strings ::
                oneString = listReduce "" strings
                    { result . s :: <> stringAdd result (tokenValue s) };
                <> stringReduce [] oneString
                    { result . ch :: <> listAppend result ch }
            }))
        (pegMakeMainSequence
            (pegMakeStar parseParserToken)
            (pegMakeCode { tokens ::
                <> listReduce [] tokens
                    { result . t :: <> listAppend result (tokenValue t) }
            })))
    (pegMakeToken "]")
    (pegMakeCode { . type terminals . ::
        io0Die "TODO"
    });

parseParserCode = pegMakeMainSequence
    (pegMakeCode { io0Die "TODO" });

parseParserAtom = pegMakeMainSequence
    (pegMakeChoice
        parseVarRef
        parseParserString
        parseParserToken
        parseParserSet
        parseParserCode
        (pegMakeToken ".")
        (pegMakeToken "()")
        parseParenPex);

parseRepeatPex = pegMakeMainSequence
    parseParserAtom
    (pegMakeChoice
        (pegMakeSequence
            (pegMakeTokenSet "?" "*" "+")
            (pegMakeCode { atom repeat :: <> @[repeat atom] }))
        (pegMakeCode { atom :: <> atom }));

parseLookaheadPex = pegMakeMainSequence
    (pegMakeChoice
        (pegMakeSequence
            (pegMakeTokenSet "&" "!")
            parseRepeatPex
            (pegMakeCode { lookahead pex :: <> @[lookahead pex] }))
        parseRepeatPex);

parseNamePex = pegMakeMainSequence
    (pegMakeChoice
        (pegMakeSequence
            (pegMakeToken "identifier")
            (pegMakeToken "=")
            parseLookaheadPex
            (pegMakeCode { name . pex ::
                <> @["varDef" ["name"=(tokenValue name) "value"=pex]]
            }))
        parseLookaheadPex);

parseSequencePex = pegMakeMainSequence
    (pegMakePlus parseNamePex)
    (pegMakeCode { items :: <> @["sequence" items] });

implChoicePex = pegMakeMainSequence
    parseSequencePex
    (pegMakeStar
        (pegMakeMainSequence
            (pegMakeToken "|")
            parseSequencePex))
    (pegMakeCode { first rest :: <> listPrepend first rest });
fwdChoicePex implChoicePex;


#
# Exported function, and support thereof
#

# Reports the given list of pending tokens as part of error processing.
reportError = { pending ::
    io0Note "Pending tokens:";

    listForEach pending
        { . token :: io0Note (format "    %q" token) };

    io0Die "\nExtra tokens at end of program."
};

# Documented in Samizdat Layer 0 spec.
parseProgramOrError = pegMakeMainSequence
    parseProgram
    (pegMakeOpt
        (pegMakeMainSequence
            (pegMakePlus pegRuleAny)
            (pegMakeCode { pending :: reportError pending })))
    (pegMakeCode { prog :: <> prog });

# Performs tree parsing of the given token list.
treeFromTokens = { programTokens ::
    <> pegApply parseProgramOrError programTokens
};

<> [
    "treeFromTokens" = treeFromTokens
]
