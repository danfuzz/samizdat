# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# PEG-style parsing engine
#
# Note: All of the meta-rule functions accept as rules either parsing
# functions per se or simple highlets to represent token-matching rules.
#


#
# Helper functions
#

# Returns a rule which succeeds if the given token type is successfully
# read.
tokenRule = { token ::
    type = highletType token;

    <> { engine ::
        <> ifValue { <> engine @peek }
            { got ::
                <> ifTrue { <> eq type (highletType got) }
                    {
                        engine @read;
                        <> got
                    }
            }
    }
};

# Returns a rule which succeeds if the given named parser rule
# is successfully matched.
namedRule = { rule ::
    <> { engine ::
        <> ifValue { <> engine @rule rule }
            { function :: <> function engine }
            { io0Die (format @"Missing rule: %Q" rule) }
        }
};

# Transforms named and token rules into functions.
functionFromRule = { rule ::
    <> ifTrue { <> isHighlet rule }
        { <> tokenRule rule }
        {
            <> ifTrue { <> isString rule }
                { <> namedRule rule}
                { <> rule }
        }
};


#
# Exported functions
#

# Returns a rule which succeeds if a given other rule succeeds, and
# if so runs the given result filter function, passing it the rule
# result, to produce the final result of processing.
filterRule = { rule filterFunction ::
    finalRule = functionFromRule rule;

    <> { engine ::
        <> ifValue { <> finalRule engine } filterFunction
    }
};

# Returns a rule which succeeds if each of a list of other rules
# succeeds in sequence (said list given in the form of separate arguments
# to this function). The result, if successful, is a list of all
# the rule results. This effectively implements the sequence "operator"
# (null infix operator) in PEG.
seqRule = { rules* ::
    finalRules = listMap rules functionFromRule;

    <> { engine <out> ::
        mark = engine @at;
        <> listReduce [] finalRules
            { results rule ::
                <> ifValue { <> rule engine }
                    { result :: <> listAppend results result }
                    {
                        engine @reset mark;
                        <out>
                    }
            }
    }
};

# Returns a rule which succeeds if any of a list of other rules
# succeeds (said list given in the form of separate arguments to this
# function), trying them in order. The result is the same as the
# result of whichever rule succeeded, or void if all the alternatives
# failed. This effectively implements the ordered choice operator
# (`|` infix) in PEG.
orRule = { rules* ::
    finalRules = listMap rules functionFromRule;

    <> { engine <out> ::
        listForEach finalRules
            { rule ::
                ifValue { <> rule engine }
                    { result :: <out> result }
            }
    }
};

# Returns a rule which optionally parses a given other rule. The
# rule when run always succeeds, yielding a list. The list will
# have either zero or one element, depending on whether the inner
# rule was matched. This effectively implements the zero-or-one
# operator (`?` suffix) in PEG.
optRule = { rule ::
    finalRule = functionFromRule rule;

    <> { engine ::
        <> ifValue { <> finalRule engine }
            { result :: <> [result] }
            { <> [] }
    }
};

# Returns a rule which parses zero or more repetitions of a given other
# rule. The rule when run always succeeds, yielding a list of all
# the results of matching. It will be a zero-length list if in fact
# the inner rule never matched. This effectively implements the
# zero-or-more operator (`*` suffix) in PEG.
starRule = { rule ::
    finalRule = functionFromRule rule;

    <> { engine <out> ::
        loopReduce [] { result ::
            <> ifValue { <> finalRule engine }
                { match :: <> listAppend result match }
                { <out> result }
        }
    }
};

# Returns a rule which parses one or more repetitions of a given other
# rule. The rule when successful yields a list of all the results of
# matching and will be of size one or more. This effectively implements
# the one-or-more operator (`+` suffix) in PEG.
plusRule = { rule ::
    <> filterRule
        (seqRule rule (starRule rule))
        { result :: <> apply listPrepend result }
};

# Returns a tokenizer rule which matches the given sequence of characters
# exactly, returning that string.
charsRule = { chars ::
    <> { engine <out> ::
        mark = engine @at;
        stringForEach chars
            { ch ::
                ifTrue { <> or { <> engine @eof } { <> ne (engine @read) ch } }
                    {
                        engine @reset mark;
                        <out>
                    }
            };
        <> chars;
    }
};

# Returns a tokenizer rule which matches any of the given characters
# (given as a string of all the characters to match), returning
# a single-character string of the matched character.
charSetRule = { chars ::
    charSet = stringReduce [=] chars
        { result ch :: <> mapPut result ch null };

    <> { engine <out> ::
        ifValue { <> engine @peek }
            { ch ::
                ifTrue { <> mapHasKey charSet ch }
                    {
                        engine @read;
                        <out> ch
                    }
            }
    }
};

# Returns a tokenizer rule which matches any character *but* one of the
# given characters (given as a string of all the characters to exclude),
# returning a single-character string of the matched character.
notCharSetRule = { chars ::
    charSet = stringReduce [=] chars
        { result ch :: <> mapPut result ch null };

    <> { engine <out> ::
        ifValue { <> engine @peek }
            { ch ::
                ifFalse { <> mapHasKey charSet ch }
                    {
                        engine @read;
                        <out> ch
                    }
            }
    }
};

# Makes a reader that's augmented with a method to perform rule lookup.
pegEngine = { reader rules ::
    <> { name rest* ::
        <> ifTrue { <> eq name @rule }
            { <> mapGet rules (listNth rest @0) }
            { <> apply reader name rest }
    }
};

<> [
    @charSetRule = charSetRule
    @charsRule = charsRule
    @filterRule = filterRule
    @notCharSetRule = notCharSetRule
    @orRule = orRule
    @pegEngine = pegEngine
    @plusRule = plusRule
    @optRule = optRule
    @seqRule = seqRule
    @starRule = starRule
]
