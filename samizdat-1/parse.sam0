# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tree parser
#

#
# Helper functions
#
# Note: All of the meta-rule functions accept as rules either parsing
# functions per se or simple highlets to represent token-matching rules.
#

# Makes a reader that's augmented with a method to perform rule lookup.
engine = { reader rules ::
    <> { name rest* ::
        <> ifTrue { <> eq name @rule }
            { <> mapletGet rules (listletNth rest @0) }
            { <> apply reader name rest }
    }
};

# Returns a rule which succeeds if the given token type is successfully
# read.
tokenRule = { token ::
    type = highletType token;

    <> { engine ::
        <> ifValue { <> engine @peek }
            { got ::
                <> ifTrue { <> eq type (highletType got) }
                    {
                        engine @read;
                        <> got
                    }
            }
    }
};

# Returns a rule which succeeds if the given parser rule is successfully
# matched.
parserRule = { rule ::
    <> { engine :: <> (engine @rule rule) engine }
};

# Meta-helper function, which transforms named rules (highlets for
# token matching and stringlets for parser matching) into functions.
functionFromRule = { rule ::
    <> ifTrue { <> isHighlet rule }
        { <> tokenRule rule }
        {
            <> ifTrue { <> isStringlet rule }
                { <> parserRule rule}
                { <> rule }
        }
};

# Returns a rule which succeeds if a given other rule succeeds, and
# if so runs the given result filter function, passing it the rule
# result, to produce the final result of processing.
filterRule = { rule filterFunction ::
    finalRule = functionFromRule rule;

    <> { engine ::
        <> ifValue { <> finalRule engine } filterFunction
    }
};

# Returns a rule which succeeds if each of a list of other rules
# succeeds in sequence (said list given in the form of separate arguments
# to this function). The result, if successful, is a listlet of all
# the rule results. This effectively implements the sequence "operator"
# (null infix operator) in PEG.
seqRule = { rules* ::
    finalRules = listletMap rules functionFromRule;

    <> { engine <out> ::
        mark = engine @at;
        <> listletReduce @[] finalRules
            { results rule ::
                <> ifValue { <> rule engine }
                    { result :: <> listletAppend results result }
                    {
                        engine @reset mark;
                        <out>
                    }
            }
    }
};

# Returns a rule which succeeds if any of a list of other rules
# succeeds (said list given in the form of separate arguments to this
# function), trying them in order. The result is the same as the
# result of whichever rule succeeded, or void if all the alternatives
# failed. This effectively implements the ordered choice operator
# (`|` infix) in PEG.
orRule = { rules* ::
    finalRules = listletMap rules functionFromRule;

    <> { engine <out> ::
        listletForEach finalRules
            { rule ::
                ifValue { <> rule engine }
                    { result :: <out> result }
            }
    }
};

# Returns a rule which optionally parses a given other rule. The
# rule when run always succeeds, yielding a listlet. The listlet will
# have either zero or one element, depending on whether the inner
# rule was matched. This effectively implements the zero-or-one
# operator (`?` suffix) in PEG.
questRule = { rule ::
    finalRule = functionFromRule rule;

    <> { engine ::
        <> ifValue { <> finalRule engine }
            { result :: <> @[result] }
            { <> @[] }
    }
};

# Returns a rule which parses zero or more repetitions of a given other
# rule. The rule when run always succeeds, yielding a listlet of all
# the results of matching. It will be a zero-length listlet if in fact
# the inner rule never matched. This effectively implements the
# zero-or-more operator (`*` suffix) in PEG.
starRule = { rule ::
    finalRule = functionFromRule rule;

    <> { engine <out> ::
        loopReduce @[] { result ::
            <> ifValue { <> finalRule engine }
                { match :: <> listletAppend result match }
                { <out> result }
        }
    }
};

# Returns a rule which parses one or more repetitions of a given other
# rule. The rule when successful yields a listlet of all the results of
# matching and will be of size one or more. This effectively implements
# the one-or-more operator (`+` suffix) in PEG.
plusRule = { rule ::
    <> filterRule
        (seqRule rule (starRule rule))
        { result :: <> apply listletPrepend result }
};

# Returns a `call` node.
makeCall = { function actuals* ::
    <> [:@call @[@function=function @actuals=actuals]:]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* specification.
#

# Parses a `call` node.
parseCall = filterRule
    (seqRule
        @atom
        (orRule
            (plusRule @atom)
            (filterRule
                (seqRule [:@"(":] [:@")":])
                { <> @[] })))
    { result ::
        <> apply makeCall (listletNth result @0) (listletNth result @1)
    };

# Parses a `highlet` node.
parseHighlet = filterRule
    (seqRule
        [:@"[":]
        [:@":":]
        @atom
        (questRule @atom)
        [:@":":]
        [:@"]":])
    { result ::
        <> apply makeCall [:@varRef @makeHighlet:]
            (listletNth result @2)
            (listletNth result @3)
    };

# Parses a `uniqlet` node.
parseUniqlet = filterRule
    [:@"@@":]
    { <> makeCall [:@varRef @makeUniqlet:] };

# Parses a `binding` node.
parseBinding = filterRule
    (seqRule @atom [:@"=":] @atom)
    { result ::
        <> @[(listletNth result @0) (listletNth result @2)]
    };

# Parses a `maplet` node.
parseMaplet = filterRule
    (seqRule [:@"@":] [:@"[":] (plusRule @binding) [:@"]":])
    { result ::
        bindings = apply listletCat (listletNth result @2);
        <> apply makeCall [:@varRef @makeMaplet:] bindings
    };

# Parses a `emptyMaplet` node.
parseEmptyMaplet = filterRule
    (seqRule [:@"@":] [:@"[":] [:@"=":] [:@"]":])
    { <> [:@literal @[=]:] };

# Parses a `listlet` node.
parseListlet = filterRule
    (seqRule [:@"@":] [:@"[":] (plusRule @atom) [:@"]":])
    { result ::
        <> apply makeCall [:@varRef @makeListlet:] (listletNth result @2)
    };

# Parses a `emptyListlet` node.
parseEmptyListlet = filterRule
    (seqRule [:@"@":] [:@"[":] [:@"]":])
    { <> [:@literal @[]:] };

# Parses a `stringlet` node.
parseStringlet = filterRule
    (seqRule
        [:@"@":]
        (orRule [:@string:] [:@identifier:]))
    { result :: <> [:@literal (highletValue (listletNth result @1)):] };

# Parses an `intlet` node.
parseIntlet = filterRule
    (seqRule [:@"@":] (questRule [:@"-":]) [:@integer:])
    { result ::
        sign = ifTrue { <> eq (listletNth result @1) @[] }
            { <> @1 } { <> @-1 };
        value = imul sign (highletValue (listletNth result @2));
        <> [:@literal value:]
    };

# Parses a `varRef` node.
parseVarRef = filterRule
    [:@identifier:]
    { result :: <> [:@varRef (highletValue result):] };

# Parses a `varDef` node.
parseVarDef = filterRule
    (seqRule [:@identifier:] [:@"=":] @expression)
    { result ::
        name = highletValue (listletNth result @0);
        value = listletNth result @2;
        <> [:@varDef @[@name=name @value=value]:]
    };

# Parses a `parenExpression` node.
parseParenExpression = filterRule
    (seqRule [:@"(":] @expression [:@")":])
    { result :: <> listletNth result @1 };

# Parses an `atom` node.
parseAtom = orRule @varRef @intlet @stringlet
    @emptyListlet @listlet @emptyMaplet @maplet
    @uniqlet @highlet @function @parenExpression;

# Parses an `expression` node.
parseExpression = orRule @call @atom;

# Parses a `statement` node.
parseStatement = orRule @varDef @expression;

# Parses a `nonlocalExit` node.
parseNonlocalExit = filterRule
    (seqRule
        [:@"<":]
        [:@identifier:]
        [:@">":]
        (questRule @expression)
        (starRule [:@";":]))
    { result ::
        varRef = [:@varRef (highletValue (listletNth result @1)):];
        actuals = listletNth result @3;
        <> apply makeCall varRef actuals
    };

# Parses a `yield` node.
parseYield = filterRule
    (seqRule [:@"<":] [:@">":] @expression (starRule [:@";":]))
    { result :: <> listletNth result @2 };

# Parses a `yieldDef` node.
parseYieldDef = filterRule
    (seqRule [:@"<":] [:@identifier:] [:@">":])
    { result :: <> highletValue (listletNth result @1) };

# Parses a `formal` node.
parseFormal = filterRule
    (seqRule
        (filterRule
            [:@identifier:]
            { result :: <> @[@name = (highletValue result)] })
        (filterRule
            (questRule
                (orRule [:@"*":] [:@"?":]))
            { result ::
                <> ifValue { <> listletNth result @0 }
                    { repeatToken :: <> @[@repeat = repeatToken] }
                    { <> @[=] }
            }))
    { result :: <> apply mapletAdd result };

# Parses a `formals` node.
parseFormals = plusRule @formal;

# `program` node helper: Parses `(formals? yieldDef? @"::")?`, yielding
# a maplet (possibly empty).
parseProgram1 = filterRule
    (questRule
        (filterRule
            (seqRule
                (questRule @formals)
                (questRule @yieldDef)
                [:@"::":])
            { result ::
                formals = ifValue { <> listletNth (listletNth result @0) @0 }
                    { value :: <> @[@formals=value] }
                    { <> @[=] };
                yieldDef = ifValue { <> listletNth (listletNth result @1) @0 }
                    { value :: <> @[@yieldDef=value] }
                    { <> @[=] };
                <> mapletAdd formals yieldDef
            }))
    { result ::
        <> ifValue { <> listletNth result @0 }
            { result :: <> result }
            { <> @[=] }
    };

# `program` node helper: Parses `(statement | nonlocalExit | yield)?`, yielding
# a maplet that maps `@yield` and `@statements`. Always Succeeds.
parseProgram2 = filterRule
    (questRule
        (orRule
            (filterRule
                (orRule @statement @nonlocalExit)
                { result :: <> @[@statements=@[result] @yield=@[=]] })
            (filterRule
                @yield
                { result :: <> @[@statements=@[] @yield=@[@yield=result]] })))
    { result ::
        <> ifValue { <> listletNth result @0 }
            { result :: <> result }
            { <> @[@statements=@[] @yield=@[=]] }
    };

# Parses a `program` node.
parseProgram = filterRule
    (seqRule
        parseProgram1
        (starRule [:@";":])
        (starRule
            (filterRule
                (seqRule @statement (plusRule [:@";":]))
                { result :: <> listletNth result @0 }))
        parseProgram2)
    { result ::
        formals = listletNth result @0;
        mostStatements = listletNth result @2;
        lastClause = listletNth result @3;
        statements = listletAdd mostStatements
            (mapletGet lastClause @statements);
        <> [:
            @function
            (mapletCat
                formals
                @[@statements=statements]
                (mapletGet lastClause @yield))
        :]
    };

# Parses a `function` node.
parseFunction = filterRule
    (seqRule [:@"{":] @program [:@"}":])
    { result :: <> listletNth result @1 };

# Maplet of all of the parser rules. Any time a parser rule is needed,
# it's looked up through this maplet by name, which trivially allows for
# mutually-recursive rules (since the rules refer directly to names and
# not actual functions).
RULES = @[
    @atom = parseAtom
    @binding = parseBinding
    @call = parseCall
    @emptyListlet = parseEmptyListlet
    @emptyMaplet = parseEmptyMaplet
    @expression = parseExpression
    @formal = parseFormal
    @formals = parseFormals
    @function = parseFunction
    @highlet = parseHighlet
    @intlet = parseIntlet
    @listlet = parseListlet
    @maplet = parseMaplet
    @nonlocalExit = parseNonlocalExit
    @parenExpression = parseParenExpression
    @program = parseProgram
    @statement = parseStatement
    @stringlet = parseStringlet
    @uniqlet = parseUniqlet
    @varDef = parseVarDef
    @varRef = parseVarRef
    @yield = parseYield
    @yieldDef = parseYieldDef
];


#
# Main `parse` function
#

# Parses a listlet of tokens as a program, using Samizdat Layer 0 tree
# syntax. Returns a `function` node.
parse = { tokens ::
    theReader = reader tokens;
    theEngine = engine theReader RULES;
    theProgram = parseProgram theEngine;

    ifFalse { <> theEngine @eof }
        {
            io0Note @"Pending tokens:";

            { <break> ::
                loop {
                    ifValue { <> theEngine @read }
                        { token :: io0Note (format @"    %q" token) }
                        { <break> }
                }
            }();

            io0Die @"Extra tokens at end of program."
        };

    <> theProgram;
};

<> @[@parse = parse];
