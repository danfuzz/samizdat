# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tree parser
#

#
# Helper functions
#

# Parses the indicated rule, If the rule is a highlet, then it
# is taken to represent a token type to read. Otherwise, it is taken to
# be a parser function to call. Returns the parsed item on success, or
# void on failure.
readOne = { reader rule ::
    <> ifTrue { <> isHighlet rule }
        {
            <> ifValue { <> reader @peek }
                { token ::
                    <> ifTrue { <> eq (highletType rule) (highletType token) }
                        {
                            reader @read;
                            <> token
                        }
                }
        }
        { <> rule reader }
};

# Parses all of the indicate rules, in order, returning a listlet of
# the results. Returns void if it could not parse everything requested.
readAll = { reader rule rest* ::
    mark = reader @at;
    <> ifValue { <> readOne reader rule }
        { firstResult ::
            <> ifTrue { <> eq rest @[] }
                { <> @[firstResult] }
                {
                    <> ifValue { <> apply readAll reader rest }
                        { result :: <> listletPrepend firstResult result }
                }
        }
        { reader @reset mark }
};

# Parses a list of alternate rules (`|` separated in PEG), returning
# the first successful result, or void if none succeeds.
orRule = { reader rule rest* ::
    <> ifValue { <> readOne reader rule }
        { result :: <> result }
        {
            <> ifTrue { <> ne rest @[] }
                { <> apply orRule reader rest }
        }
};

# Parses an optional rule (`?` suffix in PEG), returning a listlet
# of matched results, which will always be of length zero or one.
questRule = { reader rule ::
    <> ifValue { <> readOne reader rule }
        { result :: <> @[result] }
        { <> @[] }
};

# Parses a zero-or-more repetition rule (`*` suffix in PEG), returning a
# listlet of all the matched repetitions.
starRule = { reader rule ::
    <> whileReduce @[]
        { result ::
            <> ifValue { <> readOne reader rule }
                { match :: <> listletAppend result match }
        }
};

# Parses a one-or-more repetition rule (`+` suffix in PEG), returning a
# listlet of all the matched repetitions.
plusRule = { reader rule ::
    mark = reader @at;
    result = starRule reader rule;
    <> ifTrue { <> gt (lowSize result) @0 }
        { <> result }
        { reader @reset mark }
};

# Returns a `call` node.
makeCall = { function actuals* ::
    <> [:@call @[@function=function @actuals=actuals]:]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* specification.
#

# Parses a `function` node.
parseFunction = { reader ::
    <> ifValue { <> readAll reader [:@"{":] parseProgram [:@"}":] }
        { result :: <> listletNth result @1 }
};

# Parses a `program` node.
parseProgram = { reader ::
    formals = questRule reader parseProgram1;
    formalsResult = ifValue { <> listletNth formals @0 }
        { result :: @[@formals=result] }
        { <> @[=] };

    starRule reader [:@";":]; # Optional semicolons.

    statements = starRule reader parseProgram2;
    almostResult = parseProgram3 reader statements;

    <> [:
        @function
        (mapletAdd formalsResult almostResult)
    :]
};

# `program` node helper: Parses `(formals? @"::")`. May fail.
parseProgram1 = { reader ::
    <> ifValue
        {
            <> readAll reader
                { reader :: questRule reader parseFormals }
                [:@"::":]
        }
        { result ::
            formals = listletNth result @0;
            <> ifValue { <> listletNth formals @0 }
                { result :: <> result }
        };
};

# `program` node helper: Parses `(statement @";"+)`.
parseProgram2 = { reader ::
    <> readAll reader
        parseStatement
        { reader:: <> plusRule reader [:@";":] }
};

# `program` node helper: Parses `(statement | yield)?`, yielding
# a combined yield-and-statements maplet.
parseProgram3 = { reader statements ::
    <> ifValue { <> parseStatement reader }
        { <> @[@statements = (listletAppend statements statement)] }
        {
            <> ifValue { <> parseYield reader }
                { <> @[@statements=statements @yield=yield] }
                { <> @[@statements=statements] }
        }
};

# Parses a `formals` node.
parseFormals = { reader ::
    <> ifValue { <> plusRule reader parseFormals1 }
        { almostResult ::
            <> ifValue { <> readOne reader [:@"*":] }
                {
                    n = isub (lowSize almostResult) @1;
                    last = listletNth almostResult n;
                    result = listletPutNth almostResult n
                        (mapletPut last @repeat @[@type=@"*"]);
                    <> [:@formals result:]
                }
                { <> [:@formals almostResult:] }
        }
};

# `formals` node helper: Parses `identifier`, returning a maplet.
parseFormals1 = { reader ::
    <> ifValue { <> readOne reader [:@identifier:] }
        { result :: <> @[@name = (highletValue result)] }
};

# Parses a `yield` node.
parseYield = { reader ::
    <> ifValue { <> readAll reader [:@"<>":] parseExpression }
        { result ::
            starRule reader [:@";":]; # Optional semicolons.
            <> listletNth result @1;
        }
};

# Parses a `statement` node.
parseStatement = { reader ::
    <> orRule reader parseVarDef parseExpression
};

# Parses an `expression` node.
parseExpression = { reader ::
    <> orRule reader parseCall parseAtom
};

# Parses an `atom` node.
parseAtom = { reader ::
    <> orRule reader parseVarRef parseIntlet parseStringlet
        parseEmptyListlet parseListlet parseEmptyMaplet parseMaplet
        parseUniqlet parseHighlet parseFunction parseParenExpression
};

# Parses a `parenExpression` node.
parseParenExpression = { reader ::
    <> ifValue { <> readAll reader [:@"(":] parseExpression [:@")":] }
        { result :: <> listletNth result @1 }
};

# Parses a `varDef` node.
parseVarDef = { reader ::
    <> ifValue { <> readAll reader [:@identifier:] [:@"=":] parseExpression }
        { result ::
            name = highletValue (listletNth result @0);
            value = listletNth result @2;
            <> [: @varDef @[@name=name @value=value] :];
        }
};

# Parses a `varRef` node.
parseVarRef = { reader ::
    <> ifValue { <> readOne reader [:@identifier:] }
        { result :: <> [:@varRef (highletValue result):] }
};

# Parses an `intlet` node.
parseIntlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                { reader :: <> questRule reader [:@"-":] }
                [:@integer:]
        }
        { result ::
            sign = ifTrue { <> eq (listletNth result @1) @[] }
                { <> @1 } { @-1 };
            value = imul sign (highletValue (listletNth result @2));
            <> [:@intlet value:]
        }
};

# Parses a `stringlet` node.
parseStringlet = { reader ::
    <> ifValue { <> orRule reader [:@string:] [:@identifier:] }
        { result :: <> [:@literal (highletValue result):]}
};

# Parses a `emptyListlet` node.
parseEmptyListlet = { reader ::
    <> ifValue { <> readAll reader [:@"@":] [:@"[":] [:@"]":] }
        { <> [:@literal @[]:]}
};

# Parses a `listlet` node.
parseListlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                [:@"[":]
                { reader :: <> plusRule reader parseAtom }
                [:@"]":]
        }
        { result ::
            <> apply makeCall [:@varRef @makeListlet:] (listletNth result @2)
        }
};

# Parses a `emptyMaplet` node.
parseEmptyMaplet = { reader ::
    <> ifValue { <> readAll reader [:@"@":] [:@"[":] [:@"=":] [:@"]":] }
        { <> [:@literal @[=]:]}
};

# Parses a `maplet` node.
parseMaplet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                [:@"[":]
                { reader :: <> plusRule reader parseBinding }
                [:@"]":]
        }
        { result ::
            bindings = apply listletCat (listletNth result @2);
            <> apply makeCall [:@varRef @makeMaplet:] bindings
        }
};

# Parses a `binding` node.
parseBinding = { reader ::
    <> ifValue
        { <> readAll reader parseAtom [:@"=":] parseAtom }
        { result ::
            <> @[(listletNth result @0) (listletNth result @2)]
        }
};

# Parses a `uniqlet` node.
parseUniqlet = { reader ::
    <> ifValue { <> readAll reader [:@"@":] [:@"@":] }
        { <> [:@varRef @uniqlet:]}
};

# Parses a `highlet` node.
parseHighlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"[":]
                [:@":":]
                parseAtom
                { reader :: <> questRule reader parseAtom }
                [:@":":]
                [:@"]":]
        }
        { result ::
            <> apply makeCall [:@varRef @makeHighlet:]
                (listletNth result @2)
                (listletNth result @3)
        }
};

# Parses a `call` node.
parseCall = { reader ::
    <> ifValue
        {
            <> readAll reader
                parseAtom
                { reader :: <> orRule reader
                    parseCall1
                    { reader :: <> plusRule reader parseAtom }
                }
        }
        { result ::
            <> apply makeCall (listletNth result @0) (listletNth result @1)
        }
};

# `call` node helper: Parses literal `()`, returning an empty listlet.
parseCall1 = { reader ::
    <> ifValue { <> readAll reader [:@"(":] [:@")":] }
        { <> @[] }
};


#
# Main `parse` function
#

# Parses a listlet of tokens as a program, using Samizdat Layer 0 tree
# syntax. Returns a `function` node.
parse = { tokens ::
    theReader = reader tokens;
    theProgram = parseProgram theReader;

    ifFalse { <> theReader @eof }
        {
            sam0Note @"Pending tokens:"
            while {
                ifValue { <> theReader @read }
                    { token ::
                        sam0Note (format @"    %q" token)
                    }
                    { <> false }
            }
            sam0Die @"Extra tokens at end of program."
        };
    <> parseProgram theReader;
};

# Parses a listlet of tokens as a program, using Samizdat Layer 0 tree
# syntax. Returns a `function` node.
stubParse = { tokens ::
    theReader = reader tokens;

    theCall = [:
        @call
        @[
            @function=[:@varRef @io0WriteFileUtf8:]
            @actuals=@[
                [:@literal @[@"dev" @"stdout"]:]
                [:@literal @"We have received the Самиздат!\n":]
            ]
        ]
    :];

    <> [:
        @function
        @[
            @formals=[:@formals @[]:]
            @statements=@[theCall]
        ]
    :]
};

<> @[@parse = stubParse];
