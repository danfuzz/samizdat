# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tree parser
#

#
# Helper functions
#

# Parses the indicated rule, If the rule is a highlet, then it
# is taken to represent a token type to read. Otherwise, it is taken to
# be a parser function to call. Returns the parsed item on success, or
# void on failure.
readOne = { reader rule ::
    <> ifTrue { <> isHighlet rule }
        {
            <> ifValue { <> reader @peek }
                { token ::
                    <> ifTrue { <> eq (highletType rule) (highletType token) }
                        {
                            reader @read;
                            <> token
                        }
                }
        }
        { <> rule reader }
};

# Parses all of the indicate rules, in order, returning a listlet of
# the results. Returns void if it could not parse everything requested.
readAll = { reader rest* ::
    doReads = { rule rest* ::
        <> ifValue { <> readOne reader rule }
            { firstResult ::
                <> ifTrue { <> eq rest @[] }
                    { <> @[firstResult] }
                    {
                        <> ifValue { <> apply doReads rest }
                            { result :: <> listletPrepend firstResult result }
                    }
            }
    };

    mark = reader @at;

    <> ifValue { <> apply doReads rest }
        { result :: <> result }
        { reader @reset mark }
};

# Returns a rule which succeeds if a given other rule succeeds, and
# if so runs the given result filter function, passing it the rule
# result, to produce the final result of processing.
filterRule = { rule filterFunction ::
    <> { reader ::
        <> ifValue { <> rule reader } filterFunction
    }
};

# Returns a rule which succeeds if the given token type is successfully
# read.
tokenRule = { token ::
    type = highletType token;

    <> { reader ::
        <> ifValue { <> reader @peek }
            { got ::
                <> ifTrue { <> eq type (highletType got) }
                    {
                        reader @read;
                        <> got
                    }
            }
    }
};

# Returns a rule which succeeds if all of a list of other rules
# succeeds in order (said list given in the form of separate arguments
# to this function). The result, if successful, is a listlet of all
# the rule results. This effectively implements the "adjacency operator"
# in PEG.
allRule = { rules* ::
    <> { reader ::
        doAll = { rule rest* ::
            <> ifValue { <> readOne reader rule }
                { firstResult ::
                    <> ifTrue { <> eq rest @[] }
                        { <> @[firstResult] }
                        {
                            <> ifValue { <> apply doAll rest }
                                { result ::
                                    <> listletPrepend firstResult result }
                        }
                }
        };

        mark = reader @at;

        <> ifValue { <> apply doAll rules }
            { result :: <> result }
            { reader @reset mark }
    }
};

# Returns a rule which succeeds if any of a list of other rules
# succeeds (said list given in the form of separate arguments to this
# function), trying them in order. The result is the same as the
# result of whichever rule succeeded, or void if all the alternatives
# failed. This effectively implements the `|` operator in PEG.
orRule = { rules* ::
    <> { reader ::
        doOr = { rule rest* ::
            <> ifValue { <> readOne reader rule }
                { result :: <> result }
                {
                    <> ifTrue { <> ne rest @[] }
                        { <> apply doOr rest }
                }
        };

        <> apply doOr rules
    }
};

# Returns a rule which optionally parses a given other rule. The
# rule when run always succeeds, yielding a listlet. The listlet will
# have either zero or one element, depending on whether the inner
# rule was matched. This effectively implements the `?` suffix in PEG.
questRule = { rule ::
    <> { reader ::
        <> ifValue { <> readOne reader rule }
            { result :: <> @[result] }
            { <> @[] }
    }
};

# Returns a rule which parses zero or more repetitions of a given other
# rule. The rule when run always succeeds, yielding a listlet of all
# the results of matching. It will be a zero-length listlet if in fact
# the inner rule never matched. This effectively implements the `*`
# suffix in PEG.
starRule = { rule ::
    <> { reader ::
        <> whileReduce @[]
            { result ::
                <> ifValue { <> readOne reader rule }
                    { match :: <> listletAppend result match }
            }
    }
};

# Returns a rule which parses one or more repetitions of a given other
# rule. The rule when successful yields a listlet of all the results of
# matching and will be of size one or more. This effectively implements
# the `+` suffix in PEG.
plusRule = { rule ::
    subRule = allRule rule (starRule rule);
    <> { reader ::
        <> ifValue { <> subRule reader }
            { result :: <> apply listletPrepend result }
    }
};

# Returns a `call` node.
makeCall = { function actuals* ::
    <> [:@call @[@function=function @actuals=actuals]:]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* specification.
#

# Parses a `function` node.
parseFunction = { reader ::
    <> ifValue { <> readAll reader [:@"{":] parseProgram [:@"}":] }
        { result :: <> listletNth result @1 }
};

# `call` node helper: Parses literal `()`, returning an empty listlet.
parseCall1 = { reader ::
    <> ifValue { <> readAll reader [:@"(":] [:@")":] }
        { <> @[] }
};

# Parses a `call` node.
parseCall = { reader ::
    <> ifValue
        {
            <> readAll reader
                parseAtom
                (orRule
                    parseCall1
                    (plusRule parseAtom))
        }
        { result ::
            <> apply makeCall (listletNth result @0) (listletNth result @1)
        }
};

# Parses a `highlet` node.
parseHighlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"[":]
                [:@":":]
                parseAtom
                (questRule parseAtom)
                [:@":":]
                [:@"]":]
        }
        { result ::
            <> apply makeCall [:@varRef @makeHighlet:]
                (listletNth result @2)
                (listletNth result @3)
        }
};

# Parses a `uniqlet` node.
parseUniqlet = { reader ::
    <> ifValue { <> readOne reader [:@"@@":] }
        { <> [:@varRef @makeUniqlet:] }
};

# Parses a `binding` node.
parseBinding = { reader ::
    <> ifValue
        { <> readAll reader parseAtom [:@"=":] parseAtom }
        { result ::
            <> @[(listletNth result @0) (listletNth result @2)]
        }
};

# Parses a `maplet` node.
parseMaplet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                [:@"[":]
                (plusRule parseBinding)
                [:@"]":]
        }
        { result ::
            bindings = apply listletCat (listletNth result @2);
            <> apply makeCall [:@varRef @makeMaplet:] bindings
        }
};

# Parses a `emptyMaplet` node.
parseEmptyMaplet = { reader ::
    <> ifValue { <> readAll reader [:@"@":] [:@"[":] [:@"=":] [:@"]":] }
        { <> [:@literal @[=]:] }
};

# Parses a `listlet` node.
parseListlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                [:@"[":]
                (plusRule parseAtom)
                [:@"]":]
        }
        { result ::
            <> apply makeCall [:@varRef @makeListlet:] (listletNth result @2)
        }
};

# Parses a `emptyListlet` node.
parseEmptyListlet = { reader ::
    <> ifValue { <> readAll reader [:@"@":] [:@"[":] [:@"]":] }
        { <> [:@literal @[]:] }
};

# Parses a `stringlet` node.
parseStringlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                (orRule [:@string:] [:@identifier:])
        }
        { result :: <> [:@literal (highletValue (listletNth result @1)):] }
};

# Parses an `intlet` node.
parseIntlet = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"@":]
                (questRule [:@"-":])
                [:@integer:]
        }
        { result ::
            sign = ifTrue { <> eq (listletNth result @1) @[] }
                { <> @1 } { <> @-1 };
            value = imul sign (highletValue (listletNth result @2));
            <> [:@literal value:]
        }
};

# Parses a `varRef` node.
parseVarRef = { reader ::
    <> ifValue { <> readOne reader [:@identifier:] }
        { result :: <> [:@varRef (highletValue result):] }
};

# Parses a `varDef` node.
parseVarDef = { reader ::
    <> ifValue { <> readAll reader [:@identifier:] [:@"=":] parseExpression }
        { result ::
            name = highletValue (listletNth result @0);
            value = listletNth result @2;
            <> [:@varDef @[@name=name @value=value]:];
        }
};

# Parses a `parenExpression` node.
parseParenExpression = { reader ::
    <> ifValue { <> readAll reader [:@"(":] parseExpression [:@")":] }
        { result :: <> listletNth result @1 }
};

# Parses an `atom` node.
parseAtom = orRule parseVarRef parseIntlet parseStringlet
    parseEmptyListlet parseListlet parseEmptyMaplet parseMaplet
    parseUniqlet parseHighlet parseFunction parseParenExpression;

# Parses an `expression` node.
parseExpression = orRule parseCall parseAtom;

# Parses a `statement` node.
parseStatement = orRule parseVarDef parseExpression;

# Parses a `yield` node.
parseYield = { reader ::
    <> ifValue
        {
            <> readAll reader
                [:@"<>":]
                parseExpression
                (starRule [:@";":])
        }
        { result :: <> listletNth result @1; }
};

# `formals` node helper: Parses `identifier`, returning a maplet.
parseFormals1 = { reader ::
    <> ifValue { <> readOne reader [:@identifier:] }
        { result :: <> @[@name = (highletValue result)] }
};

# Parses a `formals` node.
parseFormals = { reader ::
    <> ifValue
        {
            <> readAll reader
                (plusRule parseFormals1)
                (questRule [:@"*":])
        }
        { result ::
            almostFormals = listletNth result @0;
            starMod = listletNth result @1;
            formals = ifValue { <> listletNth starMod @0 }
                { starToken ::
                    n = isub (lowSize almostFormals) @1;
                    last = listletNth almostFormals n;
                    <> listletPutNth almostFormals n
                        (mapletPut last @repeat starToken);
                }
                { <> almostFormals };
            <> [:@formals formals:]
        }
};

# `program` node helper: Parses `(formals? @"::")`. May fail. On success,
# returns a maplet (possibly empty).
parseProgram1 = { reader ::
    <> ifValue
        {
            <> readAll reader
                (questRule parseFormals)
                [:@"::":]
        }
        { result ::
            formals = listletNth result @0;
            <> ifValue { <> listletNth formals @0 }
                { result :: <> @[@formals=result] }
                { <> @[=] }
        }
};

# `program` node helper: Parses `(statement @";"+)`. Returns listlet of
# statements.
parseProgram2 = { reader ::
    <> ifValue
        {
            <> readAll reader
                parseStatement
                (plusRule [:@";":])
        }
        { result :: <> listletNth result @0 }
};

# `program` node helper: Parses `(statement | yield)?`, yielding
# a maplet that maps `@yield` and `@statements`. May fail.
parseProgram3 = { reader ::
    <> ifValue { <> parseStatement reader }
        { result :: <> @[@statements=@[result] @yield=@[=]] }
        {
            <> ifValue { <> parseYield reader }
                { result :: <> @[@statements=@[] @yield=@[@yield=result]] }
        }
};

# Parses a `program` node.
parseProgram = { reader ::
    <> ifValue
        {
            <> readAll reader
                (questRule parseProgram1)
                (starRule [:@";":])
                (starRule parseProgram2)
                (questRule parseProgram3)
        }
        { result ::
            formals = ifValue { <> listletNth (listletNth result @0) @0 }
                { result :: <> result }
                { <> @[=] };
            mostStatements = listletNth result @2;
            lastClause = ifValue { <> listletNth (listletNth result @3) @0 }
                { result :: <> result }
                { <> @[@statements=@[] @yield=@[=]] };
            statements = listletAdd mostStatements
                (mapletGet lastClause @statements);
            <> [:
                @function
                (mapletCat
                    formals
                    @[@statements=statements]
                    (mapletGet lastClause @yield))
            :]
        }
};



#
# Main `parse` function
#

# Parses a listlet of tokens as a program, using Samizdat Layer 0 tree
# syntax. Returns a `function` node.
parse = { tokens ::
    theReader = reader tokens;
    theProgram = parseProgram theReader;

    ifFalse { <> theReader @eof }
        {
            io0Note @"Pending tokens:";
            while {
                <> ifValue { <> theReader @read }
                    { token ::
                        io0Note (format @"    %q" token);
                        <> true
                    }
                    { <> false }
            };
            io0Die @"Extra tokens at end of program."
        };

    <> theProgram;
};

<> @[@parse = parse];
