# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tokenizer
#
# The following is a near-transliteration of the token grammar in
# the *Samizdat Layer 0* specification.
#

# Parses an entire file of tokens.
parseFile = filterRule
    (seqRule
        (starRule
            (filterRule
                (seqRule (starRule @whitespace) @token)
                { result :: <> listNth result @1 }))
        (starRule @whitespace))
    { result :: <> listNth result @0 };

# Parses a single token.
parseToken = orRule @punctuation @integer @string @identifier;

# Parses any of the punctuation characters or character sequences, yielding
# a token whose type is the string matched.
parsePunctuation = filterRule
    (orRule
        (charsRule @"@@")
        (charsRule @"::")
        (charsRule @"<>")
        (charSetRule @"@:*;=-?<>{}()[]"))
    { result :: <> [:result:] };

# These are all the integer digits, as a map from strings to
# digit values.
INTEGER_CHARS =
    [ @"0"=@0 @"1"=@1 @"2"=@2 @"3"=@3 @"4"=@4
      @"5"=@5 @"6"=@6 @"7"=@7 @"8"=@8 @"9"=@9 ];

# Parses an `integer` token.
parseInteger = filterRule
    (plusRule
        (filterRule
            (charSetRule @"0123456789")
            { result :: <> mapGet INTEGER_CHARS result }))
    { result ::
        value = listReduce @0 result
            { result digit :: <> iadd digit (imul result @10) };
        <> [:@integer value:]
    };

# Parses a single string character.
parseString1 = orRule
    (notCharSetRule @"\\\"")
    (filterRule
        (seqRule
            (charsRule @"\\")
            (orRule
                (filterRule (charsRule @"\\") { <> @"\\" })
                (filterRule (charsRule @"\"") { <> @"\"" })
                (filterRule (charsRule @"n")  { <> @"\n" })))
        { result :: <> listNth result @1 });

# Parses a `string` token.
parseString = filterRule
    (seqRule
        (charsRule @"\"")
        (starRule parseString1)
        (charsRule @"\""))
    { result ::
        value = apply stringAdd (listNth result @1);
        <> [:@string value:]
    };

# These are all the characters which are allowed to start an identifier.
IDENTIFIER_START_CHARS =
    @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";

# These are all the characters which are allowed to be in an identifier.
IDENTIFIER_CHARS = stringAdd IDENTIFIER_START_CHARS @"0123456789";

# Parses an `identifier` token.
parseIdentifier = filterRule
    (seqRule
        (charSetRule IDENTIFIER_START_CHARS)
        (starRule (charSetRule IDENTIFIER_CHARS)))
    { result ::
        value = stringAdd
            (listNth result @0)
            (apply stringAdd (listNth result @1));
        <> [:@identifier value:]
    };

# Parses a single whitespace character or a comment.
parseWhitespace = orRule
    (charSetRule @" \n")
    (seqRule
        (charsRule @"#")
        (starRule (notCharSetRule @"\n"))
        (charsRule @"\n"));

# Map of all the tokenizer rules.
TOKEN0_RULES = [
    @file = parseFile
    @identifier = parseIdentifier
    @integer = parseInteger
    @punctuation = parsePunctuation
    @string = parseString
    @token = parseToken
    @whitespace = parseWhitespace
];

<> [@TOKEN0_RULES = TOKEN0_RULES]
