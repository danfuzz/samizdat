# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tokenizer
#
# The following is a near-transliteration of the token grammar in
# the *Samizdat Layer 0* specification.
#

# Parses an entire file of tokens.
parseFile = filterRule
    (seqRule
        (starRule
            (filterRule
                (seqRule (starRule "whitespace") "token")
                { result :: <> listNth result 1 }))
        (starRule "whitespace"))
    { result :: <> listNth result 0 };

# Parses a single token.
parseToken = orRule
    "punctuation" "int" "string" "identifier" "quotedIdentifier";

# Parses any of the punctuation characters or character sequences, yielding
# a token whose type is the string matched.
parsePunctuation = filterRule
    (orRule
        (charsRule "@@")
        (charsRule "::")
        (charsRule "<>")
        (charsRule "()")
        (charSetRule ".@:*;=?+<>{}()[]"))
    { result :: <> @[result] };

# These are all the int digits, as a map from strings to
# digit values.
INT_CHARS = ["0"=0 "1"=1 "2"=2 "3"=3 "4"=4 "5"=5 "6"=6 "7"=7 "8"=8 "9"=9];

# Parses an `int` token.
parseInt = filterRule
    (seqRule
        (filterRule
            (optRule (charsRule "-"))
            { result :: <> ifTrue { <> eq result [] } { <> 1 } { <> -1 } })
        (plusRule
            (filterRule
                (charSetRule "0123456789")
                { result :: <> mapGet INT_CHARS result })))
    { result ::
        sign = listNth result 0;
        value = listReduce 0 (listNth result 1)
            { result . digit :: <> iadd digit (imul result 10) };
        <> @["int" (imul sign value)]
    };

# Parses a single string character.
parseString1 = orRule
    (notCharSetRule "\\\"")
    (filterRule
        (seqRule
            (charsRule "\\")
            (orRule
                (filterRule (charsRule "\\") { <> "\\" })
                (filterRule (charsRule "\"") { <> "\"" })
                (filterRule (charsRule "n")  { <> "\n" })))
        { result :: <> listNth result 1 });

# Parses a `string` token.
parseString = filterRule
    (seqRule
        (charsRule "\"")
        (starRule parseString1)
        (charsRule "\""))
    { result ::
        value = apply stringAdd (listNth result 1);
        <> @["string" value]
    };

# These are all the characters which are allowed to start an identifier.
IDENTIFIER_START_CHARS =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";

# These are all the characters which are allowed to be in an identifier.
IDENTIFIER_CHARS = stringAdd IDENTIFIER_START_CHARS "0123456789";

# Parses a `quotedIdentifier` token.
parseQuotedIdentifier = filterRule
    (seqRule (charsRule "\\") "string")
    { result ::
        value = highletValue (listNth result 1);
        <> @["identifier" value]
    };

# Parses an `identifier` token.
parseIdentifier = filterRule
    (seqRule
        (charSetRule IDENTIFIER_START_CHARS)
        (starRule (charSetRule IDENTIFIER_CHARS)))
    { result ::
        value = stringAdd
            (listNth result 0)
            (apply stringAdd (listNth result 1));
        <> @["identifier" value]
    };

# Parses a single whitespace character or a comment.
parseWhitespace = orRule
    (charSetRule " \n")
    (seqRule
        (charsRule "#")
        (starRule (notCharSetRule "\n"))
        (charsRule "\n"));

# Map of all the tokenizer rules.
TOKEN0_RULES = [
    "file" = parseFile
    "identifier" = parseIdentifier
    "int" = parseInt
    "punctuation" = parsePunctuation
    "quotedIdentifier" = parseQuotedIdentifier
    "string" = parseString
    "token" = parseToken
    "whitespace" = parseWhitespace
];

<> ["TOKEN0_RULES" = TOKEN0_RULES]
