# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. See the associated file "LICENSE.md" for details.

#
# Samizdat Layer 1
#
# This is a Samizdat Layer 0 program which runs Samizdat Layer 0
# programs.
#

#
# Helper functions (likely to be moved to the samizdat-0 core library)
#

# Returns the last element of a given listlet.
last = { value ::
    ^ getNth value (isub (lowSize value) @1);
};

# Returns the listlet consisting of all but the last element of a
# given listlet.
butLast = { value ::
    ^ delNth value (isub (lowSize value) @1);
};

# Returns true iff the given value is an intlet.
isIntlet = { value ::
    ^ eq (lowType value) @"intlet";
};

# Returns true iff the given value is a listlet.
isListlet = { value ::
    ^ eq (lowType value) @"listlet";
};

# Returns true iff the given value is a maplet.
isMaplet = { value ::
    ^ eq (lowType value) @"maplet";
};

# Returns true iff the given value is a uniqlet.
isUniqlet = { value ::
    ^ eq (lowType value) @"uniqlet";
};

# Converts an arbitrary value into a stringlet representation form.
toStringlet = { value ::
    listletBody = { value ::
        ^ if { ^ eq value @[]; } {
            ^ @"";
        } else {
            start = listletBody (butLast value);
            ^ cat
                (if { ^ eq start @""; } {
                    ^ @"";
                } else {
                    ^ cat start @" ";
                })
                (toStringlet (last value));
        };
    };

    intletBody = { value ::
        ^ if { ^ eq value @0; } {
            ^ @"";
        } else {
            digit = iadd (imod value @10) @48;
            more = idiv value @10;
            ^ cat (intletBody more) @[digit];
        };
    };

    ^ if { ^ isIntlet value; } {
        ^ if { ^ lt value @0; } {
            ^ cat @"@-" (intletBody (ineg value));
        } { ^ eq value @0; } {
            ^ @"@0";
        } else {
            ^ cat @"@" (intletBody value);
        };
    } { ^ isListlet value; } {
        ^ cat @"@[" (listletBody value) @"]";
    } { ^ isMaplet value; } {
        # TODO
    } { ^ isUniqlet value; } {
        ^ @"@@";
    } else {
        ^ @"<unknown>";
    };
};


#
# Meat of the implementation
#

# Tokenizes the given string, using Samizdat Layer 0 token syntax.
# Returns a listlet of tokens.
tokenize = { programText ::
    # TODO
    ^ @[];
};

# Parses a listlet of tokens, using Samizdat Layer 0 tree syntax.
# Returns a `statements` node.
parse = { tokens ::
    # TODO

    theCall = @[
        @"type"=@"call"
        @"value"=@[
            @"function"=@"writeFile"
            @"actuals"=@[@"/dev/stdout" @"Hello, Самиздат!\n"]
        ]
    ];

    ^ @[@"type"=@"statements" @"value"=@[theCall]];
};


#
# Main function
#

# Compiles the file named in the first argument in a fresh context,
# and runs its `main`, passing it an array of the rest of the
# arguments.
#
# Note: Samizdat Layer 0 does not support varargs, so this function
# needs to be written to take exactly as many arguments as are needed
# in the primary use case.
main = { file arg1 arg2 arg3 ::
    # Be welcoming.

    if { ^ eq file @"danfuzz"; } {
        writeFile @"/dev/stdout" @"Hello, Danfuzz!\n";
    } else {
        writeFile @"/dev/stdout" @"Hello, Самиздат!\n";
    };

    writeFile @"/dev/stdout" (toStringlet @0);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @98765);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @-12345);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@1]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@1 @2]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@1 @2 @300]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @"");
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @"Blort.");
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" @"\n";

    programText = readFile file;

    tokens = tokenize programText;
    if { ^ eq tokens null; } { ^ @1; };

    statements = parse tokens;
    if { ^ eq statements null; } { ^ @1; };

    # TODO: Bind statements as a function using exposed interface from
    # samizdat-0, and call it.
};
