# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. See the associated file "LICENSE.md" for details.

#
# Samizdat Layer 1
#
# This is a Samizdat Layer 0 program which runs Samizdat Layer 0
# programs.
#

#
# Helper functions (likely to be moved to the samizdat-0 core library)
#

# Cascading conditional. Takes an even number of arguments,
# alternating predicates and consequents. The predicates are run in
# order until one returns `true`. The consequent immediately after the
# `true` predicate then gets run, and its return value becomes the
# result of this function. If no predicate returns `true`, this
# function returns `null`.
if = { predicate consequent rest* ::
    ^ ifElse (predicate())
        consequent
        { ^ ifElse (eq rest @[]) { ^ null; } { ^ apply if rest; }; };
};

# Short-circuit conjunction. Takes an arbitrary number of predicates.
# Runs each of them in turn until one of them returns `false`. If no
# predicate returns `false`, this function returns `true`.
and = { predicate rest* ::
    ^ ifElse (predicate())
        { ^ ifElse (eq rest @[]) { ^ true; } { ^ apply and rest; }; }
        { ^ false; };
};

# Short-circuit disjunction. Takes an arbitrary number of predicates.
# Runs each of them in turn until one of them returns `true`. If no
# predicate returns `true`, this function returns `false`.
or = { predicate rest* ::
    ^ ifElse (predicate())
        { ^ true; }
        { ^ ifElse (eq rest @[]) { ^ false; } { ^ apply and rest; }; };
};

# Maps each value of a listlet, collecting the results into a new
# listlet. The given function is called on each value, with two
# arguments, namely the value and its index number.
map = { listlet func ::
    size = lowSize listlet;
    doMap = { index ::
        ^ if { ^ eq index size; } {
            ^ @[];
        } else {
            ^ cat
                @[(func (getNth listlet index) index)]
                (doMap (iadd index @1));
        };
    };
    ^ doMap @0;
};

# Reduces a listlet to a single value, given a base value and a
# reducer function, operating in low-to-high index order. The given
# function is called on each value, with three arguments: the last
# reduction result, the value, and its index number.
reduce = { listlet base func ::
    size = lowSize listlet;
    doReduce = { reduction index ::
        ^ if { ^ eq index size; } {
            ^ reduction;
        } else {
            ^ doReduce
                (func reduction (getNth listlet index) index)
                (iadd index @1);
        };
    };
    ^ doReduce base @0;
};

# Returns the last element of a given listlet.
last = { value ::
    ^ getNth value (isub (lowSize value) @1);
};

# Returns the listlet consisting of all but the last element of a
# given listlet.
butLast = { value ::
    ^ delNth value (isub (lowSize value) @1);
};

# Returns true iff the given value is an intlet.
isIntlet = { value ::
    ^ eq (lowType value) @"intlet";
};

# Returns true iff the given value is a listlet.
isListlet = { value ::
    ^ eq (lowType value) @"listlet";
};

# Returns true iff the given value is a maplet.
isMaplet = { value ::
    ^ eq (lowType value) @"maplet";
};

# Returns true iff the given value is a uniqlet.
isUniqlet = { value ::
    ^ eq (lowType value) @"uniqlet";
};

# Returns true iff the given value is a stringlet (which is the
# same as a listlet with intlet elements in the range of Unicode
# code points).
isStringlet = { value ::
    ^ and
        { ^ isListlet value; }
        {
            isValidCode = { value ::
                # Note: 1114111 == 0x10ffff, which is the highest valid
                # Unicode code point.
                ^ and { ^ ge value @0; } { ^ le value @1114111; };
            };

            check = { value ::
                ^ or
                    { ^ eq value @[]; }
                    {
                        lastValue = last value;
                        ^ and
                            { ^ isIntlet lastValue; }
                            { ^ isValidCode lastValue; }
                            { ^ check (butLast value); };
                    };
            };

            ^ check value;
        };
};

# Converts an arbitrary value into a stringlet representation form.
toStringlet = { value ::
    intletBody = { start value ::
        ^ if { ^ eq value @0; } {
            ^ start;
        } else {
            digit = iadd (imod value @10) @48; # 48 == "0"
            more = idiv value @10;
            ^ cat (intletBody start more) @[digit];
        };
    };

    intletHex = { value ::
        ^ if { ^ eq value @0; } {
            ^ @"";
        } else {
            digit = getNth @"0123456789abcdef" (imod value @16);
            more = idiv value @16;
            ^ cat (intletHex more) @[digit];
        };
    };

    stringletChar = { ch ::
        ^ if { ^ eq ch @0; } {
            ^ @"\\0";
        } { ^ eq ch @10; } {
            ^ @"\\n";
        } { ^ or { ^ eq ch @34; } { ^ eq ch @92; }; } {
            # 34 == "\"" and 92 == "\\"
            ^ cat @"\\" @[ch];
        } { ^ or { ^ le ch @31; }
                  { ^ and { ^ ge ch @127; } { ^ le ch @159; }; }; } {
            # These are the ranges for nonprinting control characters.
            ^ cat @"\\x" (intletHex ch) @";";
        } else {
            ^ @[ch];
        };
    };

    ^ if { ^ eq value @[]; } {
        ^ @"@[]";
    } { ^ eq value @[=]; } {
        ^ @"@[=]";
    } { ^ isIntlet value; } {
        ^ if { ^ eq value @0; } {
            ^ @"@0";
        } { ^ gt value @0; } {
            ^ intletBody @"@" value;
        } else {
            ^ intletBody @"@-" (ineg value);
        };
    } { ^ isStringlet value; } {
        body = reduce value @""
            { reduction item :: ^ cat reduction (stringletChar item); };
        ^ cat @"@\"" body @"\"";
    } { ^ isListlet value; } {
        body = reduce value @""
            { reduction elem ::
                ^ cat
                    reduction
                    (if { ^ eq reduction @""; } { ^ @""; } else { ^ @" "; })
                    (toStringlet elem);
            };
        ^ cat @"@[" body @"]";
    } { ^ isMaplet value; } {
        body = reduce (getKeys value) @""
            { reduction key ::
                ^ cat
                    reduction
                    (if { ^ eq reduction @""; } { ^ @""; } else { ^ @" "; })
                    (toStringlet key)
                    @"="
                    (toStringlet (getValue value key));
            };
        ^ cat @"@[" body @"]";
    } { ^ isUniqlet value; } {
        ^ @"@@";
    } else {
        ^ @"<unknown>";
    };
};


#
# Meat of the implementation
#

# Tokenizes the given string, using Samizdat Layer 0 token syntax.
# Returns a listlet of tokens.
tokenize = { programText ::
    # TODO
    ^ @[];
};

# Parses a listlet of tokens, using Samizdat Layer 0 tree syntax.
# Returns a `statements` node.
parse = { tokens ::
    # TODO

    theCall = @[
        @"type"=@"call"
        @"value"=@[
            @"function"=@"writeFile"
            @"actuals"=@[@"/dev/stdout" @"Hello, Самиздат!\n"]
        ]
    ];

    ^ @[@"type"=@"statements" @"value"=@[theCall]];
};


#
# Main function
#

# Compiles the file named in the first argument in a fresh context,
# and runs its `main`, passing it an array of the rest of the
# arguments.
#
# Note: Samizdat Layer 0 does not support varargs, so this function
# needs to be written to take exactly as many arguments as are needed
# in the primary use case.
main = { file arg1 arg2 arg3 ::
    # Be welcoming.

    ifElse (eq file @"danfuzz") {
        writeFile @"/dev/stdout" @"Hello, Danfuzz!\n";
    } {
        writeFile @"/dev/stdout" @"Hello, Самиздат!\n";
    };

    if { ^ eq file @"danfuzz"; } {
        writeFile @"/dev/stdout" @"Hello, Danfuzz!\n";
    } else {
        writeFile @"/dev/stdout" @"Hello, Самиздат!\n";
    };

    writeFile @"/dev/stdout" (toStringlet @0);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @98765);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @-12345);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@-1]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@1 @-2]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@-1 @2 @300]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @"");
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @"\"Blort.\" \n");
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[=]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@1=@2]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" (toStringlet @[@1=@2 @888=@1]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout"
        (toStringlet @[@"fizmo"=@"omzif" @"igram"=@"margi" @"blort"=@"trolb"]);
    writeFile @"/dev/stdout" @"\n";
    writeFile @"/dev/stdout" @"\n";

    programText = readFile file;

    tokens = tokenize programText;
    if { ^ eq tokens null; } { ^ @1; };

    statements = parse tokens;
    if { ^ eq statements null; } { ^ @1; };

    # TODO: Bind statements as a function using exposed interface from
    # samizdat-0, and call it.
};
