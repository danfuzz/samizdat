# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tree parser
#


#
# Helper functions
#

# Returns a `call` node.
makeCall = { function actuals* ::
    <> [:@call [@function=function @actuals=actuals]:]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* specification.
#

# Parses a `highlet` node.
parseHighlet = filterRule
    (seqRule
        [:"[":]
        [:":":]
        @atom
        (optRule @atom)
        [:":":]
        [:"]":])
    { result ::
        <> apply makeCall [:@varRef @makeHighlet:]
            (listNth result @2)
            (listNth result @3)
    };

# Parses a `uniqlet` node.
parseUniqlet = filterRule
    [:"@@":]
    { <> makeCall [:@varRef @makeUniqlet:] };

# Parses a `binding` node.
parseBinding = filterRule
    (seqRule @atom [:"=":] @atom)
    { result ::
        <> [(listNth result @0) (listNth result @2)]
    };

# Parses a `map` node.
parseMap = filterRule
    (seqRule [:"[":] (plusRule @binding) [:"]":])
    { result ::
        bindings = apply listAdd (listNth result @1);
        <> apply makeCall [:@varRef @makeMap:] bindings
    };

# Parses a `emptyMap` node.
parseEmptyMap = filterRule
    (seqRule [:"[":] [:"=":] [:"]":])
    { <> [:@literal [=]:] };

# Parses a `list` node.
parseList = filterRule
    (seqRule [:"[":] (plusRule @atom) [:"]":])
    { result ::
        <> apply makeCall [:@varRef @makeList:] (listNth result @1)
    };

# Parses a `emptyList` node.
parseEmptyList = filterRule
    (seqRule [:"[":] [:"]":])
    { <> [:@literal []:] };

# Parses a `string` node.
parseString = orRule
    (filterRule [:@string:]
        { result :: <> [:@literal (highletValue result):] })
    (filterRule (seqRule [:"@":] [:@identifier:])
        { result ::
            identifier = listNth result @1;
            <> [:@literal (highletValue identifier):]
        });

# Parses an `integer` node.
parseInteger = filterRule
    (seqRule [:"@":] (optRule [:"-":]) [:@integer:])
    { result ::
        sign = ifTrue { <> eq (listNth result @1) [] }
            { <> @1 } { <> @-1 };
        value = imul sign (highletValue (listNth result @2));
        <> [:@literal value:]
    };

# Parses a `varRef` node.
parseVarRef = filterRule
    [:@identifier:]
    { result :: <> [:@varRef (highletValue result):] };

# Parses a `varDef` node.
parseVarDef = filterRule
    (seqRule [:@identifier:] [:"=":] @expression)
    { result ::
        name = highletValue (listNth result @0);
        value = listNth result @2;
        <> [:@varDef [@name=name @value=value]:]
    };

# Parses a `parenExpression` node.
parseParenExpression = filterRule
    (seqRule [:"(":] @expression [:")":])
    { result :: <> listNth result @1 };

# Parses an `atom` node.
parseAtom = orRule @varRef @integer @string
    @emptyList @list @emptyMap @map
    @uniqlet @highlet @function @parenExpression;

# Parses a `callExpression` node.
parseCallExpression = filterRule
    (seqRule @atom (plusRule @atom))
    { result ::
        <> apply makeCall (listNth result @0) (listNth result @1)
    };

# Parses a `unaryCallExpression` node.
parseUnaryCallExpression = filterRule
    (seqRule
        @atom
        (plusRule (seqRule [:"(":] [:")":])))
    { result ::
        atom = listNth result @0;
        calls = listNth result @1;
        <> listReduce atom calls
            { result :: <> makeCall result }
    };

# Parses a `unaryExpression` node.
parseUnaryExpression = orRule @unaryCallExpression @atom;

# Parses an `expression` node.
parseExpression = orRule @callExpression @unaryExpression;

# Parses a `statement` node.
parseStatement = orRule @varDef @expression;

# Parses a `nonlocalExit` node.
parseNonlocalExit = filterRule
    (seqRule
        [:"<":]
        [:@identifier:]
        [:">":]
        (optRule @expression))
    { result ::
        varRef = [:@varRef (highletValue (listNth result @1)):];
        actuals = listNth result @3;
        <> apply makeCall varRef actuals
    };

# Parses a `yield` node.
parseYield = filterRule
    (seqRule [:"<>":] @expression)
    { result :: <> listNth result @1 };

# Parses a `yieldDef` node.
parseYieldDef = filterRule
    (seqRule [:"<":] [:@identifier:] [:">":])
    { result :: <> highletValue (listNth result @1) };

# Parses a `formal` node.
parseFormal = filterRule
    (seqRule
        (filterRule
            [:@identifier:]
            { result :: <> [@name = (highletValue result)] })
        (filterRule
            (optRule
                (orRule [:"*":] [:"?":]))
            { result ::
                <> ifValue { <> listNth result @0 }
                    { repeatToken :: <> [@repeat = repeatToken] }
                    { <> [=] }
            }))
    { result :: <> apply mapAdd result };

# `programBody` node helper: Parses `(statement | nonlocalExit | yield)?`,
# yielding a map that maps `@yield` and `@statements`. Always succeeds.
parseProgramBody1 = filterRule
    (optRule
        (orRule
            (filterRule
                (orRule @statement @nonlocalExit)
                { result :: <> [@statements=[result]] })
            (filterRule
                @yield
                { result :: <> [@statements=[] @yield=result] })))
    { result ::
        <> ifValue { <> listNth result @0 }
            { result :: <> result }
            { <> [@statements=[]] }
    };

# Parses a `programBody` node.
parseProgramBody = filterRule
    (seqRule
        (starRule [:";":])
        (starRule
            (filterRule
                (seqRule @statement (plusRule [:";":]))
                { result :: <> listNth result @0 }))
        parseProgramBody1
        (starRule [:";":]))
    { result ::
        mostStatements = listNth result @1;
        lastClause = listNth result @2;
        statements = listAdd mostStatements
            (mapGet lastClause @statements);
        <> mapPut lastClause @statements statements;
    };

# Parses a `programDeclarations` node.
parseProgramDeclarations = filterRule
    (seqRule
        (filterRule (starRule @formal)
            { result ::
                <> ifTrue { <> ne result [] }
                    { <> [@formals = result] }
                    { <> [=] }
            })
        (filterRule (optRule @yieldDef)
            { result ::
                <> ifValue { <> listNth result @0 }
                    { yieldDef :: <> [@yieldDef = yieldDef] }
                    { <> [=] }
            }))
    { result :: <> apply mapAdd result };

# `program` node helper: Parses `(programDeclarations [:"::":])?`, yielding
# a map (possibly empty).
parseProgram1 = filterRule
    (optRule (seqRule @programDeclarations [:"::":]))
    { result ::
        <> ifValue { <> listNth result @0 }
            { match :: <> listNth match @0 }
            { <> [=] }
    };

# Parses a `program` node.
parseProgram = filterRule
    (seqRule parseProgram1 @programBody)
    { result :: <> [:@function (apply mapAdd result):] };

# Parses a `function` node.
parseFunction = filterRule
    (seqRule [:"{":] @program [:"}":])
    { result :: <> listNth result @1 };

# Map of all of the parser rules. Any time a parser rule is needed,
# it's looked up through this map by name, which trivially allows for
# mutually-recursive rules (since the rules refer directly to names and
# not actual functions).
TREE0_RULES = [
    @atom = parseAtom
    @binding = parseBinding
    @callExpression = parseCallExpression
    @emptyList = parseEmptyList
    @emptyMap = parseEmptyMap
    @expression = parseExpression
    @formal = parseFormal
    @function = parseFunction
    @highlet = parseHighlet
    @integer = parseInteger
    @list = parseList
    @map = parseMap
    @nonlocalExit = parseNonlocalExit
    @parenExpression = parseParenExpression
    @program = parseProgram
    @programBody = parseProgramBody
    @programDeclarations = parseProgramDeclarations
    @statement = parseStatement
    @string = parseString
    @unaryExpression = parseUnaryExpression
    @unaryCallExpression = parseUnaryCallExpression
    @uniqlet = parseUniqlet
    @varDef = parseVarDef
    @varRef = parseVarRef
    @yield = parseYield
    @yieldDef = parseYieldDef
];

<> [@TREE0_RULES = TREE0_RULES]
