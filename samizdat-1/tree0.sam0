# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tree parser
#


#
# Helper functions
#

# Returns a `call` node.
makeCall = { function actuals* ::
    <> @["call" ["function"=function "actuals"=actuals]]
};

# Returns a `varRef` node.
makeVarRef = { name ::
    <> @["varRef" name]
};

# Returns a `call` node that names a function as a `varRef`.
makeCallName = { name actuals* ::
    <> @["call" ["function"=(makeVarRef name) "actuals"=actuals]]
};

# Returns a `literal` node.
makeLiteral = { value ::
    <> @["literal" value]
};


#
# Grammar rules
#
# The following is a near-transliteration of the tree grammar in
# the *Samizdat Layer 0* specification.
#

# forward-declaration: atom
# forward-declaration: expression
# forward-declaration: function

# Documented in Samizdat Layer 0 spec.
parseInt = pegMakeMainSequence
    (pegMakeToken @int)
    (pegMakeCode { int :: <> makeLiteral (highletValue int) });

# Documented in Samizdat Layer 0 spec.
parseString = pegMakeMainSequence
    (pegMakeToken @string)
    (pegMakeCode { string :: <> makeLiteral (highletValue string) });

# Documented in Samizdat Layer 0 spec.
parseEmptyList = pegMakeMainSequence
    (pegMakeToken @"[")
    (pegMakeToken @"]")
    (pegMakeCode { . . :: <> makeLiteral [] });

# Documented in Samizdat Layer 0 spec.
parseList = pegMakeMainSequence
    (pegMakeToken @"[")
    (pegMakeStar parseAtom)
    (pegMakeToken @"]")
    (pegMakeCode { . atoms . :: <> apply makeCallName "makeList" atoms });

# Documented in Samizdat Layer 0 spec.
parseEmptyMap = pegMakeMainSequence
    (pegMakeToken @"[")
    (pegMakeToken @"=")
    (pegMakeToken @"]")
    (pegMakeCode { . . . :: <> makeLiteral [=] });

# Documented in Samizdat Layer 0 spec.
parseBinding = pegMakeMainSequence
    parseAtom
    (pegMakeToken @"=")
    parseAtom
    (pegMakeCode { key . value :: <> [key value] });

# Documented in Samizdat Layer 0 spec.
parseMap = pegMakeMainSequence
    (pegMakeToken @"[")
    (pegMakePlus parseBinding)
    (pegMakeToken @"]")
    (pegMakeCode { . bindings . ::
        <> apply makeCallName "makeMap" (apply listAdd bindings)
    });

# Documented in Samizdat Layer 0 spec.
parseHighlet = pegMakeMainSequence
    (pegMakeToken @"@")
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeToken @"[")
            parseAtom
            (pegMakeOpt parseAtom)
            (pegMakeToken @"]")
            (pegMakeCode { . type value . ::
                <> apply makeCallName "makeHighlet" type value
            }))
        (pegMakeMainSequence
            (pegMakeTokenSet @string @identifier)
            (pegMakeCode { type ::
                <> makeCallName "makeHighlet" (makeLiteral (highletValue type))
            })));

# Documented in Samizdat Layer 0 spec.
parseUniqlet = pegMakeMainSequence
    (pegMakeToken @"@@")
    (pegMakeCode { . :: <> makeCallName "makeUniqlet" });

# Documented in Samizdat Layer 0 spec.
parseVarRef = pegMakeMainSequence
    (pegMakeToken @identifier)
    (pegMakeCode { name :: <> makeVarRef (highletValue name) });

# Documented in Samizdat Layer 0 spec.
parseVarDef = pegMakeMainSequence
    (pegMakeToken @identifier)
    (pegMakeToken @"=")
    parseExpression
    (pegMakeCode { name . ex ::
        <> @["varDef" ["name"=(highletValue name) "value"=ex]]
    });

# Documented in Samizdat Layer 0 spec.
parseParenExpression = pegMakeMainSequence
    (pegMakeToken @"(")
    parseExpression
    (pegMakeToken @")")
    (pegMakeCode { . ex . :: <> ex });

# Documented in Samizdat Layer 0 spec.
parseAtom = pegMakeMainSequence
    (pegMakeChoice
        parseVarRef parseInt parseString
        parseEmptyList parseList parseEmptyMap parseMap
        parseUniqlet parseHighlet parseFunction parenExpression);

# Documented in Samizdat Layer 0 spec.
parseCallExpression = pegMakeMainSequence
    parseAtom
    (pegMakePlus parseAtom)
    (pegMakeCode { function args :: <> apply makeCall function args });

# Documented in Samizdat Layer 0 spec.
parseUnaryCallExpression = pegMakeMainSequence
    parseAtom
    (pegMakePlus (pegMakeToken @"()"))
    (pegMakeCode { function calls ::
        <> listReduce function calls
            { result :: <> makeCall result }
    });

# Documented in Samizdat Layer 0 spec.
parseUnaryExpression = pegMakeMainSequence
    (pegMakeChoice parseUnaryCallExpression parseAtom);

# Documented in Samizdat Layer 0 spec.
parseExpression = pegMakeMainSequence
    (pegMakeChoice parseCallExpression parseUnaryExpression);

# Documented in Samizdat Layer 0 spec.
parseStatement = pegMakeMainSequence
    (pegMakeChoice parseVarDef parseExpression);

# Documented in Samizdat Layer 0 spec.
parseNonlocalExit = pegMakeMainSequence
    (pegMakeToken @"<")
    parseVarRef
    (pegMakeToken @">")
    (pegMakeOpt parseExpression)
    (pegMakeCode { . name . ex :: <> apply makeCall name ex });

# Documented in Samizdat Layer 0 spec.
parseYield = pegMakeMainSequence
    (pegMakeToken @"<>")
    (pegMakeChoice
        (pegMakeMainSequence
            parseExpression
            (pegMakeCode { ex :: <> ["yield" = ex] }))
        (pegMakeMainSequence
            (pegMakeCode { . :: <> [=] })));

# Documented in Samizdat Layer 0 spec.
parseYieldDef = pegMakeMainSequence
    (pegMakeToken @"<")
    (pegMakeToken @identifier)
    (pegMakeToken @">")
    (pegMakeCode { . name . :: <> highletValue name });

# Documented in Samizdat Layer 0 spec.
parseFormal = pegMakeMainSequence
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeToken @identifier)
            (pegMakeCode { n :: <> ["name" = n] }))
        (pegMakeMainSequence
            (pegMakeToken @".")
            (pegMakeCode { . :: <> [=] })))
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeTokenSet @"?" @"*" @"+")
            (pegMakeCode { r :: <> ["repeat" = (highletType r)] }))
        (pegMakeMainSequence
            (pegMakeCode { <> [=] })))
    (pegMakeCode { name repeat :: <> mapAdd name repeat });

# Documented in Samizdat Layer 0 spec.
parseProgramBody = pegMakeMainSequence
    (pegMakeStar (pegMakeToken @";"))
    (pegMakeStar
        (pegMakeMainSequence
            parseStatement
            (pegMakePlus (pegMakeToken @";"))
            (pegMakeCode { s . :: <> s })))
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakeChoice parseStatement parseNonlocalExit)
            (pegMakeCode { s :: <> ["statements" = s] }))
        (pegMakeMainSequence
            parseYield
            (pegMakeCode { y :: <> mapAdd ["statements" = []] y }))
        (pegMakeMainSequence
            (pegMakeCode { :: <> ["statements" = []] })))
    (pegMakeStar (pegMakeToken @";"))
    (pegMakeCode { . most last . ::
        allStatements = listAdd most (mapGet last "statements");
        <> mapPut last "statements" allStatements
    });

# Documented in Samizdat Layer 0 spec.
parseProgramDeclarations = pegMakeMainSequence
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakePlus parseFormal)
            (pegMakeCode { fs :: <> ["formals" = fs] }))
        (pegMakeMainSequence
            (pegMakeCode { <> [=] })))
    (pegMakeChoice
        (pegMakeMainSequence
            (pegMakePlus parseYieldDef)
            (pegMakeCode { y :: <> ["yieldDef" = y] }))
        (pegMakeMainSequence
            (pegMakeCode { <> [=] })))
    (pegMakeToken @"::")
    (pegMakeCode { formals yieldDef . :: <> mapAdd formals yieldDef });

# Documented in Samizdat Layer 0 spec.
parseProgram = pegMakeMainSequence
    (pegMakeChoice
        parseProgramDeclarations
        (pegMakeCode { <> [=] }))
    parseProgramBody
    (pegMakeCode { decls body :: <> @["function" (mapAdd decls body)] });

# Documented in Samizdat Layer 0 spec.
parseFunction = pegMakeMainSequence
    (pegMakeToken @"{")
    parseProgram
    (pegMakeToken @"}")
    (pegMakeCode { . prog . :: <> prog });

# Performs parsing of the given token list.
parse0 = { programTokens ::
    <> pegApply parseProgram programTokens
};

<> [
    "parse0" = parse0
]
