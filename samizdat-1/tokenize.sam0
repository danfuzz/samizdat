# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tokenizer
#


#
# Lookahead Reader
#
# A lookahead reader can read characters from a string, additionally
# allowing explicit backtracking.
#
# State consists of:
#
# * `@text` &mdash; The text being read.
# * `@size` &mdash; The size of the text in characters.
# * `@at` &mdash; The current cursor position.
#
# Convention: `do` prefix for public exposed functions, and `x` prefix for
# private non-dispatched functions.
#

# Gets the size.
xSize = { state :: mapletGet state @size };

# Gets the text.
xText = { state :: mapletGet state @text };

# Gets the cursor position.
xAt = { state :: mapletGet state @at };

# Gets the current cursor position.
doAt = { state :: <> @[@result=(xAt state)] };

# Returns whether the reader is at EOF.
doEof = { state :: <> @[@result=(lt (xAt state) (xSize state))] };

# Peeks at the next character without reading. Returns void at EOF.
doPeek = { state ::
    at = xAt state;
    <> ifValue { <> listletNth (xText state) at }
        { ch :: <> @[@result=ch] };
};

# Reads the next character. Returns void at EOF.
doRead = { state ::
    at = xAt state;
    <> ifValue { <> listletNth (xText state) at }
        { ch :: <> @[@result=ch @state=(mapletPut state @at (iadd at @1))] };
};

# Sets the cursor position to the given one.
doReset = { state at ::
    ifTrue { <> or { <> lt at @0 } { <> ge at (xSize state) } }
        { io0Die @"Reset out of range." };
    <> @[@state=(mapletPut state @at at)]
};

# Dispatch table.
READER_DISPATCH = @[
    @at    = doAt
    @eof   = doEof
    @peek  = doPeek
    @read  = doRead
    @reset = doReset
];

# Performs method dispatch.
readerDispatch = { state name rest* ::
    <> apply (mapletGet READER_DISPATCH name) state rest
};

# Returns a lookahead-enabled character reader.
makeReader = { programText ::
    <> object readerDispatch @[
        @at = @0
        @size = (lowSize programText)
        @text = programText
    ]
};


#
# Tokenizer function
#

# Mapping from valid string escapes to their translated characters.
STRING_ESCAPES = @[@"\\"=@"\\" @"\""=@"\"" @"n"=@"\n"];

# Parses a string escape.
parseStringEscape = { reader ::
    reader @read; # Skip the backslash.

    <> ifValue { <> reader @read }
        { ch ::
            <> ifValue { <> mapletGet STRING_ESCAPES ch }
                { translation :: <> translation }
        }
};

# Parses a string.
parseString = { reader ::
    reader @read; # Skip the open quote.

    value = whileReduce @"" { result ::
        <> ifValue { <> reader @peek }
            { ch ::
                <> ifTrue { <> ne ch @"\"" }
                    {
                        # TODO: Handle invalid escape sequences gracefully.
                        reader @read;
                        addCh = ifTrue { <> eq ch @"\\" }
                            { <> parseStringEscape reader }
                            { <> ch };
                        <> stringletAdd result addCh;
                    }
            }
    };

    # Skip the close quote, or complain if it was absent.
    <> ifVoid { <> reader @read }
        { <> [:@error @"Unterminated string literal.":] }
        { <> [:@string value:] }
};

# These are all the valid identifier characters, as a set-like maplet
# (all elements map to `null`).
IDENTIFIER_CHARS = listletReduce @[=]
    @[
        @"0" @"1" @"2" @"3" @"4" @"5" @"6" @"7" @"8" @"9" @"_"
        @"a" @"b" @"c" @"d" @"e" @"f" @"g" @"h" @"i" @"j" @"k" @"l" @"m"
        @"n" @"o" @"p" @"q" @"r" @"s" @"t" @"u" @"v" @"w" @"x" @"y" @"z"
        @"A" @"B" @"C" @"D" @"E" @"F" @"G" @"H" @"I" @"J" @"K" @"L" @"M"
        @"N" @"O" @"P" @"Q" @"R" @"S" @"T" @"U" @"V" @"W" @"X" @"Y" @"Z"
    ]
    { result ch :: <> mapletPut result ch null };

# Parses an identifier.
parseIdentifier = { reader ::
    value = whileReduce @"" { result ::
        <> ifValue { <> reader @peek }
            { ch ::
                ifValue { <> mapletGet IDENTIFIER_CHARS ch }
                    { reader @read; <> stringletAdd result ch }
            }
    };

    <> [:@identifier value:]
};

# These are all the integer digits, as a maplet from stringlets to
# digit values.
INTEGER_CHARS = listletReduce @[=]
    @[@0 @1 @2 @3 @4 @5 @6 @7 @8 @9]
    { result n ::
        # Note: 48 == "0".
        <> mapletPut result (stringletFromIntlet (iadd @48 n)) n
    };

# Parses an integer.
parseInteger = { reader ::
    value = whileReduce @0 { result ::
        <> ifValue { <> reader @peek }
            { ch ::
                <> ifValue { <> mapletGet INTEGER_CHARS ch }
                    { n :: <> (iadd n (imul result @10)) }
            }
    };

    <> [:@integer value:];
};

# Skips over all characters until and including a newline.
skipUntilNewline = { reader ::
    while {
        <> ifValue { <> reader @read } { ch :: <> ne ch @"\n" } { <> false }
    }
};

# Parsers for particular whitespace characters.
WHITESPACE_DISPATCH = @[
    @" "  = { reader :: reader @read }
    @"\n" = { reader :: reader @read }
    @"#"  = skipUntilNewline
];

# Skips any whitespace at the current cursor.
skipWhitespace = { reader ::
    while {
        <> ifVoid { <> reader @peek }
            { <> false }
            { ch ::
                <> ifValue { <> mapletGet WHITESPACE_DISPATCH ch }
                    { parser :: parser reader; <> true }
                    { <> false }
            }
    }
};

# Single-character parser. Reads a single character, returning that
# value directly as a token.
oneCharParser = { reader :: <> [:(reader @read):] };

# Makes a one-or-two-character parser, given a two-character string.
# The result is a function which reads a character, and then peeks at
# the next one. It consumes the second character only if it matches as
# indicated.
makeOneTwoParser = { twoChars ::
    ch2 = stringletNth twoChars @1;
    result1 = [:(stringletNth twoChars @0):];
    result2 = [:twoChars:];

    parser = { reader ::
        reader @read; # Only ever called when the first character matched.
        <> ifValue { <> reader @peek }
            { ch ::
                <> ifTrue { <> eq ch ch2 }
                    { reader @read; <> result2 }
                    { <> result1 }
            }
    };

    <> parser;
};

# Mapping from token start character to the corresponding parser to use.
# Note that the identifier mappings need to be listed before the integer
# ones, so that the latter overrides the ones that overlap with the former.
TOKEN_DISPATCH = mapletCat
    (mapletMap IDENTIFIER_CHARS { <> parseIdentifier })
    (mapletMap INTEGER_CHARS { <> parseInteger })
    @[
        @"\"" = parseString
        @"{"  = oneCharParser
        @"}"  = oneCharParser
        @"["  = oneCharParser
        @"]"  = oneCharParser
        @"("  = oneCharParser
        @")"  = oneCharParser
        @"="  = oneCharParser
        @"-"  = oneCharParser
        @";"  = oneCharParser
        @"*"  = oneCharParser
        @":"  = (makeOneTwoParser @"::")
        @"@"  = (makeOneTwoParser @"@@")
        @"<"  = (makeOneTwoParser @"<>")
    ];

# Reads a single token.
readToken = { reader ::
    skipWhitespace reader;
    <> ifValue { <> reader @peek }
        { ch ::
            <> ifValue { <> mapletGet TOKEN_DISPATCH ch }
                { parser :: <> parser reader }
                {
                    error = stringletCat @"No parser for character: "
                        (sourceStringlet ch);
                    skipUntilNewline reader; # Heuristic to help re-synch.
                    <> [:@error error:];
                }
        }
};

# Tokenizes the given string, using Samizdat Layer 0 token syntax.
# Returns a listlet of tokens.
tokenize = { programText ::
    reader = makeReader programText;

    <> whileReduce @[] { result ::
        <> ifValue { <> readToken reader }
            { token :: <> listletAppend result token }
    }
};

<> tokenize;
