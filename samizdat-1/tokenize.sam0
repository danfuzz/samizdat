# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Samizdat Layer 0 tokenizer
#
# The following is a near-transliteration of the token grammar in
# the *Samizdat Layer 0* specification.
#

# Parses an entire file of tokens.
parseFile = filterRule
    (seqRule
        (starRule
            (filterRule
                (seqRule (starRule @whitespace) @token)
                { result :: <> listletNth result @1 }))
        (starRule @whitespace))
    { result :: <> listletNth result @0 };

# Parses a single token.
parseToken = orRule @punctuation @integer @string @identifier;

# Parses any of the punctuation characters or character sequences, yielding
# a token whose type is the stringlet matched.
parsePunctuation = filterRule
    (orRule
        (charsRule @"@@")
        (charsRule @"::")
        (charsRule @"<>")
        (charSetRule @"@:*;=-?<>{}()[]"))
    { result :: <> [:result:] };

# These are all the integer digits, as a maplet from stringlets to
# digit values.
INTEGER_CHARS = listletReduce @[=]
    @[@0 @1 @2 @3 @4 @5 @6 @7 @8 @9]
    { result n ::
        # Note: 48 == "0".
        <> mapletPut result (stringletFromIntlet (iadd @48 n)) n
    };

# Parses an `integer` token.
parseInteger = filterRule
    (plusRule
        (filterRule
            (charSetRule @"0123456789")
            { result :: <> mapletGet INTEGER_CHARS result }))
    { result ::
        value = listletReduce @0 result
            { result digit :: <> iadd digit (imul result @10) };
        <> [:@integer value:]
    };

# Parses a single string character.
parseString1 = orRule
    (notCharSetRule @"\\\"")
    (filterRule
        (seqRule
            (charsRule @"\\")
            (orRule
                (filterRule (charsRule @"\\") { <> @"\\" })
                (filterRule (charsRule @"\"") { <> @"\"" })
                (filterRule (charsRule @"n")  { <> @"\n" })))
        { result :: <> listletNth result @1 });

# Parses a `string` token.
parseString = filterRule
    (seqRule
        (charsRule @"\"")
        (starRule parseString1)
        (charsRule @"\""))
    { result ::
        value = apply stringletAdd (listletNth result @1);
        <> [:@string value:]
    };

# These are all the characters which are allowed to start an identifier.
IDENTIFIER_START_CHARS =
    @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";

# These are all the characters which are allowed to be in an identifier.
IDENTIFIER_CHARS = stringletAdd IDENTIFIER_START_CHARS @"0123456789";

# Parses an `identifier` token.
parseIdentifier = filterRule
    (seqRule
        (charSetRule IDENTIFIER_START_CHARS)
        (starRule (charSetRule IDENTIFIER_CHARS)))
    { result ::
        value = stringletAdd
            (listletNth result @0)
            (apply stringletAdd (listletNth result @1));
        <> [:@identifier value:]
    };

# Parses a single whitespace character or a comment.
parseWhitespace = orRule
    (charSetRule @" \n")
    (seqRule
        (charsRule @"#")
        (starRule (notCharSetRule @"\n"))
        (charsRule @"\n"));

# Maplet of all the tokenizer rules.
RULES = @[
    @file = parseFile
    @identifier = parseIdentifier
    @integer = parseInteger
    @punctuation = parsePunctuation
    @string = parseString
    @token = parseToken
    @whitespace = parseWhitespace
];


#
# Main `tokenize` function
#

# Error helper, to read a line of text for reporting back.
readLine = filterRule
    (seqRule
        (starRule (notCharSetRule @"\n"))
        (questRule (charsRule @"\n")))
    { result :: <> apply stringletAdd (listletNth result @0) };

# Tokenizes the given string, using Samizdat Layer 0 token syntax.
# Returns a listlet of tokens.
tokenize = { programText ::
    theReader = reader programText;
    theEngine = pegEngine theReader RULES;
    theProgram = parseFile theEngine;

    ifFalse { <> theEngine @eof }
        {
            io0Note @"Extra text at end of program.";
            io0Note @"Pending text:";
            io0Die (readLine theEngine);
        };

    <> theProgram;
};

<> @[@tokenize = tokenize]
