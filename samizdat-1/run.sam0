# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `run` function, which is the effective main entry point to the program.
#

# This is the reader to use for reading internal files (e.g. and in
# particular, the embedded copy of samizdat-0-lib).
READER ::

# Parses the given program text, yielding a `program` node. This also
# compares the would-be result with the result of doing the same operation
# using the samizdat-0 facilities for same, complaining if they're not
# equal.
def sam1ValidatedTree = { programText ::
    # Parse the text using the layer 1 parsers.
    def programNode1 = sam1Tree(programText);

    # Do the same using the layer 0 parsers.
    def programNode0 = sam0Tree(programText);

    # Complain if the two parsed forms aren't identical.
    ifTrue { <> ne(programNode0, programNode1) }
        {
            io0Note("Parser disagreement.");
            diff(programNode0, programNode1);
            io0Note("");
            io0Note(format("v1\n----------\n%q\n", programNode0));
            io0Note(format("v2\n----------\n%q\n", programNode1));
            io0Die("Ouch!");
        };

    <> programNode1
};

# Reads the named embedded library file.
def readLibraryFile = { name ::
    <> READER(["samizdat-0-lib", name])
};

# Reads all the library files, returning a map from names to contents.
def readAllLibraryFiles = {
    # Use the manifest to figure out what all to read.
    def manifestText = readLibraryFile("manifest.sam0");
    def manifestProgram = sam0Eval(LIBRARY, sam0Tree(manifestText));
    def manifestBindings = manifestProgram();
    def BOOTSTRAP_FILES = mapGet(manifestBindings, "BOOTSTRAP_FILES");
    def MANIFEST = mapGet(manifestBindings, "MANIFEST");

    <> listReduce([:], [BOOTSTRAP_FILES*, MANIFEST*])
        { result, ., name :: <> [result*, (name): readLibraryFile(name)] }
};

# Makes the core library by using this program's parser to parse the library
# source text.
def makeCoreLibrary = {
    # Make the core library context that will be used to load the embedded
    # core library. The only difference between this and the original core
    # library is the replacement of `sam0Tree` with `sam1ValidatedTree`.
    def subLibrary = makeLibrary([LIBRARY*, sam0Tree: sam1ValidatedTree]);

    def libraryFiles = readAllLibraryFiles();

    def mainProgram = sam1Tree(mapGet(libraryFiles, "main.sam0"));
    def mainFunction = sam0Eval(subLibrary, mainProgram);
    <> mainFunction(libraryFiles)
};

# Compiles the file named in the first argument in a fresh context,
# and runs it, passing it an array consisting of its own file path
# (in standard list-of-string form) followed by the rest of the
# arguments as-is.
def run = { args* ::
    def parsedArgs = parseArgs0(args);
    def allArgs = mapGet(parsedArgs, "args");
    def options = mapGet(parsedArgs, "options");
    def validate = mapGet(options, "validate", false);

    ifTrue { <> eq(allArgs, []) } { io0Die("Missing file name.") };
    def file = listFirst(allArgs);
    def argsPerSe = listButFirst(allArgs);

    def library = ifTrue { <> validate }
        {
            def lib = makeCoreLibrary();
            <> lib
        }
        { <> LIBRARY };

    def filePath = io0PathFromFlat(file);
    def programText = io0ReadFileUtf8(filePath);
    def programNode = sam1ValidatedTree(programText);

    # Evaluate the program in the context of the samizdat-0 core library.
    def function = sam1Eval(makeLibrary(library), programNode);

    # Run it!
    <> function(filePath, argsPerSe*)
};

<> [run: run]
