# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `run` function, which is the effective main entry point to the program.
#

# This is the reader to use for reading internal files (e.g. and in
# particular, the embedded copy of samizdat-0-lib).
READER ::

# Parses the given program text, yielding a `program` node. This also
# compares the would-be result with the result of doing the same operation
# using the samizdat-0 facilities for same, complaining if they're not
# equal.
sam1ValidatedTree = { programText ::
    # Parse the text using the layer 1 parsers.
    programNode1 = sam1Tree(programText);

    # Do the same using the layer 0 parsers.
    programNode0 = sam0Tree(programText);

    # Complain if the two parsed forms aren't identical.
    ifTrue { <> ne(programNode0, programNode1) }
        {
            io0Note("Parser disagreement.");
            diff(programNode0, programNode1);
            io0Note("");
            io0Note(format("v1\n----------\n%q\n", programNode0));
            io0Note(format("v2\n----------\n%q\n", programNode1));
            io0Die("Ouch!");
        };

    <> programNode1
};

# Reads the named embedded library file.
readLibraryFile = { name ::
    <> READER(["samizdat-0-lib", name])
};

# Reads all the library files, returning a map from names to contents.
readAllLibraryFiles = {
    # Use the manifest to figure out what all to read.
    manifestText = readLibraryFile("manifest.sam0");
    manifestProgram = sam0Eval(LIBRARY, sam0Tree(manifestText));
    manifestBindings = manifestProgram();
    BOOTSTRAP_FILES = mapGet(manifestBindings, "BOOTSTRAP_FILES");
    MANIFEST = mapGet(manifestBindings, "MANIFEST");

    <> listReduce([:], [BOOTSTRAP_FILES*, MANIFEST*])
        { result, ., name :: <> mapPut(result, name, readLibraryFile(name)) }
};

# Makes the core library by using this program's parser to parse the library
# source text.
makeCoreLibrary = {
    # Make the core library context that will be used to load the embedded
    # core library. The only difference between this and the original core
    # library is the replacement of `sam0Tree` with `sam1ValidatedTree`.
    subLibrary = makeLibrary(mapPut(LIBRARY, "sam0Tree", sam1ValidatedTree));

    libraryFiles = readAllLibraryFiles();

    mainProgram = sam1Tree(mapGet(libraryFiles, "main.sam0"));
    mainFunction = sam0Eval(subLibrary, mainProgram);
    <> mainFunction(libraryFiles)
};

# Compiles the file named in the first argument in a fresh context,
# and runs it, passing it an array consisting of its own file path
# (in standard list-of-string form) followed by the rest of the
# arguments as-is.
run = { args* ::
    parsedArgs = parseArgs0(args);
    allArgs = mapGet(parsedArgs, "args");
    options = mapGet(parsedArgs, "options");
    validate = mapGet(options, "validate", false);

    ifTrue { <> eq(allArgs, []) } { io0Die("Missing file name.") };
    file = listFirst(allArgs);
    argsPerSe = listButFirst(allArgs);

    library = ifTrue { <> validate }
        {
            lib = makeCoreLibrary();
            <> lib
        }
        { <> LIBRARY };

    filePath = io0PathFromFlat(file);
    programText = io0ReadFileUtf8(filePath);
    programNode = sam1ValidatedTree(programText);

    # Evaluate the program in the context of the samizdat-0 core library.
    function = sam1Eval(makeLibrary(library), programNode);

    # Run it!
    <> function(filePath, argsPerSe*)
};

<> ["run": run]
