# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Structural value diff.
#

# Reports a difference.
report = { context v1 v2 message ::
    io0Note message;
    listletForEach context
        { item ::
            io0Note (format @"    at %Q" item);
            <> null
        };
    io0Note @"";
    io0Note (format @"v1 = %q" v1);
    io0Note (format @"v2 = %q" v2);
    <> false;
};

# Diffs highlets.
diffHighlet = { recurse context v1 v2 ::
    type1 = highletType v1;
    type2 = highletType v2;
    has1 = highletHasValue v1;
    has2 = highletHasValue v2;
    value1 = highletValue v1 null;
    value2 = highletValue v2 null;

    <> and
        { <> recurse @type type1 type2 }
        { <> recurse @hasValue has1 has2 }
        { <> recurse @value value1 value2 }
};

# Diffs integers.
diffInteger = { recurse context v1 v2 ::
    <> report context v1 v2 @"Different integers."
};

# Diffs maplets.
diffMaplet = { recurse context v1 v2 <out> ::
    size1 = lowSize v1;
    size2 = lowSize v2;

    <> and
        { <> recurse @size size1 size2 }
        {
            mapletForEach v1
                { value key ::
                    ifVoid { <> mapletGet v2 key }
                        {
                            report (listletAppend context key) v1 v2
                                @"Key mismatch.";
                            <out> false
                        }
                };
            <> true
        }
        {
            mapletForEach v1
                { value key ::
                    ifFalse { <> recurse @[@key=key] value (mapletGet v2 key) }
                        { <out> false }
                };
            <> true
        }
};

# Diffs listlets.
diffListlet = { recurse context v1 v2 ::
    size1 = lowSize v1;
    size2 = lowSize v2;

    <> and
        { <> recurse @size size1 size2 }
        {
            listletForEach v1
                { elem index ::
                    recurse index elem (listletNth v2 index)
                };
            <> false
        }
};

# Diffs strings.
diffString = { recurse context v1 v2 ::
    <> report context v1 v2 @"Different strings."
};

# Diffs uniqlets.
diffUniqlet = { recurse context v1 v2 ::
    <> report context v1 v2 @"Different uniqlets."
};

# Mapping from type names to diff functions.
DIFF_FUNCTIONS = @[
    @highlet   = diffHighlet
    @integer    = diffInteger
    @listlet   = diffListlet
    @maplet    = diffMaplet
    @string = diffString
    @uniqlet   = diffUniqlet
];

# Inner diff. Returns an `eq` result.
innerDiff = { selfRef context v1 v2 ::
    type1 = lowType v1;
    type2 = lowType v2;
    innerContext = listletAppend context type1;

    # The `selfRef` and `recurse` definitions here are effectively a
    # "manual inlining" of the Y combinator, necessitated by the fact that
    # *Samizdat Layer 0* doesn't allow use-before-def.
    recurse = { newContext v1 v2 ::
        <> selfRef selfRef (listletAppend innerContext newContext) v1 v2
    };

    <> ifTrue { <> ne v1 v2 }
        {
            type1 = lowType v1;
            type2 = lowType v2;

            <> ifTrue { <> ne type1 type2 }
                {
                    <> report context v1 v2
                        (format @"Types differ: %q %q" type1 type2)
                }
                {
                    <> (mapletGet DIFF_FUNCTIONS type1) recurse innerContext
                        v1 v2
                }
        }
        { <> true }
};

# Compares two values structurally, reporting on the differences.
diff = { v1 v2 ::
    <> innerDiff innerDiff @[@top] v1 v2
};

<> @[@diff = diff]
