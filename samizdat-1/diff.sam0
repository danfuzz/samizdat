# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# Structural value diff.
#

# Reports a difference.
report = { context v1 v2 message ::
    io0Note message;
    listForEach context
        { . item ::
            io0Note (format "    at %Q" item);
            <> null
        };
    io0Note "";
    io0Note (format "v1 = %q" v1);
    io0Note (format "v2 = %q" v2);
    <> false;
};

# Diffs highlets.
diffHighlet = { recurse context v1 v2 ::
    type1 = highletType v1;
    type2 = highletType v2;
    has1 = highletHasValue v1;
    has2 = highletHasValue v2;
    value1 = highletValue v1 null;
    value2 = highletValue v2 null;

    <> and
        { <> recurse @type type1 type2 }
        { <> recurse @hasValue has1 has2 }
        { <> recurse @value value1 value2 }
};

# Diffs integers.
diffInteger = { recurse context v1 v2 ::
    <> report context v1 v2 "Different integers."
};

# Diffs maps.
diffMap = { recurse context v1 v2 <out> ::
    size1 = lowSize v1;
    size2 = lowSize v2;

    <> and
        { <> recurse @size size1 size2 }
        {
            mapForEach v1
                { key value ::
                    ifVoid { <> mapGet v2 key }
                        {
                            report (listAppend context key) v1 v2
                                "Key mismatch.";
                            <out> false
                        }
                };
            <> true
        }
        {
            mapForEach v1
                { key value ::
                    ifFalse { <> recurse [@key=key] value (mapGet v2 key) }
                        { <out> false }
                };
            <> true
        }
};

# Diffs lists.
diffList = { recurse context v1 v2 ::
    size1 = lowSize v1;
    size2 = lowSize v2;

    <> and
        { <> recurse @size size1 size2 }
        {
            listForEach v1
                { index elem ::
                    recurse index elem (listNth v2 index)
                };
            <> false
        }
};

# Diffs strings.
diffString = { recurse context v1 v2 ::
    <> report context v1 v2 "Different strings."
};

# Diffs uniqlets.
diffUniqlet = { recurse context v1 v2 ::
    <> report context v1 v2 "Different uniqlets."
};

# Mapping from type names to diff functions.
DIFF_FUNCTIONS = [
    @highlet = diffHighlet
    @integer = diffInteger
    @list    = diffList
    @map     = diffMap
    @string  = diffString
    @uniqlet = diffUniqlet
];

# Inner diff. Returns an `eq` result.
innerDiff = { selfRef context v1 v2 ::
    type1 = lowType v1;
    type2 = lowType v2;
    innerContext = listAppend context type1;

    # The `selfRef` and `recurse` definitions here are effectively a
    # "manual inlining" of the Y combinator, necessitated by the fact that
    # *Samizdat Layer 0* doesn't allow use-before-def.
    recurse = { newContext v1 v2 ::
        <> selfRef selfRef (listAppend innerContext newContext) v1 v2
    };

    <> ifTrue { <> ne v1 v2 }
        {
            type1 = lowType v1;
            type2 = lowType v2;

            <> ifTrue { <> ne type1 type2 }
                {
                    <> report context v1 v2
                        (format "Types differ: %q %q" type1 type2)
                }
                {
                    <> (mapGet DIFF_FUNCTIONS type1) recurse innerContext
                        v1 v2
                }
        }
        { <> true }
};

# Compares two values structurally, reporting on the differences.
diff = { v1 v2 ::
    <> innerDiff innerDiff [@top] v1 v2
};

<> [@diff = diff]
