# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `parseArgs` function, which parses command-line arguments.
#

# wordBreak = {/ "\0" /}
parseWordBreak = pegMakeToken "\0";

# word = {/
#     chars=[! "\0"]* wordBreak
#     { <> apply stringAdd chars }
# /}
parseWord = pegMakeMainSequence
    (pegMakeStar (pegMakeCharSetComplement "\0"))
    parseWordBreak
    (pegMakeCode { chars . ::
        <> stringFromTokenList chars
    });

# key = {/
#     chars=[! "=\0"]*
#     { <> apply stringAdd chars }
# /}
parseKey = pegMakeMainSequence
    (pegMakeStar (pegMakeCharSetComplement "=\0"))
    (pegMakeCode { chars ::
        <> stringFromTokenList chars
    });

# keyValue = {/
#     "--" k=key "=" v=word
#     { <> [k = v] }
# /}
parseKeyValue = pegMakeMainSequence
    (pegMakeString "--")
    parseKey
    (pegMakeToken "=")
    parseWord
    (pegMakeCode { . k . v :: <> [k = v] });

# flag = {/
#     "--" w=word
#     { <> [w = true] }
# /}
parseFlag = pegMakeMainSequence
    (pegMakeString "--")
    parseWord
    (pegMakeCode { . w :: <> [w = true] });

# error = {/
#     "-" [! "-\0"] word
#     { ... <> [error = true] }
# /}
parseError = pegMakeMainSequence
    (pegMakeToken "-")
    (pegMakeCharSetComplement "-\0")
    parseWord
    (pegMakeCode { ch1 ch2 word ::
        value = stringAdd (stringFromTokens ch1 ch2) word;
        io0Note (format "Unknown option: %Q" value);
        <> [error = true]
    });

# option = {/
#     flag | keyValue | error
# /}
parseOption = pegMakeChoice parseFlag parseKeyValue parseError;

# arguments = {/
#     optList=option* ("--" wordBreak)? words=word*
#     { ... <> ["options"=options "file"=file "args"=args] }
# /}
parseArguments = pegMakeMainSequence
    (pegMakeStar parseOption)
    (pegMakeOpt (pegMakeSequence (pegMakeString "--") parseWordBreak))
    (pegMakeStar parseWord)
    (pegMakeCode { optList . words ::
        options = apply mapAdd optList;
        ifTrue { <> mapGet options "error" false }
            { io0Die "Trouble with options." };
        ifTrue { <> eq (lowSize words) 0 }
            { io0Die "Missing file name." };
        file = listFirst words;
        args = listButFirst words;
        <> [
            "options" = options
            "file" = file
            "args" = args
        ]
    });

# Parses the command-line arguments. Starts by appending all the
# arguments-as-given together with a "\0" at the end of each. Then
# it uses the peg grammar above to split them back apart.
parseArgs = { args ::
    # Make a unified string with each argument "\0"-terminated.
    argString = listReduce "" args
        { result . arg ::
            <> stringAdd result arg "\0";
        };

    <> pegApply parseArguments argString
};

<> ["parseArgs" = parseArgs]
