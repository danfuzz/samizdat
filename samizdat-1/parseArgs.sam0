# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `parseArgs` function, which parses command-line arguments.
#

#
# Grammar:
#
# arguments ::= options ("--" wordBreak)? words ;
# options ::= ((option | error) wordBreak)* ;
# error ::= "-" ~("\0")+ ;
# option ::= "--" key value? ;
# key ::= ~("=" | "\0")+ ;
# value ::= "=" word ;
# words ::= (word wordBreak)* ;
# word ::= ~("\0")* ;
# wordBreak ::= "\0" ;
#

# The character @"\0".
CHAR_0 = stringletFromIntlet @0;

parseArguments = filterRule
    (seqRule
        @options
        (questRule (charsRule (stringletAdd @"--" CHAR_0)))
        @words)
    { result ::
        optsErrors = listletNth result @0;
        words = listletNth result @2;
        # TODO
        <> result
    };

parseOptions = starRule
    (filterRule
        (seqRule
            (orRule @option @error)
            @wordBreak)
        { result :: <> listletNth result @0 });

parseError = filterRule
    (seqRule
        (charsRule @"-")
        (plusRule (notCharSetRule CHAR_0)))
    { result ::
        elems = apply listletPrepend result;
        value = apply stringletAdd elems;
        <> @[@errors = @[value]]
    };

parseOption = filterRule
    (seqRule (charsRule @"--") @key (questRule @value))
    { result ::
        key = listletNth result @1;
        valueHolder = listletNth result @2;
        <> ifValue { <> listletNth valueHolder @0 }
            { value :: <> @[@options = @[@key=key @value=value]] }
            { <> @[@options = @[@key=key]] }
    };

parseKey = filterRule
    (plusRule
        (notCharSetRule (stringletAdd @"=" CHAR_0)))
    { result :: <> apply stringletAdd result };

parseValue = filterRule
    (seqRule (charsRule @"=") @word)
    { result :: <> listletNth result @1 };

parseWords = starRule
    (filterRule
        (seqRule @word @wordBreak)
        { result :: <> listletNth result @0 });

parseWord = filterRule
    (starRule (notCharSetRule CHAR_0))
    { result :: <> apply stringletAdd result };

parseWordBreak = charsRule CHAR_0;

RULES = @[
    @arguments = parseArguments
    @error = parseError
    @key = parseKey
    @option = parseOption
    @options = parseOptions
    @value = parseValue
    @word = parseWord
    @wordBreak = parseWordBreak
    @words = parseWords
];

parseArgsNew = { args ::
    # Make a unified string with each argument "\0"-terminated.
    argString = listletReduce @"" args
        { result arg ::
            <> stringletAdd result arg CHAR_0;
        };

    theReader = reader argString;
    theEngine = pegEngine theReader RULES;

    <> parseArguments theEngine;
};

# Parses the command-line arguments. Starts by appending all the
# arguments-as-given together with a "\0" at the end of each. Then
# it uses the parser engine to split them back apart.
parseArgs = { args <out> ::
    ifValue { <> parseArgsNew args }
        { args :: io0Note (format @"=== new-style args %q" args) }
        { io0Note @"=== no args?" };
    # io0Die @"woo";

    # TODO: This is the old implementation.
    <> listletReduce @[@validate=false @args=@[]] args { result arg ::
        <> ifTrue { <> eq arg @"--validate" }
            { <> mapletPut result @validate true }
            {
                <> ifValue { <> mapletGet result @file }
                    {
                        args = listletAppend (mapletGet result @args) arg;
                        <> mapletPut result @args args
                    }
                    { <> mapletPut result @file arg }
            }
    }
};

<> @[@parseArgs = parseArgs]
