# Copyright 2013 the Samizdat Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License,
# Version 2.0. Details: <http://www.apache.org/licenses/LICENSE-2.0>

#
# `parseArgs` function, which parses command-line arguments.
#

#
# Grammar:
#
# arguments ::= options ("--" wordBreak)? words ;
# options ::= ((option | error) wordBreak)* ;
# error ::= "-" ~("-" | "\0") ~("\0")*;
# option ::= "--" key value? ;
# key ::= ~("=" | "\0")+ ;
# value ::= "=" word ;
# words ::= (word wordBreak)* ;
# word ::= ~("\0")* ;
# wordBreak ::= "\0" ;
#

# The character "\0".
CHAR_0 = stringFromInteger 0;

parseArguments = filterRule
    (seqRule
        @options
        (optRule (charsRule (stringAdd "--" CHAR_0)))
        @words)
    { result ::
        optsErrors = listNth result 0;
        words = listNth result 2;
        ifTrue { <> mapGet optsErrors @errors }
            { io0Die "Trouble with options." };
        ifTrue { <> eq (lowSize words) 0 }
            { io0Die "Missing file name." };
        fileName = listNth words 0;
        args = listDelNth words 0;
        <> [
            @options = (mapGet optsErrors @options)
            @file = fileName
            @args = args
        ]
    };

parseOptions = filterRule
    (starRule
       (filterRule
            (seqRule (orRule @option @error) @wordBreak)
            { result :: <> listNth result 0 }))
    { result ::
        <> listReduce [@options=[=] @errors=false] result
            { result . one :: <> one result }
    };

parseError = filterRule
    (seqRule
        (charsRule "-")
        (notCharSetRule (stringAdd "-" CHAR_0))
        (starRule (notCharSetRule CHAR_0)))
    { result ::
        c0 = listNth result 0;
        c1 = listNth result 1;
        more = listNth result 2;
        value = apply stringAdd c0 c1 more;
        io0Note (format "Unknown option: %Q" value);
        <> { result :: <> mapPut result @errors true }
    };

parseOption = filterRule
    (seqRule (charsRule "--") @key (optRule @value))
    { result ::
        key = listNth result 1;
        valueHolder = listNth result 2;
        value = ifValue { <> listNth valueHolder 0 }
            { value :: <> value }
            { <> true };
        <> { result ::
            options = mapPut (mapGet result @options) key value;
            <> mapPut result @options options
        }
    };

parseKey = filterRule
    (plusRule
        (notCharSetRule (stringAdd "=" CHAR_0)))
    { result :: <> apply stringAdd result };

parseValue = filterRule
    (seqRule (charsRule "=") @word)
    { result :: <> listNth result 1 };

parseWords = starRule
    (filterRule
        (seqRule @word @wordBreak)
        { result :: <> listNth result 0 });

parseWord = filterRule
    (starRule (notCharSetRule CHAR_0))
    { result :: <> apply stringAdd result };

parseWordBreak = charsRule CHAR_0;

RULES = [
    @arguments = parseArguments
    @error = parseError
    @key = parseKey
    @option = parseOption
    @options = parseOptions
    @value = parseValue
    @word = parseWord
    @wordBreak = parseWordBreak
    @words = parseWords
];

# Parses the command-line arguments. Starts by appending all the
# arguments-as-given together with a "\0" at the end of each. Then
# it uses the parser engine to split them back apart.
parseArgs = { args ::
    # Make a unified string with each argument "\0"-terminated.
    argString = listReduce "" args
        { result . arg ::
            <> stringAdd result arg CHAR_0;
        };

    theReader = reader argString;
    theEngine = pegEngine theReader RULES;

    <> parseArguments theEngine;
};

<> [@parseArgs = parseArgs]
